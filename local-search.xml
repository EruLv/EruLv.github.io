<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Leetcoed_week_1</title>
    <link href="/EruLv.github.io/2020/06/17/Leetcode-week-1/"/>
    <url>/EruLv.github.io/2020/06/17/Leetcode-week-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-打卡-week-1"><a href="#Leetcode-打卡-week-1" class="headerlink" title="Leetcode 打卡 week 1"></a>Leetcode 打卡 week 1</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例</strong></p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><p>暴力枚举$O(n^2)$</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; res;        int n = nums.size();        for(int i = 0; i &lt; n; i++){            for(int j = i; j&lt;n; j++){                if( i!=j &amp;&amp; nums[i] + nums[j] == target){                    res.push_back(i);                    res.push_back(j);                }            }        }        return res;    }};</code></pre><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>排序 + 双指针, 参考<a href="https://www.acwing.com/problem/content/802/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/802/</a></p><p>因为需要存下标，很不推荐这种方法。</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; res;        vector&lt;pair&lt;int, int&gt;&gt; a;        for(int i = 0; i&lt; nums.size();i++) a.push_back({nums[i], i});        sort(a.begin(),a.end());  //升序，nlogn        for(int i = 0, j = 0; i&lt;a.size(); i++){    //O(2n)            while(a[i].first + a[j].first &lt; target) j++;            if( i != j &amp;&amp;a[i].first + a[j].first == target) {                res.push_back(a[i].second);                res.push_back(a[j].second);            }        }        sort(res.begin(), res.end());        return res;    }};</code></pre><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h4><p>Hash map</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int, int&gt; heap;    //基于散列表，查找时间为O(1)        for(int i = 0; i&lt; nums.size(); i++){            int r = target - nums[i];   //寻找目标值            if (heap.count(r)) return {heap[r], i};    //判断是否存在该键            heap[nums[i]] = i;        }        return {};    }};</code></pre><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><pre><code class="lang-c++">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="lang-c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {        ListNode* head = new ListNode(-1);        ListNode* cur = head;        int t = 0;  //进位        while(l1 || l2 || t){   //若t最后为1，需要添加一个节点            if(l1) t += l1-&gt;val, l1 = l1-&gt;next;            if(l2) t += l2-&gt;val, l2 = l2-&gt;next;            cur-&gt;next = new ListNode(t % 10);            cur = cur-&gt;next;            t /= 10;        }        return head-&gt;next;    }};</code></pre><h3 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>双指针算法.</p><p> 假设[j,i]为最长无重复字串，i向后移动时，j只能不动或向后移动。</p><pre><code class="lang-c++">class Solution {public:    int lengthOfLongestSubstring(string s) {        unordered_map&lt;char, int&gt; heap;        int res = 0;        for(int i =0, j = 0; i&lt;s.size();i++){            heap[s[i]] ++;            while(heap[s[i]] &gt; 1){                heap[s[j]] --;                j ++;            }            res = max(res, i - j + 1);        }    return res;    }};</code></pre><p>以”pwwkew”为例：</p><pre><code class="lang-c++">i = 0, j = 0, {p:1}i = 1, j = 0, {p:1, w:1}i = 2, j = 0, {p:1, w:2}     -&gt; j++, {w:2}     -&gt; j++, {w:1}i = 3, j = 2, {k:1, w:1}i = 4, j = 2, {k:1, w:1, e:1}i = 5, j = 2, {k:1, w:2, e:1}...</code></pre><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h3><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p><strong>示例 1:</strong></p><pre><code>nums1 = [1, 3]nums2 = [2]则中位数是 2.0</code></pre><p><strong>示例 2:</strong></p><pre><code>nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>思想和归并排序相同。$O(m+n)$</p><pre><code class="lang-c++">class Solution {public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        double res;        vector&lt;int&gt; r;        int i = 0 , j = 0;        while(i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()){            if(nums1[i] &lt; nums2[j]) r.push_back(nums1[i++]);            else r.push_back(nums2[j++]);        }        while(i &lt; nums1.size()) r.push_back(nums1[i++]);        while(j &lt; nums2.size()) r.push_back(nums2[j++]);        int n = nums1.size() +  nums2.size();        if(n%2 == 0)            res = double(r[n&gt;&gt;1] + r[n-1&gt;&gt;1])/2;        else res = r[n&gt;&gt;1];        return res;    }};</code></pre><h4 id="Solution-2-1"><a href="#Solution-2-1" class="headerlink" title="Solution 2"></a>Solution 2</h4>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oj好题错题集</title>
    <link href="/EruLv.github.io/2020/06/11/oj%E9%94%99%E9%A2%98%E9%9B%86/"/>
    <url>/EruLv.github.io/2020/06/11/oj%E9%94%99%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="oj好题错题集"><a href="#oj好题错题集" class="headerlink" title="oj好题错题集"></a>oj好题错题集</h1><h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1.模拟"></a>1.模拟</h2><h3 id="1-1-蚂蚁坠落"><a href="#1-1-蚂蚁坠落" class="headerlink" title="1.1 蚂蚁坠落"></a>1.1 蚂蚁坠落</h3><pre><code>https://www.nowcoder.com/practice/fdd6698014c340178a8b1f28ea5fadf8?tpId=40&amp;&amp;tqId=21420&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/kaoyan/question-ranking</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>c++ 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm排序</title>
    <link href="/EruLv.github.io/2020/06/11/Algoritm%E6%8E%92%E5%BA%8F/"/>
    <url>/EruLv.github.io/2020/06/11/Algoritm%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="基础算法-一-——排序"><a href="#基础算法-一-——排序" class="headerlink" title="基础算法(一)——排序"></a>基础算法(一)——排序</h2><h3 id="1-快排"><a href="#1-快排" class="headerlink" title="1.快排"></a>1.快排</h3><p>快排是不稳定的。</p><p>基于<strong>分治</strong>，步骤:</p><ol><li>确定分界点</li><li>调整区间，&lt;=x在x左边，&gt;=x的在x右边。</li><li>递归，左边右边排序。</li></ol><pre><code class="lang-c++">void quick_sort(int q[], int l, int r){    if(l&gt;=r) return;    int x = q[l+r&gt;&gt;1], i = l - 1, j = r + 1;    while(i &lt; j){        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);    }    quick_sort(q,l,j);    quick_sort(q,j+1,r);}</code></pre><h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h3><p>归并排序是稳定的。</p><ol><li>确定分界点。mid = (l+r)/2</li><li>递归排序left,right</li><li>归并，合二为一</li></ol><pre><code class="lang-c++">void merge_sort(int q[], int l, int r){    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法 排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algoritm模板</title>
    <link href="/EruLv.github.io/2020/06/10/Algoritm%E6%A8%A1%E6%9D%BF/"/>
    <url>/EruLv.github.io/2020/06/10/Algoritm%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="C-常用算法模板（一）"><a href="#C-常用算法模板（一）" class="headerlink" title="C++常用算法模板（一）"></a>C++常用算法模板（一）</h2><p>字符串、数字、数组的基础操作。</p><h3 id="1-反序数"><a href="#1-反序数" class="headerlink" title="1.反序数"></a>1.反序数</h3><p>1234-&gt;4321。</p><p>可用于判断数字是否对称。</p><pre><code class="lang-c++">int reverse(int x){    //反序数    int r = 0;    while(x!=0){        r *= 10;        r += x%10;        x /= 10;    }     return r;}</code></pre><h4 id="2-字符串反转"><a href="#2-字符串反转" class="headerlink" title="2.字符串反转"></a>2.字符串反转</h4><pre><code class="lang-c++">string reverse(string s){    string r = &quot;&quot;;    for(int i=s.size()-1;i&gt;=0;i--){        r += s[i];    }    return r;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法 c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT甲级1001</title>
    <link href="/EruLv.github.io/2020/05/22/PAT%E7%94%B2%E7%BA%A71001/"/>
    <url>/EruLv.github.io/2020/05/22/PAT%E7%94%B2%E7%BA%A71001/</url>
    
    <content type="html"><![CDATA[<h2 id="A-B-Format"><a href="#A-B-Format" class="headerlink" title="A+B Format"></a>A+B Format</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Calculate A + B and output the sum in standard format—hat is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where  </p><script type="math/tex; mode=display">-10^6<= a,b <= 10^6</script><p>The numbers are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="lang-c++">-1000000 9</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="lang-c++">-999,991</code></pre><h3 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution:"></a>My Solution:</h3><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    int a,b;    cin&gt;&gt;a&gt;&gt;b;    int r = a+b;    if(r==0){        cout&lt;&lt;0&lt;&lt;endl;        return 0;    }    int flag = r/abs(r);    if(flag==-1)        cout&lt;&lt;&quot;-&quot;;    string s = to_string(abs(r));    int j = 3-s.size()%3;    bool f = j==0;    for(int i=0;i&lt;s.size();i++){        if((i+j)%3==0 &amp;&amp; i!=0){             cout&lt;&lt;&quot;,&quot;;        }        cout&lt;&lt;s[i];    }    cout&lt;&lt;endl;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>字符串处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/EruLv.github.io/2020/05/22/test/"/>
    <url>/EruLv.github.io/2020/05/22/test/</url>
    
    <content type="html"><![CDATA[<h1 id="This-is-a-test"><a href="#This-is-a-test" class="headerlink" title="This is a test."></a>This is a test.</h1>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp常用函数</title>
    <link href="/EruLv.github.io/2020/03/19/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/EruLv.github.io/2020/03/19/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="c-常用函数"><a href="#c-常用函数" class="headerlink" title="c++常用函数"></a>c++常用函数</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort:"></a>sort:</h4><p>头文件:</p><pre><code class="lang-c++">#include&lt;algorithm&gt;</code></pre><p>使用方法:</p><pre><code class="lang-c++">void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></pre><p>（1）第一个参数first：是要排序的数组的起始地址。</p><p>（2）第二个参数last：是结束的地址（最后一个数据的后一个数据的地址）</p><p>（3）第三个参数comp是排序的方法：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是<strong>从小到大</strong>排序。</p><h4 id="qsort"><a href="#qsort" class="headerlink" title="qsort:"></a>qsort:</h4><pre><code class="lang-c++">void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</code></pre><ul><li><p><strong>base</strong> — 指向要排序的数组的第一个元素的指针。</p></li><li><p><strong>nitems</strong> — 由 base 指向的数组中元素的个数。</p></li><li><p><strong>size</strong> — 数组中每个元素的大小，以字节为单位。</p></li><li><p><strong>compar</strong> — 用来比较两个元素的函数。</p></li></ul><h3 id="2-输出保留小数后几位"><a href="#2-输出保留小数后几位" class="headerlink" title="2.输出保留小数后几位"></a>2.输出保留小数后几位</h3><p>头文件:</p><pre><code class="lang-c++">#include&lt;iomanip&gt;</code></pre><p>需要补零:</p><pre><code class="lang-c++">cout&lt;&lt;fixed&lt;&lt;setprecision(需要精确到小数点后几位)&lt;&lt;ans&lt;&lt;endl;</code></pre><p>不需要补零:</p><pre><code class="lang-c++">cout&lt;&lt;setprecision(需要精确到小数点后几位)&lt;&lt;ans&lt;&lt;endl;</code></pre><p><strong>推荐</strong>：更简单的方法:使用printf()</p><pre><code class="lang-c++">float d = 0.235;printf(&quot;%.5f\n&quot;,d);</code></pre><p>结果:0.23500</p><pre><code class="lang-c++">float d = 0.235;printf(&quot;%.2f\n&quot;,d);</code></pre><p>结果: 0.23</p><h3 id="3-格式化输出-日期"><a href="#3-格式化输出-日期" class="headerlink" title="3.格式化输出(日期)"></a>3.格式化输出(日期)</h3><pre><code class="lang-c++">printf(&quot;%04d-%02d-%02d\n&quot;,yyyy,mm,dd);</code></pre><p>会右对齐左补0.</p><h3 id="4-全局变量声明"><a href="#4-全局变量声明" class="headerlink" title="4.全局变量声明"></a>4.全局变量声明</h3><p>声明的int 的全局变量，数组会默认初始化为0.</p><h3 id="5-无限大与无限小-inf"><a href="#5-无限大与无限小-inf" class="headerlink" title="5.无限大与无限小(inf)"></a>5.无限大与无限小(inf)</h3><pre><code class="lang-c++">int inf = 1e8;</code></pre><h3 id="6-字符串转int"><a href="#6-字符串转int" class="headerlink" title="6.字符串转int"></a>6.字符串转int</h3><p>atoi:(表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。</p><pre><code class="lang-c++">string s = &quot;123&quot;;int x = atoi(s.c_str());cout&lt;&lt;x&lt;&lt;endl;</code></pre><h3 id="7-输入带空格的字符串"><a href="#7-输入带空格的字符串" class="headerlink" title="7.输入带空格的字符串"></a>7.输入带空格的字符串</h3><pre><code class="lang-c++">#include&lt;string.h&gt;char str[1000];gets(str);int len = strlen(str);</code></pre><p>or</p><pre><code class="lang-c++">#include&lt;string&gt;string str;getline(cin , str);cout&lt;&lt;str&lt;&lt;endl;</code></pre><h3 id="8-清空数组"><a href="#8-清空数组" class="headerlink" title="8.清空数组"></a>8.清空数组</h3><p>memset函数</p><pre><code class="lang-c++">#include &lt;cstring&gt;const int N = 128;int hs[N];int main(){    hs[0] = 5;    cout&lt;&lt;hs[0]&lt;&lt;endl;    memset(hs, 0 , sizeof(hs));    cout&lt;&lt;hs[0]&lt;&lt;endl;    return 0;}</code></pre><h3 id="9-分词"><a href="#9-分词" class="headerlink" title="9. 分词"></a>9. 分词</h3><pre><code class="lang-c++">    //分词    s += &quot; &quot;;    string tmp = &quot;&quot;;    int m = 0;    for(int i = 0; i &lt; s.size(); i++){        if(s[i] == &#39; &#39;){            w[m++] = tmp;            tmp = &quot;&quot;;        }        else{            tmp += s[i];        }    }</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵求导运算</title>
    <link href="/EruLv.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E8%BF%90%E7%AE%97/"/>
    <url>/EruLv.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵求导运算推导与总结"><a href="#矩阵求导运算推导与总结" class="headerlink" title="矩阵求导运算推导与总结"></a>矩阵求导运算推导与总结</h2><h3 id="1-标量对向量求导"><a href="#1-标量对向量求导" class="headerlink" title="1.标量对向量求导"></a>1.标量对向量求导</h3><p>输入向量，输出标量。即映射关系为$f:R^N➡R$ 。</p><p>设$y = f(\boldsymbol{x})$ ,$\boldsymbol{x}$是Nx1的矢量，y是标量。</p><p>则求导结果为:</p><script type="math/tex; mode=display">\frac{\partial y}{\partial \boldsymbol{x}}=\left(\frac{\partial y}{\partial x_{1}}, \frac{\partial y}{\partial x_{2}}, \ldots, \frac{\partial y}{\partial x_{N}}\right)</script><h3 id="2-向量对向量求导"><a href="#2-向量对向量求导" class="headerlink" title="2.向量对向量求导"></a>2.向量对向量求导</h3><p>输入向量，输出也是向量，则需要用到 Jacobian矩阵。</p><p>假设映射关系为$f:R^N➡R^M$ ,输入输出都为向量。$\boldsymbol{y} = f(\boldsymbol{x})$ ,则有:</p><script type="math/tex; mode=display">\frac{\partial y}{\partial x}=\left(\begin{array}{ccc}\frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{1}}{\partial x_{N}} \\\vdots & \ddots & \vdots \\\frac{\partial y_{M}}{\partial x_{1}} & \cdots & \frac{\partial y_{M}}{\partial x_{N}}\end{array}\right)</script><p>输出MxN的矩阵。</p><script type="math/tex; mode=display">\left(\frac{\partial \boldsymbol{y}}{\partial \boldsymbol{x}}\right)_{i j}=\frac{\partial y_{i}}{\partial x_{j}}</script><h4 id="2-1-x-为列向量"><a href="#2-1-x-为列向量" class="headerlink" title="2.1$x$为列向量"></a>2.1$x$为列向量</h4><p>假如$W$ 是一个NxM的矩阵，$\boldsymbol{z}=\boldsymbol{W}\boldsymbol{x}$ ，$\boldsymbol{x}$为Mx1的列向量，$\boldsymbol{z}$为Nx1的列向量,Jacobian矩阵为NxM维。</p><script type="math/tex; mode=display">z_{i}=\sum_{k=1}^{m} W_{i k} x_{k}</script><script type="math/tex; mode=display">\left(\frac{\partial \boldsymbol{z}}{\partial \boldsymbol{x}}\right)_{i j}=\frac{\partial z_{i}}{\partial x_{j}}=\frac{\partial}{\partial x_{j}} \sum_{k=1}^{m} W_{i k} x_{k}=\sum_{k=1}^{m} W_{i k} \frac{\partial}{\partial x_{j}} x_{k}=W_{i j}</script><p>所以</p><script type="math/tex; mode=display">\frac{\partial{\boldsymbol{z}}}{\partial{\boldsymbol{x}}} = \boldsymbol{W}</script><h4 id="2-2-x-为行向量"><a href="#2-2-x-为行向量" class="headerlink" title="2.2 $x$为行向量"></a>2.2 $x$为行向量</h4><p>假设有$\boldsymbol{z}=\boldsymbol{x}\boldsymbol{W}$ ，$\boldsymbol{x}$为1xN的列向量，$\boldsymbol{z}$为1xM的列向量.W维度为NxM,Jacobian矩阵为MxN.</p><script type="math/tex; mode=display">\frac{\partial{\boldsymbol{z}}}{\partial{\boldsymbol{x}}} = \boldsymbol{W^T}</script><h3 id="3-向量对矩阵求导"><a href="#3-向量对矩阵求导" class="headerlink" title="3.向量对矩阵求导"></a>3.向量对矩阵求导</h3>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
