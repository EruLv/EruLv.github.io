<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>计算机图形学复习</title>
    <link href="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
    <url>/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机图形学复习"><a href="#计算机图形学复习" class="headerlink" title="计算机图形学复习"></a>计算机图形学复习</h1><h2 id="1-CG基础"><a href="#1-CG基础" class="headerlink" title="1.CG基础"></a>1.CG基础</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念:"></a>1.1概念:</h3><p><strong>几何学(geometry)</strong>:几何学是研究在n维空间中物体之间关系的一门学科。</p><p><strong>几何学原语(primitives)</strong>:构建复杂的物体需要的最基础的元素。</p><p><strong>三个基本元素:</strong>标量(Scalars),向量(Vectors),点(Points)</p><p><strong>标量</strong>:标量可以定义为集合的成员，可以通过两个操作（加法和乘法）结合一些基本公理（关联性，可交换性，逆函数）进行组合.标量没有几何属性。</p><p><strong>向量</strong>:向量由幅度和方向两个属性组成。</p><h3 id="1-2-Coordinate-Free-Geometry-无坐标几何"><a href="#1-2-Coordinate-Free-Geometry-无坐标几何" class="headerlink" title="1.2 Coordinate-Free Geometry(无坐标几何)"></a>1.2 Coordinate-Free Geometry(无坐标几何)</h3><p><strong>笛卡尔坐标系</strong>:直角坐标系和斜坐标系的统称。</p><p>物理上，点的存在与坐标系无关，如，如果两个三角形两条边及其夹角相等，则他们相同(全等)。</p><h3 id="1-3-向量空间"><a href="#1-3-向量空间" class="headerlink" title="1.3 向量空间"></a>1.3 向量空间</h3><p>1.向量空间中，向量的起点不同，但方向和长度相同的向量为同一向量。</p><p>2.仿射空间(Affine Spaces): 点的集合+向量空间。</p><p>操作:</p><ul><li>Vector-vector addition -&gt; vector</li><li>Scalar-vector multiplication -&gt;vector</li><li>Point-vector addition -&gt; point</li><li>Scalar-scalar operations -&gt;scalar</li><li>scalar – 以上运算均与坐标系无关</li></ul><p>3.点的参数形式</p><p>参数坐标 : $P(\alpha) = P_0 + \alpha d $</p><p>点的线性运算:$P1 + P_2 = P_1 + (P2 - 0)$,得到的还是一个坐标</p><p>4.凸面体</p><p>如果该物体内部任意两个点之间组成的线段上的所有点均在该物体内部，则称该物体为凸的(convex).</p><p>5.点的仿射和(Affine Sum)</p><p>$P = a_1P_1 + a_2P_2 + …+a_nP_n$</p><p>当且仅当$a1+a2 + …a_n = 1$,则称这是点$P_1,…P_n$的仿射和。如果$a_i &gt; 0$则我们得到$P_i$的一个凸包(convex hull)</p><p>6.向量乘</p><p>点乘，叉乘(右手准则)</p><p>7.曲线和面</p><p>如何定义曲线和面</p><p>曲线:形式$为P（x）$的一个参数实体，其中函数是非线性的。</p><p>面:曲线由两个函数组成的参数定义$P(a,b)$</p><p>8.平面(Plane)</p><p>可以由一个点+两个向量或者三个点表示。</p><p>9.法向量</p><p>每个平面都有法向量，平面上的向量点乘法向量结果均为0.</p><p>10.线性无关</p><p>一系列向量$v_1,v_2,…,v_n$成为线性无关的如果:</p><script type="math/tex; mode=display">\alpha_1v_1 + \alpha_2v_2 + \alpha_3v_3 +... = 0 \\iff \alpha_1 = \alpha_2 = ... = 0</script><p>11.维度</p><p>向量空间中，线性无关向量的最大数量称为线性空间的维度。</p><p>12.坐标系中坐标的表示</p><p>设$v_1，v2,…v_n$是向量空间的一组基，一个向量可以表示为$v = \alpha_1v_1 + \alpha_2v_2 +… + \alpha_nv_n$</p><p>其中$\alpha_i$为标量</p><p>13.框架</p><p>因为坐标系只能表示向量而不能表示点，所以加上原点。即</p><p>原点+坐标系构成框架Frame,可以表示向量空间中的点。一个三维Frame的形式:$(P_0,v_1,v2,v3)$</p><p>每个点可以记作:</p><script type="math/tex; mode=display">P = P_0 + \beta_1 v_1 + \beta_2 v_2 + ... + \beta_n v_n</script><p>14.三维空间的四维表示</p><script type="math/tex; mode=display">v = \alpha_1 v_1 + \alpha_2 v_2 + \alpha_3 v_3 = [\alpha_1\alpha_2 \alpha_3][v_1 v_2 v_3 P_0]^T</script><script type="math/tex; mode=display">P = P_0 + \beta_1 v_1 + \beta_2 v_2 + \beta_3 v_3 = [\beta_1 \beta_2  \beta_3 ][v_1 v_2 v_3 P_0]^T</script><p>所以向量可以表示为:</p><script type="math/tex; mode=display">v = [\alpha_1 \alpha_2 \alpha_3 0]^T\\\p = [\beta_1 \beta_2 \beta_3 1]^T</script><p>15.同质坐标</p><p>w != 1 &amp;&amp; w != 0</p><h3 id="1-4-建模和渲染的Pipeline"><a href="#1-4-建模和渲染的Pipeline" class="headerlink" title="1.4 建模和渲染的Pipeline"></a>1.4 建模和渲染的Pipeline</h3><p>1.步骤:</p><ol><li>几何建模</li><li>将建模的物体放入世界坐标系。</li><li>选择视角的位置和方向</li><li>将物体从世界坐标系变换到视角坐标系并且投影到图像平面。</li></ol>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础</title>
    <link href="/EruLv.github.io/2020/08/01/java%E5%9F%BA%E7%A1%80/"/>
    <url>/EruLv.github.io/2020/08/01/java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础笔记-《Java编程思想》阅读笔记"><a href="#Java基础笔记-《Java编程思想》阅读笔记" class="headerlink" title="Java基础笔记-《Java编程思想》阅读笔记"></a>Java基础笔记-《Java编程思想》阅读笔记</h1><h6 id="距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java"><a href="#距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java" class="headerlink" title="距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java."></a>距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java.</h6><h2 id="1-一切皆是对象"><a href="#1-一切皆是对象" class="headerlink" title="1.一切皆是对象"></a>1.一切皆是对象</h2><ol><li><p>java是一种更纯粹的面向对象的编程语言。</p></li><li><p>Java使用<code>new</code>关键字创建对象，对象的存储位置在<strong>堆</strong>内。对于一些基本类型，<code>new</code>对堆的操作开销较大，因此对于这些类型，java采取与c,c++相同的方法，即，不用<code>new</code>来创建这些变量，而直接创建一个并非是引用的变量，这个变量直接存储值，并置于堆栈中，音因此更加高效。</p></li><li><p>Java变量的<strong>基本类型</strong>:</p></li></ol><div class="table-container"><table><thead><tr><th>基本类型</th><th>大小</th><th>最小值</th><th>最大值</th><th>包装器类型</th></tr></thead><tbody><tr><td>boolean</td><td>—</td><td>—</td><td>—</td><td>Boolean</td></tr><tr><td>char</td><td>16 bits</td><td>Unicode 0</td><td>Unicode $2^{16} -1$</td><td>Character</td></tr><tr><td>byte</td><td>8 bits</td><td>-128</td><td>127</td><td>Byte</td></tr><tr><td>short</td><td>16 bits</td><td>-$2^{15}$</td><td>$2^{15}-1$</td><td>Short</td></tr><tr><td>int</td><td>32 bits</td><td>-$2^{31}$</td><td>$2^{31} - 1$</td><td>Integer</td></tr><tr><td>long</td><td>64 bits</td><td>-$2^{63}$</td><td>$2^{63} - 1$</td><td>Long</td></tr><tr><td>float</td><td>32 bits</td><td>IEEE 754</td><td>IEEE 754</td><td>Float</td></tr><tr><td>double</td><td>64 bits</td><td>IEEE 754</td><td>IEEE 754</td><td>Double</td></tr><tr><td>void</td><td>—</td><td>—</td><td>—</td><td>Void</td></tr></tbody></table></div><p>所有数值类型变量均有符号。</p><pre><code class="lang-java">//创建一个基本类型变量int a = 13;//使用包装器创建一个非基本对象Integer a = new Integer(13);//java自动将基本类型转换为包装器类型Integer a = 13;</code></pre><p>4.高精度</p><ul><li><p>高精度整数:<code>BigInteger</code>，支持任何精度的整数。</p></li><li><p>高精度浮点数:<code>BigDecimal</code>，支持任何精度的浮点数。</p></li></ul><p>只能通过<code>new</code>创建.</p><p>对象的作用域</p><p>由<code>new</code>创建的对象，只要你需要，就会一直保存下去，即超出作用域是不会被立即销毁。</p><p>6.类的要素:</p><ul><li><p>字段</p></li><li><p>方法</p></li></ul><p>7.当java的变量作为类的成员时，若该变量时基本类型并且未被赋值，则java会给它一个默认值(类似c++)。</p><p>8.导入类</p><pre><code class="lang-java">import java.utils.ArrayList;import java.utils.*;    //导入utils下所有类。</code></pre><p>9.static</p><p>当一个事物声明是static时，意味着这个域或方法不会与包含它的那个对象关联在一起。即无论创建多少个包含它的对象，系统只给它分配一个存储空间。</p><pre><code class="lang-java">class test{    static int a = 1;}class Main {    public static void main(String args[]){        test t = new test();        t.a ++;        test tt = new test();        tt.a ++;        test.a ++;    //可以直接通过类名调用静态方法        System.out.println(t.a);        System.out.println(tt.a);    }}结果:44</code></pre><p>同理，静态方法也可通过类名直接调用或通过对象调用。</p><p>10.</p><p>java.lang是默认导入到每个Java文件中的，不需要额外import.</p><p>11.编译</p><p>生成.class类</p><pre><code>javac xxx.java</code></pre><p>假设生成了A.class和B.class, 现在运行代码:</p><pre><code>java A</code></pre><p>12.注释</p><pre><code class="lang-java">class Main {    /** 类的作用是啥巴拉巴拉     * @author 作者名称     * @param args 参数解释     * @return xxx     * @version 1.0     */    public static void main(String args[]){        System.getProperties().list(System.out);    }}</code></pre><h2 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2.操作符"></a>2.操作符</h2><p>1.赋值</p><p><strong>基本类型的赋值</strong>: </p><p>直接把内容赋值给左边，如a = b, 当改变b的值时，a的内容不变。</p><p><strong>对象赋值</strong>:</p><p>把指向对象的引用复制给左边，如c = d,那么c和d都指向同一存储位置。</p><p>2.random</p><pre><code class="lang-java">import java.util.*;class Main {    public static void main(String args[]){        Random random = new Random(66);    //随机数对象，种子:66        int a = random.nextInt(100) + 1;    //设置Int范围1-100        float b = random.nextFloat()*10;    //设置float范围0-10        System.out.println(a);        System.out.println(b);    }}</code></pre><p>3.科学计数法</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        float a = 1e32f;        System.out.println(a);    }}</code></pre><p>4.按位操作</p><p><code>&amp;</code>:与</p><p><code>|</code>:或</p><p><code>~</code>:非</p><p><code>^</code>:异或</p><p><code>&lt;&lt;</code>:左移</p><p><code>&gt;&gt;</code>:右移</p><p>5.if-else操作</p><pre><code class="lang-java">boolean-exp ? a:b;</code></pre><p>6.类型转换</p><p><strong>窄化转换</strong>可能面临信息丢失的危险，所以必须显示转换。</p><p><strong>拓展转换</strong>不需要显示转换。</p><p>例如: long转int会报错，必须显示转换。</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        long a = 1000000;        int b = a;    }}</code></pre><p>7.截尾和舍入</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        double a = 9.7;        int b = (int)a;    //截尾        int c = (int)Math.round(a);    //四舍五入        System.out.println(b);        System.out.println(c);    }}</code></pre><p>8.其他</p><ul><li>比int小的类型(char,byte,short)在运算时会自动转换为int类型。</li><li>通常，表达式中最大数据类型决定了表达式最终结果的数据类型。</li></ul><h2 id="3-执行控制流程"><a href="#3-执行控制流程" class="headerlink" title="3.执行控制流程"></a>3.执行控制流程</h2><p>1.if else,while, for, switch</p><p>pass</p><p>2.Foreach</p><p>(c++11中也支持该语句)</p><p>Foreach可用于任何数组和Iterable对象。</p><pre><code class="lang-java">        Random r = new Random(6);        int a[] = new int[10];        for(int i = 0;i &lt; a.length; i++){            a[i] = r.nextInt(100);        }        for(int x:a){            System.out.println(x);        }</code></pre><pre><code class="lang-java">    public static void main(String args[]){        for(int x: range(5,10)){    //rang前提: import static net.mindview.util.Range.*;            print(x);        }    }</code></pre><p>3.goto</p><p>goto是java的一个保留字，但是java并不能使用goto语句。</p><p>4.标签</p><p><code>break label</code>: 跳出标签所指循环。</p><p><code>continue label</code>:跳过标签所指循环的这一步。</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        int i = 0;        outer:        for(;;){            inner:            for(;i &lt; 10; i++){                print(&quot;i = &quot;+i);                if(i == 5) break outer;    //直接跳出外部循环            }        }    }}</code></pre><h2 id="4-初始化与请理"><a href="#4-初始化与请理" class="headerlink" title="4.初始化与请理"></a>4.初始化与请理</h2><p>1.构造器</p><p>与类名相同的函数。</p><p>2.重载</p><p>方法名相同，形参不同。</p><p><strong>函数名和形参相同，返回值不同，不是重载，编译器会报错。</strong></p><p>3.this</p><p>在类内使用，表示该类的引用。可用于区分形参和类内参数。</p><p>一般的方法，如:</p><pre><code class="lang-java">class Person {    public void eat(Apple apple) {        print(&quot;Yummy&quot;);    }}//实际上隐含的代码是(实际不能把this写上，否则编译器报错):class Person {    public void eat(this, Apple apple) {        print(&quot;Yummy&quot;);    }}</code></pre><p>4.再看static</p><p>static方法是没有<code>this</code>的方法，在所以在static方法内部不能直接调用非静态方法，单反过来是可以的。</p><p>static很像全局方法，给java提供了一种访问全局变量和方法的思路。</p><p>5.finalize</p><p>类似于c++中的析构函数。但不建议使用。java9以上的版本该方法被<strong>Deprecated</strong> 并且<strong>will be removed</strong>.</p><p>6.构造器初始化</p><p>变量一定会在构造函数之前初始化(即使变量可能定义在构造函数后面)，变量之间的初始化顺序由定义的顺序决定。</p><p>7.静态数据初始化</p><p><code>static</code> 不能作用与局部数据，静态数据也会自动初始化(基本类型，对象类型)。</p><pre><code class="lang-java">import java.util.*;import static net.mindview.util.Print.*;import static net.mindview.util.Range.*;class Bowl{    Bowl(int marker){        print(&quot;Bowl(&quot;+marker+&quot;)&quot;);    }    void f1(int marker){        print(&quot;f1(&quot;+marker+&quot;)&quot;);    }}class Table{    static Bowl bowl1 = new Bowl(1);    Table(){        print(&quot;Table()&quot;);        bowl2.f1(1);    }    void f2(int marker){        print(&quot;f2(&quot;+marker+&quot;)&quot;);    }    static Bowl bowl2 = new Bowl(2);}class Cupboard{    Bowl bowl3 = new Bowl(3);    static Bowl bowl4 = new Bowl(4);    Cupboard(){        print(&quot;Cupboard&quot;);        bowl4.f1(2);    }    void f3(int marker){        print(&quot;f3(&quot;+marker+&quot;)&quot;);    }    static Bowl bowl5 = new Bowl(5);}class Main {    public static void main(String args[]){        print(&quot;create new Cupboard() in main !&quot;);        new Cupboard();        print(&quot;create new Cupboard() in main !&quot;);        new Cupboard();        table.f2(1);        cupboard.f3(1);    }    static Table table = new Table();    static Cupboard cupboard = new Cupboard();}</code></pre><pre><code>输出:Bowl(1)Bowl(2)Table()f1(1)Bowl(4)Bowl(5)Bowl(3)Cupboardf1(2)create new Cupboard() in main !Bowl(3)Cupboardf1(2)create new Cupboard() in main !Bowl(3)Cupboardf1(2)f2(1)f3(1)</code></pre><p><strong>总结初始化顺序:</strong></p><p>静态对象(只会被初始化一次)-&gt;非静态对象-&gt;构造器。</p><p>8.静态子句</p><p>只会被执行一次的域</p><pre><code class="lang-java">static{    int i = 1;    xxxx}</code></pre><p>9.数组初始化</p><pre><code>int a[];int[] a;int[] a = {1,2,3,4};int a[] = new int[10];</code></pre><pre><code class="lang-java">a2 = a1;//把a1的引用赋值给a2;</code></pre><pre><code class="lang-java">Arrays.toString(a); //把数组转化为字符串,需要引用java.utils.*标准库</code></pre><p>创建对象数组时，需要分两步:</p><p>创建应用数组，给每个引用赋初值。</p><pre><code class="lang-java">A[] a = new A[10];for(int i = 0; i  &lt; a.length; i++){    a = new A();}</code></pre><p>或者直接初始化</p><pre><code class="lang-java">A[] a = {new A(1),new A(2)};A[] a = new A[]{new A(1), new A(2)};</code></pre><p>10.可变参数列表</p><pre><code class="lang-java">public class VarArgs{    static void printArray(Object... args){    //将你的输入自动封装成数组，疮长度不固定，可以是0        for(Object obj: args){            System.out.print(obj + &quot; &quot;);        }        print();    }}class DynamicArray{    public static void main(String[] args){        VarArgs.printArray(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);        VarArgs.printArray(new Object[]{                new Integer(1),                new Integer(2),                new Integer(3)        });    }}</code></pre><p>11.枚举类型</p><pre><code class="lang-java">enum E{    A,B,C,D}class Main{    public static void main(String[] args){        for(E e: E.values()){            print(e);        }        print(E.A);            }}</code></pre><p>enum类有toString方法，可以在switch中使用。</p><h2 id="5-访问权限控制"><a href="#5-访问权限控制" class="headerlink" title="5.访问权限控制"></a>5.访问权限控制</h2><p>1.包Package</p><p> 每个<code>.java</code>文件都只能有一个public类，该类的名称必须与文件名相同，如果改文件还有额外的类的话，包之外的世界(其他文件)是无法看见这个类的。即每个文件都有一个<code>public</code>类，以及许多非<code>public</code>类。</p><p>每个文件都有一个构件，如果希望这些构件从属于同一个群组，就可以使用关键字<code>package</code>,必须放在程序最前面。</p><p>新建package access</p><pre><code class="lang-java">package access;public class A {    public A(){        System.out.println(&quot;access A !&quot;);    }}class AA{    public AA(){        System.out.println(&quot;access AA !&quot;);    }}</code></pre><p>在<code>access</code>包外调用包内的内容。</p><pre><code class="lang-java">import access.*;public class B {    public static void main(String[] args){//        AA aa = new AA();        A a = new A();    }}</code></pre><p>java解释器寻找类库的过程：</p><p>比如导入包</p><pre><code class="lang-java">import net.mindview.test.*</code></pre><p>当编译器遇到<code>test</code>的<code>import</code>语句时，就开始在<code>CLASSPATH</code>所指定的目录中查找，查找到子目录<code>net/mindview/test</code>，然后从已编译的文件中找出名称相符者。</p><p>如果导入的两个类库中存在冲突类，如果你恰好使用到了冲突的类，编译器会报错。</p><p><strong>自己一个print包</strong></p><pre><code class="lang-java">package access;public class Print {    public static void print(Object obj){        System.out.println(obj);    }    public static void print(){        System.out.println();    }}</code></pre><p>调用:</p><pre><code class="lang-java">import static access.Print.*;public class B {    public static void main(String[] args){        print();    }}</code></pre><p><code>import static 包名.类名.*;</code></p><p>意思是导入这个类里的静态成员（静态方法、静态变量）,可以直接使用静态方法而不用通过<code>类名.方法名()</code>,可以导入的静态成员包括静态对象引用、静态常量和静态方法。</p><p>2.<strong>访问权限修饰词</strong></p><p>2.1包访问权限(默认权限)</p><p>没有访问权限修饰词，则默认为包访问权限(<code>friendly</code>),则当前包中的其他类堆那个成员对具有访问权限。对于包外的所有类都是不可见的。</p><p>如果你没有设置当前文件所属的包，即没有定义<code>package xxxx</code>,则位于同一目录的这样文件被java看作位于隶属于该目录的默认包中，于是对于同级目录下的没有设置包的文件来说，它们有<strong>包访问权限</strong>。</p><p>2.2 public</p><p>在任何位置都可以访问。</p><p>2.3 private</p><p>除了包含该成员的类之外，其他任何类都无法访问这个成员。</p><p>2.4 protected</p><p>继承的子类可以访问基类中的<code>protected</code>的成员（当然也可以访问<code>public</code>的）。</p><p><code>protected</code>也提供包继承，即同一个包内的类也可以访问含有<code>protected</code>声明的成员。</p><p>3.注意，类(外部类)不可以时<code>protected</code>或者<code>privated</code>.可以把构造器设置为<code>private</code>,阻止其他类创建该类的实例。</p><h2 id="6-复用类"><a href="#6-复用类" class="headerlink" title="6.复用类"></a>6.复用类</h2><p>1.复用类的两种实现方法</p><p>组合:在新类中<code>new</code>一个现有类。</p><p>继承:在基类的基础上添加代码。</p><p>2.toString方法</p><p>在每一个非基本类型的对象都有一个<code>toString()</code>方法，当编译器需要一个String而你只有一个对象时，该方法会被调用。可以自己定义<code>toString()</code>方法:</p><pre><code class="lang-java">public String toString(){    return &quot;This is toString&quot;;}</code></pre><pre><code class="lang-java">import static access.Print.*;public class B {    public static void main(String[] args){        Print p = new Print();        System.out.println(p);    }}</code></pre><p>3.继承</p><p>java默认从<code>Object</code>类继承。</p><p>继承关键字:<code>extends</code>.</p><pre><code class="lang-java">public A ectends B{    //balabala}</code></pre><p>A类从B类继承。</p><pre><code class="lang-java">class C{    C(){        System.out.println(&quot;initialize C!&quot;);    }}class B extends C{    B(){        System.out.println(&quot;initialize B!&quot;);    }}public class A extends B{    A(){        System.out.println(&quot;initialize A!&quot;);    }    public static void main(String[] args){        A a = new A();    }}</code></pre><p><strong>java会首先初始化基类。</strong></p><p>如果没有默认的基类构造器，或者基类构造器带参数，则必须使用<code>super</code>，显示地调用基类构造器。并且<code>super</code>要位于最前面。</p><p>4.代理</p><p>继承和组合的一个折中，不直接继承，而是创建基类的一个实例，根据定义当前类需要的方法。</p><p>5.名称屏蔽</p><p>如果基类中有一个方法，在子类中被重载了，那么基类中的这个方法依然是可用的。</p><p>使用<code>@override</code>会检查你写的下面的代码是否覆盖掉基类代码，如果只是重载而不是覆盖，则编译器会报错。</p><pre><code class="lang-java">class B {    B(int i) {        System.out.println(&quot;initialize B!&quot;);    }    void f(int x){        System.out.println(&quot;f(&quot;+x+&quot;)&quot;);    }}public class A extends B{    A(){        super(1);        System.out.println(&quot;initialize A!&quot;);    }    void f(String s){        System.out.println(&quot;f(&quot;+s+&quot;)&quot;);    }    public static void main(String[] args){        A a = new A();        a.f(&quot;你好&quot;);        a.f(1);    }}/* outputs:initialize B!initialize A!f(你好)f(1)*/</code></pre><pre><code class="lang-java">public class A extends B{    A(){        super(1);        System.out.println(&quot;initialize A!&quot;);    }    //限定只能覆盖,重写会报错    @Override    void f(int x){        System.out.println(&quot;ff(&quot;+x+&quot;)&quot;);    }    public static void main(String[] args){        A a = new A();        a.f(1);    }}</code></pre><p>6.组合和继承的选择</p><p>组合是使用现有类的一些功能，来实现我们需要的功能，比如car类可能需要wheel类，Engine类等。</p><p>继承一般是把一个通用类的功能特殊化，具体化。</p><p>7.向上转型</p><p>将导出类(子类)转换为基类的动作（从一个特殊类转换为通用类）。如:</p><pre><code class="lang-java">Instrument x = new Flute();</code></pre><p>8.final关键字</p><p><strong>1.数据</strong></p><p><code>final</code>代表常量，如果修饰基本类型，则表示该数据不能修改，如果修饰对象，表示改引用不能指向其他对象(但对象可以改变)。</p><p><code>final static</code>命名一般是大写字幕+下划线。</p><p><code>final</code>必须在定义时初始化。当然，如果作为类成员变量，可以先不初始化，但一定要在构造函数里初始化。</p><pre><code class="lang-java">class Test{    private final int j = 1;    private final int i;    Test(){        i = 1;    }}</code></pre><p><strong>2.方法</strong></p><p><code>final</code>修饰方法作用和<code>private</code>关键字类似，可以防止子类覆盖。</p><pre><code class="lang-java">class WithFinals {    // Identical to &quot;private&quot; alone:    private final void f() { print(&quot;WithFinals.f()&quot;); }    // Also automatically &quot;final&quot;:    public final void g() { print(&quot;WithFinals.g()&quot;); }}class OverridingPrivate extends WithFinals {    private final void f() {        print(&quot;OverridingPrivate.f()&quot;);    }    public void g() {   //会报错        print(&quot;OverridingPrivate.g()&quot;);    }}</code></pre><p><strong>3.类</strong></p><p>在类前加<code>final</code>关键字表示改类不能被继承。final类不会被继承，因此它的所有方法都隐式指定为final的。</p><h2 id="7-多态"><a href="#7-多态" class="headerlink" title="7.多态"></a>7.<strong>多态</strong></h2><p>在<strong>oop</strong>中，多态时继数据抽象和继承之后的第三种基本特征。多态的作用是消除类型之间的耦合关系</p><p>1.向上转型</p><p>对象既可作为它自己本身的类型使用，也可作为它的基类型使用。</p><pre><code class="lang-java">class Instrument {  public void play(Note n) {    print(&quot;Instrument.play()&quot;);  }}public class Wind extends Instrument {  // Redefine interface method:  public void play(Note n) {    System.out.println(&quot;Wind.play() &quot; + n);  }} public class Music {  public static void tune(Instrument i) {    // ...    i.play(Note.MIDDLE_C);  }  public static void main(String[] args) {    Wind flute = new Wind();    tune(flute); // Upcasting  }} /* Output:Wind.play() MIDDLE_C*///:~</code></pre><p>接收Instrument类型的对象，调用的却是Wind的方法。</p><p>为什么会这样？因为java中除了<code>final</code>和<code>static</code>均采用动态绑定，在运行时判断对象类型。</p><p>你以为你把它转到基类了，实际上如果可以，它还是会调用子类的方法。</p><pre><code class="lang-java">class A{    public void play(){        System.out.println(&quot;A.play()&quot;);    }}class B extends A{    public void play(){        System.out.println(&quot;B.play()&quot;);    }}public class test {    public static void main(String[] args){        A a = new B();        a.play();    }}B/* Output:B.play() *///:~</code></pre><p>2.“覆盖”私有方法</p><pre><code class="lang-java">public class PrivateOverride {  private void f() { print(&quot;private f()&quot;); }      public static void main(String[] args) {    PrivateOverride po = new Derived();    po.f();  }}class Derived extends PrivateOverride {  public void f() { print(&quot;public f()&quot;); }    } /* Output:private f()*///:~</code></pre><p>上面的基类中f()是私有的，与<code>final</code>等价，下面继承的方法看作是个全新的方法，基类中的方法f()在导出类中不可见，不能被重载，<strong>只有非<code>private</code>方法才可以被覆盖</strong>。</p><p>满足多态的条件:</p><ul><li>基类和子类中都有非<code>private</code>方法f().</li><li>A a = new B()形式，其中B继承A。</li></ul><p>最终a.f()调用B的f()。</p><p><strong>另外，向上转型后不能访问子类中存在但基类中不存在的方法。</strong></p><p>3.“域”(类变量)访问</p><p>如果你直接访问某个域，这个访问就会在编译期间进行解析，不具有多态性。</p><pre><code class="lang-java">class Super {  public int field = 0;  public int getField() { return field; }}class Sub extends Super {  public int field = 1;  public int getField() { return field; }  public int getSuperField() { return super.field; }}public class FieldAccess {  public static void main(String[] args) {    Super sup = new Sub(); // Upcast    System.out.println(&quot;sup.field = &quot; + sup.field +      &quot;, sup.getField() = &quot; + sup.getField());    Sub sub = new Sub();    System.out.println(&quot;sub.field = &quot; +      sub.field + &quot;, sub.getField() = &quot; +      sub.getField() +      &quot;, sub.getSuperField() = &quot; +      sub.getSuperField());  }}/* Output:sup.field = 0, sup.getField() = 1sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0*///:~</code></pre><p>向上转型后，访问sup的域，因为sup是Super类，所以访问的是Super的类变量。</p><p>如果某个方法是静态的，它的行为也不具有多态性。因为静态方法与类关联而不是单个对象。</p><pre><code class="lang-java">class StaticSuper {  public static String staticGet() {    return &quot;Base staticGet()&quot;;  }  public String dynamicGet() {    return &quot;Base dynamicGet()&quot;;  }}class StaticSub extends StaticSuper {  public static String staticGet() {    return &quot;Derived staticGet()&quot;;  }  public String dynamicGet() {    return &quot;Derived dynamicGet()&quot;;  }}public class StaticPolymorphism {  public static void main(String[] args) {    StaticSuper sup = new StaticSub(); // Upcast    System.out.println(sup.staticGet());    System.out.println(sup.dynamicGet());  }} /* Output:Base staticGet()Derived dynamicGet()*///:~</code></pre><p>4.构造器和多态</p><p>构造器是<code>static</code>的，因此不具有多态性。</p><p>构造器调用顺序:</p><p><strong>从上往下初始化基类构造器-&gt;初始化当前类的变量-&gt;初始化当前类的构造器。</strong></p><p>5.清理</p><p>如果需要显示地写辣鸡回收方法，子类覆盖父类的请理方法，子类的清理方法中一定要添加<code>super().请理()</code>方法，否则父类的清理方法一直不会执行。</p><p>6.构造器中调用被覆盖的类</p><pre><code class="lang-java">class Glyph {  void draw() { print(&quot;Glyph.draw()&quot;); }  Glyph() {    print(&quot;Glyph() before draw()&quot;);    draw();    print(&quot;Glyph() after draw()&quot;);  }}  class RoundGlyph extends Glyph {  private int radius = 1;  RoundGlyph(int r) {    radius = r;    print(&quot;RoundGlyph.RoundGlyph(), radius = &quot; + radius);  }  void draw() {    print(&quot;RoundGlyph.draw(), radius = &quot; + radius);  }}  public class PolyConstructors {  public static void main(String[] args) {    new RoundGlyph(5);  }} /* Output:Glyph() before draw()RoundGlyph.draw(), radius = 0Glyph() after draw()RoundGlyph.RoundGlyph(), radius = 5*///:~</code></pre><p>可以看到基类的draw()方法被重写了，在基类构造器中调用draw()方法依旧调用的是子类的draw()方法，但由于子类还未初始化，所以radius为0.（之前编译器会给所有对象分配好空间，然后初始化成二进制的0.</p><p>7.协变返回类型</p><pre><code class="lang-java">class Grain {  public String toString() { return &quot;Grain&quot;; }}class Wheat extends Grain {  public String toString() { return &quot;Wheat&quot;; }}class Mill {  Grain process() { return new Grain(); }}class WheatMill extends Mill {  Wheat process() { return new Wheat(); }}public class CovariantReturn {  public static void main(String[] args) {    Mill m = new Mill();    Grain g = m.process();    System.out.println(g);    m = new WheatMill();    g = m.process();    System.out.println(g);  }} /* Output:GrainWheat*///:~</code></pre><p>8.向下转型</p><pre><code class="lang-java">class Useful {  public void f() {}  public void g() {}}class MoreUseful extends Useful {  public void f() {}  public void g() {}  public void u() {}  public void v() {}  public void w() {}}  public class RTTI {  public static void main(String[] args) {    Useful[] x = {      new Useful(),      new MoreUseful()    };    x[0].f();    x[1].g();    // Compile time: method not found in Useful:    x[1].u();    //编译报错    ((MoreUseful)x[1]).u(); //通过    ((MoreUseful)x[0]).u(); // 抛出异常  }} ///:~</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/EruLv.github.io/2020/07/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/EruLv.github.io/2020/07/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划题目总结"><a href="#动态规划题目总结" class="headerlink" title="动态规划题目总结"></a>动态规划题目总结</h1><h2 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.背包问题"></a>1.背包问题</h2><h3 id="1-1-01背包问题"><a href="#1-1-01背包问题" class="headerlink" title="1.1 01背包问题"></a>1.1 01背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>每件物品只能使用一次</strong>。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数$v_i, w_i$，用空格隔开，分别表示第i件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例：</strong></p><pre><code>8</code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h4><p>$f[i][j]$表示状态，从前i件物品中选择不超过质量j的最大总价值。</p><p>划分为两个集合:</p><p>不选择第i件物品,则$f[i][j] = f[i-1][j]$</p><p>选择第i件物品，考虑如何使用前面的状态表示，$f[i][j] = f[i - 1][j - v[i]] + w[i]$,选择第i件物品质量不超过j，需要从前i-1件物品中的质量不超过$j - v[i]$的物品中获得。前提是$j &gt;= v[i]$</p><p>上面两者求最大值即可。</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N][N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i]&gt;&gt; w[i];    }    //f[i][j] = max(f[i-1][j], f[i - 1][j - v[i]] + w[i])    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;=m ; j++){            f[i][j] = f[i-1][j];            if(j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j-v[i]] + w[i]);         }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>可以使用一维数组代替二维数组，因为计算$f[i][j]$是只用到了$f[i-1]$的状态，所以i这一维可以压缩到一个数组中。</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i]&gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = m; j &gt;= v[i] ; j--){            //注意要从后往前遍历，因为我们要确保公式右边都是没有更新过的，j一定在j-v[i]前更新            f[j] = max(f[j], f[j-v[i]] + w[i]);         }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="1-2-完全背包问题"><a href="#1-2-完全背包问题" class="headerlink" title="1.2 完全背包问题"></a>1.2 完全背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>每件物品都有无限件可用</strong>。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数$v_i, w_i$，用空格隔开，分别表示第i件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例：</strong></p><pre><code>10</code></pre><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析:"></a>分析:</h4><p>跟01背包相似，不过集合划分时，把情况划分为第i件物品选0,1,2,…,k件。</p><p>$f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i], f[i-1][j-2<em>v[i]] + 2</em>w[i],…,f[i-1][j-k<em>v[i]] + k</em>w[i])$</p><p>所以有:</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int f[N][N];int n, m;int v[N], w[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j&lt;=m; j++){            for(int k = 0; k*v[i] &lt;= j; k++)            f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + K*w[i]);        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>上述时间复杂读为$O(nm^2)$,可以优化。</p><p>考虑:</p><p>$f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i], f[i-1][j-2<em>v[i]] + 2</em>w[i],…,f[i-1][j-k<em>v[i]] + k</em>w[i])$</p><p>$f[i][j-v[i]] + w[i] = max(f[i-1][j - v[i]] + w[i], f[i-1][j-2 <em> v[i]] + 2</em>w[i], f[i-1][j-3<em>v[i]] + 3</em>w[i],…)$</p><p>所以</p><p>$f[i][j] = max(f[i-1][j], f[i][j-v[i]] + w[i])$</p><p>注意与01背包的区别，区别在它是从i转移来的而不是i - 1</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int f[N][N];int n, m;int v[N], w[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j&lt;=m; j++){            f[i][j] = f[i-1][j];            if(j &gt;= v[i])                f[i][j] = max(f[i-1][j], f[i][j - v[i]] + w[i]);        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>一维的形式</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int f[N];int n, m;int v[N], w[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = v[i]; j&lt;=m; j++){            //注意j是从小到大遍历，因为左边是从已经更新过的i转移来的            f[j] = max(f[j], f[j - v[i]] + w[i]);        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="1-3-多重背包问题"><a href="#1-3-多重背包问题" class="headerlink" title="1.3 多重背包问题"></a>1.3 多重背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>第i种物品最多有$s_i$件</strong>。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数$v_i, w_i$，用空格隔开，分别表示第i件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N≤1000$<br>$0&lt;V≤2000$<br>$0&lt;vi,wi,si≤2000$</p><p><strong>输入样例</strong></p><pre><code>4 51 2 32 4 13 4 34 5 2</code></pre><p><strong>输出样例：</strong></p><pre><code>10</code></pre><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析:"></a>分析:</h4><p>思路同完全背包，把第i件物品划分为选择0,1,2,…s[i]件</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int v[N],w[N],s[N];int n, m;int f[N][N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;=n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;= m; j++){            for(int k = 0; k &lt;= s[i] &amp;&amp; k*v[i] &lt;= j; k++){                f[i][j] = max(f[i][j], f[i-1][j - k*v[i]] + k*w[i]);            }        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>根据完全背包问题做优化:</p><pre><code>f[i][j] = max(f[i-1][j], f[i-1][j - v[i]] + w[i],...,f[i-1][j - s*v[i]] + s* w[i])f[i][j-v[i]] = max(      f[i-1][j - v[i]],      ... ,f[i-1][j - s*v[i]] + (s-1)*w[i],  f[i-1][j - (s+1)*v[i]])</code></pre><p>发现后面多了一项，不能根据后面的最大值，求前面的最大值。</p><p>所以使用二进制优化。</p><p><strong>思想</strong>:</p><p>假设第i组的数量为s，则可以将s分解为$logs$组，每组的数量为$1,2,4…2^k,c$,其中$1+2+…+2^k+c = s$,可以证明0-s种的任意一个整数可以用上面的二进制组合表示。</p><p>所以将每一种物品分成数量为$1,2,4…2^k,c$的组，最后转换为01背包问题。</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;// N = log(s) * Nconst int N = 15000, M = 2010;int v[N], w[N];int n, m;int f[M];int main(){    cin &gt;&gt; n &gt;&gt; m;    int cnt = 0;    //新的集合的编号    for(int i = 0; i &lt; n; i++){        int a, b, s;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;        //分组        int k = 1;  //该组的数量        while(k &lt;= s){            cnt ++;            v[cnt] = a * k;            w[cnt] = b * k;            s -= k;            k *= 2;        }        //剩下的        if(s &gt; 0){            cnt ++ ;            v[cnt] = a * s;            w[cnt] = b * s;        }    }    n = cnt;    //01背包问题    for(int i = 1; i &lt;= n; i++){        for(int j = m; j &gt;= v[i]; j--){            f[j] = max(f[j], f[j - v[i]] + w[i]);        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;}</code></pre><h3 id="1-4分组背包问题"><a href="#1-4分组背包问题" class="headerlink" title="1.4分组背包问题"></a>1.4分组背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>每组物品有若干个，同一组内的物品最多只能选一个</strong>。每件物品的体积是 $v<em>{ij}$，价值是 $w</em>{ij}$，其中 i是组号，j是组内编号。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$组数据：</p><ul><li>每组数据第一行有一个整数 $S_i$，表示第i 个物品组的物品数量；</li><li>每组数据接下来有$S<em>i$行，每行有两个整数 $v</em>{ij},w_{ij}$，用空格隔开，分别表示第 i个物品组的第 jj 个物品的体积和价值；</li></ul><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N,V≤100$<br>$0&lt;v<em>{ij},w</em>{ij}≤100$</p><p>$0&lt;S_i&lt;=100$</p><p><strong>输入样例</strong></p><pre><code>3 521 22 413 414 5</code></pre><p><strong>输出样例：</strong></p><pre><code>8</code></pre><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析:"></a>分析:</h4><p>集合的表示:前i组中总体积不超过j的最大价值。</p><p>集合划分:第i组，选择0个，第一个，第二个，…,第$s[i]$个</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int v[N][N], w[N][N], s[N];int f[N][N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        int cnt;        cin &gt;&gt; cnt;        s[i] = cnt;        for(int j = 1; j &lt;= cnt; j++){            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];        }    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;= m; j++){            for(int k = 0; k &lt;= s[i]; k++){                if(j - v[i][k] &gt;=0 )                    f[i][j] = max(f[i][j], f[i-1][j-v[i][k]] + w[i][k]);            }        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int v[N][N], w[N][N], s[N];int f[N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; s[i];        for(int j = 1; j &lt;= s[i]; j++){            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];        }    }    for(int i = 1; i &lt;= n; i++){        for(int j = m; j &gt;= 0; j--){            for(int k = 0; k &lt;= s[i]; k++){                if(j - v[i][k] &gt;=0 )                    f[j] = max(f[j], f[j-v[i][k]] + w[i][k]);            }        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习复习</title>
    <link href="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/"/>
    <url>/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="1-判别模型vs生成模型"><a href="#1-判别模型vs生成模型" class="headerlink" title="1.判别模型vs生成模型"></a>1.判别模型vs生成模型</h2><p>生成模型是由数据先学习联合概率分布$P(X,Y)$，然后求出条件概率分布作为预测模型。如朴素贝叶斯和隐马尔可夫模型。</p><p>判别方法是直接根据数据学习决策函数$f(X)$或者条件概率分布$P(Y|X)$作为预测的模型(学习一个决策边界)。典型的模型由SVM，k近邻，感知机，决策树、最大熵模型、条件随机场等。</p><p>判别: discriminative</p><p>生成: generative</p><h2 id="2-评测指标"><a href="#2-评测指标" class="headerlink" title="2.评测指标"></a>2.评测指标</h2><h3 id="2-1-准确率，精确率，召回率，F1值"><a href="#2-1-准确率，精确率，召回率，F1值" class="headerlink" title="2.1 准确率，精确率，召回率，F1值"></a>2.1 准确率，精确率，召回率，F1值</h3><ul><li>tp: 预测为正类，实际为正类</li><li>fp:预测为正类，实际为负类</li><li>tn:预测为负类，实际为负类</li><li>fn:预测为负类，实际为正类</li></ul><p>准确率</p><script type="math/tex; mode=display">acc = \frac{tp + tn}{tp + tn + fp + fn}</script><p>精确率</p><script type="math/tex; mode=display">p = \frac{tp}{tp + fp}</script><p>召回率</p><script type="math/tex; mode=display">r = \frac{tp}{tp + fn}</script><p>F1值:精确率和召回率的调和平均</p><script type="math/tex; mode=display">F1 = \frac{2*p*r}{p+r}</script><h2 id="3-朴素贝叶斯"><a href="#3-朴素贝叶斯" class="headerlink" title="3. 朴素贝叶斯"></a>3. 朴素贝叶斯</h2><p>先验概率分布: $P(Y = c_k)$</p><p>条件概率分布:$P(X = x|Y = c_k)$</p><p>由上面两个概率得到联合概率分布:</p><script type="math/tex; mode=display">P(X = x,Y = c_k) = P(X = x| y = c_k) P(y = c_k)</script><p>朴素贝叶斯<strong>条件独立性假设</strong>（朴素的含义）:</p><p>当$Y$确定时，$X$的各个特征分量取值之间相互独立，用公式表示:</p><script type="math/tex; mode=display">P(X=x|y = c_k) = P(X = x_1,x_2,...,x_n|y = c_k) = \prod_{j = 1}^{n}P(X_j = x_j|y = c_k)</script><p>后验概率:(结合上式计算)</p><script type="math/tex; mode=display">P(Y = c_k|X) = \frac{P(X = x|Y = c_k)P(Y = c_k)}{P(X)} = \frac{P(X = x|Y = c_k)P(Y = c_k)}{\sum_{k} P(X = x|y = c_k)P(y = c_k)}</script><p><strong>在估计条件概率$P(X)$时出现概率为0的情况怎么办？</strong></p><p>贝叶斯估计:</p><p>在每个随机变量的哥哥取值的频数上各加一个正数$\lambda$,常取$\lambda = 1$</p><h2 id="4-决策树"><a href="#4-决策树" class="headerlink" title="4.决策树"></a>4.决策树</h2><h3 id="4-1算法流程"><a href="#4-1算法流程" class="headerlink" title="4.1算法流程"></a>4.1算法流程</h3><p><img src="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/dtree.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200701214058220"></p><h3 id="4-2-决策树的三个停止条件"><a href="#4-2-决策树的三个停止条件" class="headerlink" title="4.2 决策树的三个停止条件:"></a><strong>4.2 决策树的三个停止条件:</strong></h3><ul><li>当前节点包含的样本属于同一类别，无需划分。</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无需划分。把当前节点标记为叶节点，类别设定为它的父节点所含样本最多的类别</li><li>当前节点包含的样本集合为空，不能划分。把父节点样本分布作为当前结点的先验分布。</li></ul><h3 id="4-3划分选择"><a href="#4-3划分选择" class="headerlink" title="4.3划分选择:"></a><strong>4.3划分选择:</strong></h3><h4 id="4-3-1信息增益ID3"><a href="#4-3-1信息增益ID3" class="headerlink" title="4.3.1信息增益ID3"></a>4.3.1信息增益ID3</h4><p>信息熵: 度量样本集合纯度，熵越大，越混乱。公式如下:$p_k$表示样本集合D中第k类样本所占比例。</p><script type="math/tex; mode=display">Ent(D)  =- \sum_{k = 1}^{C}p_klog(p_k)</script><p>信息增益,使用a属性划分，划分后产生V个分支节点，信息增益公式为:</p><script type="math/tex; mode=display">Gain(D,a) = Ent(D) - \sum_{v = 1}^{V}\frac{D^v}{D}Ent(D^v)</script><h4 id="4-3-2增益率C4-5"><a href="#4-3-2增益率C4-5" class="headerlink" title="4.3.2增益率C4.5"></a>4.3.2增益率C4.5</h4><p>信息增益准则对可取数目比较多的属性有所偏好，(可取属性越多，划分越纯)，为减少这种偏好可能带来的不利影响，使用增益率作为划分依据。</p><script type="math/tex; mode=display">Gain_ratio(D,a) = \frac{Gain(D,a)}{IV(a)}\\IV (a)  =-\sum_{v = 1}^V\frac{|D^v|}{|D|}log2\frac{|D^v|}{|D|}</script><p>属性a的可能取值越多，IV越大</p><h4 id="4-3-3基尼指数CART"><a href="#4-3-3基尼指数CART" class="headerlink" title="4.3.3基尼指数CART"></a>4.3.3基尼指数CART</h4><p>从数据集D中随机抽取两个样本，类别不一致的概率。Gini越小，纯度越高。</p><script type="math/tex; mode=display">Gini(D) = \sum_{k=1}^C\sum_{u != k}p_k p_u = 1 - \sum_{k = 1}^{C}p_{k}^2</script><p>基尼指数为:选择使基尼指数最小a的作为划分依据。</p><script type="math/tex; mode=display">Gini_index(D,a) = \sum_{v=1}^{V}\frac{|D^v|}{|D|}Gini(D^v)</script><h3 id="4-4-剪枝"><a href="#4-4-剪枝" class="headerlink" title="4.4 剪枝"></a>4.4 剪枝</h3><p>提高泛化能力，避免过拟合。</p><h4 id="4-4-1预剪枝"><a href="#4-4-1预剪枝" class="headerlink" title="4.4.1预剪枝"></a>4.4.1预剪枝</h4><p>比较划分前后的验证集精度，如果划分后验证集精度不能提升，则禁止划分，类别标记为最多的类。有欠拟合的风险。</p><h4 id="4-4-2-后剪枝"><a href="#4-4-2-后剪枝" class="headerlink" title="4.4.2 后剪枝"></a>4.4.2 后剪枝</h4><p>自底向上的剪枝方法。后续遍历决策树内部节点，比较剪枝前后的验证集精度。</p><h3 id="4-5-连续值处理"><a href="#4-5-连续值处理" class="headerlink" title="4.5 连续值处理"></a>4.5 连续值处理</h3><p>二分法。与离散属性不同，若当前节点划分属性为连续属性，该属性还可作为其后代节点的划分属性。</p><h2 id="5-线性回归"><a href="#5-线性回归" class="headerlink" title="5.线性回归"></a>5.线性回归</h2><p>损失函数为L2距离</p><h2 id="6-逻辑回归"><a href="#6-逻辑回归" class="headerlink" title="6.逻辑回归"></a>6.逻辑回归</h2><h3 id="6-1二项式逻辑回归"><a href="#6-1二项式逻辑回归" class="headerlink" title="6.1二项式逻辑回归"></a>6.1二项式逻辑回归</h3><script type="math/tex; mode=display">P(Y = 1|x)  = \frac{exp(w^T x+b)}{1+exp(w^T x+b)}\\P(Y = 0|x) = \frac{1}{1+exp(w^T x+b)}</script><p>损失函数为交叉熵，可以根据极大似然估计获得。</p><h3 id="6-2多项式逻辑回归"><a href="#6-2多项式逻辑回归" class="headerlink" title="6.2多项式逻辑回归"></a>6.2多项式逻辑回归</h3><script type="math/tex; mode=display">P(Y = k|x)  = \frac{exp(w^T x_k+b)}{1+\sum_{k=1}^{K-1}exp(w^T x_k+b)},k = 1,2,..K-1\\P(Y = K|x) = \frac{1}{1+\sum_{k=1}^{K-1}exp(w^T x_k+b)}</script><h2 id="7-隐马尔可夫模型"><a href="#7-隐马尔可夫模型" class="headerlink" title="7.隐马尔可夫模型"></a>7.隐马尔可夫模型</h2><h3 id="7-1HMM属性"><a href="#7-1HMM属性" class="headerlink" title="7.1HMM属性"></a>7.1HMM属性</h3><ul><li>Q:所有可能状态集合${q_1,q_2,…,q_N}$</li><li>V:所有可能的观测集合${v_1,v_2,…,v_M}$</li><li>I:长度为T的状态序列${i_1,i_2,…i_T}$</li><li>O::长度为T的观测序列${o_1,o_2,…,o_T}$</li><li>A:状态转移矩阵,$N×N$,$a_{ij}$表示在时刻t处于状态$q_i$的条件下在时刻t+1转移到状态$q_j$的概率。</li><li>B:观测概率矩阵,$N×M$，$b_j$表示t时刻处于状态$q_j$生成观测$v_k$的概率。</li><li>$\pi$:初始状态概率向量，$\pi_i = P(i_1 = q_i)$</li></ul><h3 id="7-2-隐马尔可夫三要素"><a href="#7-2-隐马尔可夫三要素" class="headerlink" title="7.2 隐马尔可夫三要素"></a>7.2 隐马尔可夫三要素</h3><script type="math/tex; mode=display">\lambda = (A,B,\pi)</script><h3 id="7-3-隐马尔可夫两个基本假设"><a href="#7-3-隐马尔可夫两个基本假设" class="headerlink" title="7.3 隐马尔可夫两个基本假设"></a>7.3 隐马尔可夫两个基本假设</h3><p><strong>齐次马尔可夫性假设</strong>:马尔可夫在t+1时刻的状态只依赖于其前一时刻的状态。</p><p><strong>观测独立性假设</strong>：当前观测值只依赖于当前状态。</p><h3 id="7-4隐马尔可夫的三个问题"><a href="#7-4隐马尔可夫的三个问题" class="headerlink" title="7.4隐马尔可夫的三个问题"></a>7.4隐马尔可夫的三个问题</h3><ul><li><strong>概率问题</strong>:已知模型和观测序列，计算观测序列出现的概率$P(O|\lambda)$。</li><li><strong>学习问题</strong>:已知观测序列，估计模型参数，使得在该模型下观测序列概率$P(O|\lambda)$最大。</li><li><strong>预测问题</strong>:已知模型和观测序列，求对给定观测序列条件概率$P(I|O)$最大的状态序列I,即给定观测序列，求最有可能对应的状态序列。解码，分词。维特比(Viterbi)算法.</li></ul><h3 id="7-5-预测问题"><a href="#7-5-预测问题" class="headerlink" title="7.5 预测问题"></a>7.5 预测问题</h3><h2 id="8-聚类"><a href="#8-聚类" class="headerlink" title="8.聚类"></a>8.聚类</h2><h3 id="8-1-K-means"><a href="#8-1-K-means" class="headerlink" title="8.1 K-means"></a>8.1 K-means</h3><p><strong>算法流程:</strong></p><ul><li>输入聚类簇的个数k。</li><li>从数据集中随机选择k个数据点作为初始的质心。</li><li>对训练集中的每一个样本，计算它于质心的距离，距离哪个质心进，就属于那一组。</li><li>然后每个组重新求质心。</li><li>如果新的质心于原来质心的距离的和小于某个阈值，算法停止，否则继续迭代。</li></ul><p>细节问题:</p><p>​    1. K值怎么定？我怎么知道应该几类？ 答：这个真的没有确定的做法，分几类主要取决于个人的经验与感觉，通常的做法是多尝试几个K值，看分成几类的结果更好解释，更符合分析目的等。或者可以把各种K值算出的SSE做比较，取最小的SSE的K值。</p><p>​    2. 初始的K个质心怎么选？ 答：最常用的方法是随机选，初始质心的选取对最终聚类结果有影响，因此算法一定要多执行几次，哪个结果更reasonable，就用哪个结果。 当然也有一些优化的方法，第一种是选择彼此距离最远的点，具体来说就是先选第一个点，然后选离第一个点最远的当第二个点，然后选第三个点，第三个点到第一、第二两点的距离之和最小，以此类推。第二种是先根据其他聚类算法（如层次聚类）得到聚类结果，</p><pre><code>3. K-Means会不会陷入一直选质心的过程，永远停不下来？ 答：不会，有数学证明K-Means一定会收敛，大致思路是利用SSE的概念（也就是误差平方和），即每个点到自身所归属质心的距离的平方和，这个平方和是一个函数，然后能够证明这个函数是可以最终收敛的函数。 4. 缺点:只能处理球形的簇(只适用于凸样本集)。</code></pre><h3 id="8-2-DBSCAN"><a href="#8-2-DBSCAN" class="headerlink" title="8.2 DBSCAN"></a>8.2 DBSCAN</h3><p>​    DBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种基于密度的空间聚类算法。 该算法将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，它将簇定义为密度相连的点的最大集合。DBSCAN算法的显著优点是聚类速度快且能够有效处理噪声点和发现<strong>任意形状的空间聚类</strong>。<br>​     该算法利用基于密度的聚类的概念，即要求聚类空间中的一定区域内所包含对象（点或其他空间对象）的数目不小于某一给定阈值。过滤低密度区域，发现稠密度样本点。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</p><p>思想:同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</p><p><strong>概念:</strong></p><ul><li>核心对象: 对一个样本，在它的一个给定邻域内，样本的个数大于等于给定的阈值，则称该样本是核心对象。</li><li>密度直达: 如果$x_i$位于$x_j$的邻域中，且$x_j$是核心对象，那么$x_i$可由$x_j$密度直达。</li><li>密度可达:对于$x_i$和$x_j$,如果存在样本序列$p_1,p_2,…,p_T$满足$p_1 = x_i,p_t = x_j$,$p_t+1$可有$p_t$密度直达，则$x_j$由$x_i$密度可达。注意$p_1,…p_t+1$是核心对象。</li><li>密度相连:对于$x_i$和$x_j$,如果存在核心对象样本$x_k$,使得$x_i$和$x_j$均有$x_k$ 密度可达。</li></ul><p><strong>算法流程</strong>:</p><ul><li>找出所有核心对象 </li><li>从一个核心对象出发建立一个簇 </li><li>从核心对象集中去除已经被分簇的核心对象</li><li>对剩余核心对象重复执行第2、3步，至核心对象集为空。</li></ul><p><strong>如何从一个核心对象出发建立簇</strong>:</p><pre><code> 初始，给定数据集D中所有对象都被标记为“unvisited”，DBSCAN随机选择一个未访问的对象p，标记p为“visited”，并检查p的**ϵ-**领域是否至少包含MinPts个对象。如果不是，则p被标记为噪声点。否则为p创建一个新的簇C，并且把p的**ϵ-**领域中所有对象都放在候选集合N中。DBSCAN迭代地把N中不属于其他簇的对象添加到C中。在此过程中，对应N中标记为“unvisited”的对象 P&#39; ,DBSCAN把它标记为“visited”，并且检查它的**ϵ-**领域，如果 P&#39; 的**ϵ-**领域至少包含MinPts个对象，则P&#39; 的**ϵ-**领域中的对象都被添加到N中。DBSCAN继续添加对象到C，直到C不能扩展，即直到N为空。此时簇C完成生成，输出。</code></pre><h3 id="8-3评价指标"><a href="#8-3评价指标" class="headerlink" title="8.3评价指标"></a>8.3评价指标</h3><p>标准: 簇内相似度高，簇间相似度低</p><p>内部指标:</p><p>DB指数</p><p><img src="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/dbi.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200721150259920"></p><p>外部指标:</p><p>Jaccard 系数</p><p><img src="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/jaccard.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200721151105353"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL</title>
    <link href="/EruLv.github.io/2020/06/20/C-STL/"/>
    <url>/EruLv.github.io/2020/06/20/C-STL/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcoed_week_1</title>
    <link href="/EruLv.github.io/2020/06/17/Leetcode-week-1/"/>
    <url>/EruLv.github.io/2020/06/17/Leetcode-week-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-打卡-week-1"><a href="#Leetcode-打卡-week-1" class="headerlink" title="Leetcode 打卡 week 1"></a>Leetcode 打卡 week 1</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例</strong></p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><p>暴力枚举$O(n^2)$</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; res;        int n = nums.size();        for(int i = 0; i &lt; n; i++){            for(int j = i; j&lt;n; j++){                if( i!=j &amp;&amp; nums[i] + nums[j] == target){                    res.push_back(i);                    res.push_back(j);                }            }        }        return res;    }};</code></pre><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>排序 + 双指针, 参考<a href="https://www.acwing.com/problem/content/802/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/802/</a></p><p>因为需要存下标，很不推荐这种方法。</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; res;        vector&lt;pair&lt;int, int&gt;&gt; a;        for(int i = 0; i&lt; nums.size();i++) a.push_back({nums[i], i});        sort(a.begin(),a.end());  //升序，nlogn        for(int i = 0, j = 0; i&lt;a.size(); i++){    //O(2n)            while(a[i].first + a[j].first &lt; target) j++;            if( i != j &amp;&amp;a[i].first + a[j].first == target) {                res.push_back(a[i].second);                res.push_back(a[j].second);            }        }        sort(res.begin(), res.end());        return res;    }};</code></pre><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h4><p>Hash map</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int, int&gt; heap;    //基于散列表，查找时间为O(1)        for(int i = 0; i&lt; nums.size(); i++){            int r = target - nums[i];   //寻找目标值            if (heap.count(r)) return {heap[r], i};    //判断是否存在该键            heap[nums[i]] = i;        }        return {};    }};</code></pre><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><pre><code class="lang-c++">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="lang-c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {        ListNode* head = new ListNode(-1);        ListNode* cur = head;        int t = 0;  //进位        while(l1 || l2 || t){   //若t最后为1，需要添加一个节点            if(l1) t += l1-&gt;val, l1 = l1-&gt;next;            if(l2) t += l2-&gt;val, l2 = l2-&gt;next;            cur-&gt;next = new ListNode(t % 10);            cur = cur-&gt;next;            t /= 10;        }        return head-&gt;next;    }};</code></pre><h3 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>双指针算法.</p><p> 假设[j,i]为最长无重复字串，i向后移动时，j只能不动或向后移动。</p><pre><code class="lang-c++">class Solution {public:    int lengthOfLongestSubstring(string s) {        unordered_map&lt;char, int&gt; heap;        int res = 0;        for(int i =0, j = 0; i&lt;s.size();i++){            heap[s[i]] ++;            while(heap[s[i]] &gt; 1){                heap[s[j]] --;                j ++;            }            res = max(res, i - j + 1);        }    return res;    }};</code></pre><p>以”pwwkew”为例：</p><pre><code class="lang-c++">i = 0, j = 0, {p:1}i = 1, j = 0, {p:1, w:1}i = 2, j = 0, {p:1, w:2}     -&gt; j++, {w:2}     -&gt; j++, {w:1}i = 3, j = 2, {k:1, w:1}i = 4, j = 2, {k:1, w:1, e:1}i = 5, j = 2, {k:1, w:2, e:1}...</code></pre><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h3><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p><strong>示例 1:</strong></p><pre><code>nums1 = [1, 3]nums2 = [2]则中位数是 2.0</code></pre><p><strong>示例 2:</strong></p><pre><code>nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>思想和归并排序相同。$O(m+n)$</p><pre><code class="lang-c++">class Solution {public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        double res;        vector&lt;int&gt; r;        int i = 0 , j = 0;        while(i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()){            if(nums1[i] &lt; nums2[j]) r.push_back(nums1[i++]);            else r.push_back(nums2[j++]);        }        while(i &lt; nums1.size()) r.push_back(nums1[i++]);        while(j &lt; nums2.size()) r.push_back(nums2[j++]);        int n = nums1.size() +  nums2.size();        if(n%2 == 0)            res = double(r[n&gt;&gt;1] + r[n-1&gt;&gt;1])/2;        else res = r[n&gt;&gt;1];        return res;    }};</code></pre><h4 id="Solution-2-1"><a href="#Solution-2-1" class="headerlink" title="Solution 2"></a>Solution 2</h4>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oj好题错题集</title>
    <link href="/EruLv.github.io/2020/06/11/oj%E9%94%99%E9%A2%98%E9%9B%86/"/>
    <url>/EruLv.github.io/2020/06/11/oj%E9%94%99%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="oj好题错题集"><a href="#oj好题错题集" class="headerlink" title="oj好题错题集"></a>oj好题错题集</h1><h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1.模拟"></a>1.模拟</h2><h3 id="1-1-蚂蚁坠落"><a href="#1-1-蚂蚁坠落" class="headerlink" title="1.1 蚂蚁坠落"></a>1.1 蚂蚁坠落</h3><pre><code>https://www.nowcoder.com/practice/fdd6698014c340178a8b1f28ea5fadf8?tpId=40&amp;&amp;tqId=21420&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/kaoyan/question-ranking</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>c++ 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm排序</title>
    <link href="/EruLv.github.io/2020/06/11/Algoritm%E6%8E%92%E5%BA%8F/"/>
    <url>/EruLv.github.io/2020/06/11/Algoritm%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="基础算法-一-——排序"><a href="#基础算法-一-——排序" class="headerlink" title="基础算法(一)——排序"></a>基础算法(一)——排序</h2><h3 id="1-快排"><a href="#1-快排" class="headerlink" title="1.快排"></a>1.快排</h3><p>快排是不稳定的。</p><p>基于<strong>分治</strong>，步骤:</p><ol><li>确定分界点</li><li>调整区间，&lt;=x在x左边，&gt;=x的在x右边。</li><li>递归，左边右边排序。</li></ol><pre><code class="lang-c++">void quick_sort(int q[], int l, int r){    if(l&gt;=r) return;    int x = q[l+r&gt;&gt;1], i = l - 1, j = r + 1;    while(i &lt; j){        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);    }    quick_sort(q,l,j);    quick_sort(q,j+1,r);}</code></pre><h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h3><p>归并排序是稳定的。</p><ol><li>确定分界点。mid = (l+r)/2</li><li>递归排序left,right</li><li>归并，合二为一</li></ol><pre><code class="lang-c++">void merge_sort(int q[], int l, int r){    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法 排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algoritm模板</title>
    <link href="/EruLv.github.io/2020/06/10/Algoritm%E6%A8%A1%E6%9D%BF/"/>
    <url>/EruLv.github.io/2020/06/10/Algoritm%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="C-常用算法模板（一）"><a href="#C-常用算法模板（一）" class="headerlink" title="C++常用算法模板（一）"></a>C++常用算法模板（一）</h2><p>字符串、数字、数组的基础操作。</p><h3 id="1-反序数"><a href="#1-反序数" class="headerlink" title="1.反序数"></a>1.反序数</h3><p>1234-&gt;4321。</p><p>可用于判断数字是否对称。</p><pre><code class="lang-c++">int reverse(int x){    //反序数    int r = 0;    while(x!=0){        r *= 10;        r += x%10;        x /= 10;    }     return r;}</code></pre><h4 id="2-字符串反转"><a href="#2-字符串反转" class="headerlink" title="2.字符串反转"></a>2.字符串反转</h4><pre><code class="lang-c++">string reverse(string s){    string r = &quot;&quot;;    for(int i=s.size()-1;i&gt;=0;i--){        r += s[i];    }    return r;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法 c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT甲级1001</title>
    <link href="/EruLv.github.io/2020/05/22/PAT%E7%94%B2%E7%BA%A71001/"/>
    <url>/EruLv.github.io/2020/05/22/PAT%E7%94%B2%E7%BA%A71001/</url>
    
    <content type="html"><![CDATA[<h2 id="A-B-Format"><a href="#A-B-Format" class="headerlink" title="A+B Format"></a>A+B Format</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Calculate A + B and output the sum in standard format—hat is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where  </p><script type="math/tex; mode=display">-10^6<= a,b <= 10^6</script><p>The numbers are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="lang-c++">-1000000 9</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="lang-c++">-999,991</code></pre><h3 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution:"></a>My Solution:</h3><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    int a,b;    cin&gt;&gt;a&gt;&gt;b;    int r = a+b;    if(r==0){        cout&lt;&lt;0&lt;&lt;endl;        return 0;    }    int flag = r/abs(r);    if(flag==-1)        cout&lt;&lt;&quot;-&quot;;    string s = to_string(abs(r));    int j = 3-s.size()%3;    bool f = j==0;    for(int i=0;i&lt;s.size();i++){        if((i+j)%3==0 &amp;&amp; i!=0){             cout&lt;&lt;&quot;,&quot;;        }        cout&lt;&lt;s[i];    }    cout&lt;&lt;endl;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>字符串处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/EruLv.github.io/2020/05/22/test/"/>
    <url>/EruLv.github.io/2020/05/22/test/</url>
    
    <content type="html"><![CDATA[<h1 id="This-is-a-test"><a href="#This-is-a-test" class="headerlink" title="This is a test."></a>This is a test.</h1><p><img src="/EruLv.github.io/2020/05/22/test/test1.jpg" srcset="/EruLv.github.io/img/loading.gif" alt="test1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp常用函数</title>
    <link href="/EruLv.github.io/2020/03/19/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/EruLv.github.io/2020/03/19/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="c-常用函数"><a href="#c-常用函数" class="headerlink" title="c++常用函数"></a>c++常用函数</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort:"></a>sort:</h4><p>头文件:</p><pre><code class="lang-c++">#include&lt;algorithm&gt;</code></pre><p>使用方法:</p><pre><code class="lang-c++">void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></pre><p>（1）第一个参数first：是要排序的数组的起始地址。</p><p>（2）第二个参数last：是结束的地址（最后一个数据的后一个数据的地址）</p><p>（3）第三个参数comp是排序的方法：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是<strong>从小到大</strong>排序。</p><h4 id="qsort"><a href="#qsort" class="headerlink" title="qsort:"></a>qsort:</h4><pre><code class="lang-c++">void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</code></pre><ul><li><p><strong>base</strong> — 指向要排序的数组的第一个元素的指针。</p></li><li><p><strong>nitems</strong> — 由 base 指向的数组中元素的个数。</p></li><li><p><strong>size</strong> — 数组中每个元素的大小，以字节为单位。</p></li><li><p><strong>compar</strong> — 用来比较两个元素的函数。</p></li></ul><h3 id="2-输出保留小数后几位"><a href="#2-输出保留小数后几位" class="headerlink" title="2.输出保留小数后几位"></a>2.输出保留小数后几位</h3><p>头文件:</p><pre><code class="lang-c++">#include&lt;iomanip&gt;</code></pre><p>需要补零:</p><pre><code class="lang-c++">cout&lt;&lt;fixed&lt;&lt;setprecision(需要精确到小数点后几位)&lt;&lt;ans&lt;&lt;endl;</code></pre><p>不需要补零:</p><pre><code class="lang-c++">cout&lt;&lt;setprecision(需要精确到小数点后几位)&lt;&lt;ans&lt;&lt;endl;</code></pre><p><strong>推荐</strong>：更简单的方法:使用printf()</p><pre><code class="lang-c++">float d = 0.235;printf(&quot;%.5f\n&quot;,d);</code></pre><p>结果:0.23500</p><pre><code class="lang-c++">float d = 0.235;printf(&quot;%.2f\n&quot;,d);</code></pre><p>结果: 0.23</p><h3 id="3-格式化输出-日期"><a href="#3-格式化输出-日期" class="headerlink" title="3.格式化输出(日期)"></a>3.格式化输出(日期)</h3><pre><code class="lang-c++">printf(&quot;%04d-%02d-%02d\n&quot;,yyyy,mm,dd);</code></pre><p>会右对齐左补0.</p><h3 id="4-全局变量声明"><a href="#4-全局变量声明" class="headerlink" title="4.全局变量声明"></a>4.全局变量声明</h3><p>声明的int 的全局变量，数组会默认初始化为0.</p><h3 id="5-无限大与无限小-inf"><a href="#5-无限大与无限小-inf" class="headerlink" title="5.无限大与无限小(inf)"></a>5.无限大与无限小(inf)</h3><pre><code class="lang-c++">int inf = 1e9;//更好的: int最大2^31 - 1, 约等于10^9。int inf = 0x3f3f3f3f;</code></pre><h3 id="6-string与int互转"><a href="#6-string与int互转" class="headerlink" title="6.string与int互转"></a>6.string与int互转</h3><p>atoi:(表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。</p><pre><code class="lang-c++">string s = &quot;123&quot;;int x = atoi(s.c_str());cout&lt;&lt;x&lt;&lt;endl;</code></pre><p>int转字符串</p><pre><code class="lang-c++">#include&lt;string&gt;string s = &quot;&quot;;int x = 5;s = to_string(x);</code></pre><p>c</p><h3 id="7-输入带空格的字符串"><a href="#7-输入带空格的字符串" class="headerlink" title="7.输入带空格的字符串"></a>7.输入带空格的字符串</h3><pre><code class="lang-c++">#include&lt;string.h&gt;char str[1000];gets(str);int len = strlen(str);</code></pre><p>or</p><pre><code class="lang-c++">#include&lt;string&gt;string str;getline(cin , str);cout&lt;&lt;str&lt;&lt;endl;</code></pre><h3 id="8-清空数组"><a href="#8-清空数组" class="headerlink" title="8.清空数组"></a>8.清空数组</h3><p>memset函数</p><pre><code class="lang-c++">#include &lt;cstring&gt;const int N = 128;int hs[N];int main(){    hs[0] = 5;    cout&lt;&lt;hs[0]&lt;&lt;endl;    memset(hs, 0 , sizeof(hs));    cout&lt;&lt;hs[0]&lt;&lt;endl;    return 0;}</code></pre><h3 id="9-分词"><a href="#9-分词" class="headerlink" title="9. 分词"></a>9. 分词</h3><pre><code class="lang-c++">    //分词    s += &quot; &quot;;    string tmp = &quot;&quot;;    int m = 0;    for(int i = 0; i &lt; s.size(); i++){        if(s[i] == &#39; &#39;){            w[m++] = tmp;            tmp = &quot;&quot;;        }        else{            tmp += s[i];        }    }</code></pre><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵求导运算</title>
    <link href="/EruLv.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E8%BF%90%E7%AE%97/"/>
    <url>/EruLv.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵求导运算推导与总结"><a href="#矩阵求导运算推导与总结" class="headerlink" title="矩阵求导运算推导与总结"></a>矩阵求导运算推导与总结</h2><h3 id="1-标量对向量求导"><a href="#1-标量对向量求导" class="headerlink" title="1.标量对向量求导"></a>1.标量对向量求导</h3><p>输入向量，输出标量。即映射关系为$f:R^N➡R$ 。</p><p>设$y = f(\boldsymbol{x})$ ,$\boldsymbol{x}$是Nx1的矢量，y是标量。</p><p>则求导结果为:</p><script type="math/tex; mode=display">\frac{\partial y}{\partial \boldsymbol{x}}=\left(\frac{\partial y}{\partial x_{1}}, \frac{\partial y}{\partial x_{2}}, \ldots, \frac{\partial y}{\partial x_{N}}\right)</script><h3 id="2-向量对向量求导"><a href="#2-向量对向量求导" class="headerlink" title="2.向量对向量求导"></a>2.向量对向量求导</h3><p>输入向量，输出也是向量，则需要用到 Jacobian矩阵。</p><p>假设映射关系为$f:R^N➡R^M$ ,输入输出都为向量。$\boldsymbol{y} = f(\boldsymbol{x})$ ,则有:</p><script type="math/tex; mode=display">\frac{\partial y}{\partial x}=\left(\begin{array}{ccc}\frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{1}}{\partial x_{N}} \\\vdots & \ddots & \vdots \\\frac{\partial y_{M}}{\partial x_{1}} & \cdots & \frac{\partial y_{M}}{\partial x_{N}}\end{array}\right)</script><p>输出MxN的矩阵。</p><script type="math/tex; mode=display">\left(\frac{\partial \boldsymbol{y}}{\partial \boldsymbol{x}}\right)_{i j}=\frac{\partial y_{i}}{\partial x_{j}}</script><h4 id="2-1-x-为列向量"><a href="#2-1-x-为列向量" class="headerlink" title="2.1$x$为列向量"></a>2.1$x$为列向量</h4><p>假如$W$ 是一个NxM的矩阵，$\boldsymbol{z}=\boldsymbol{W}\boldsymbol{x}$ ，$\boldsymbol{x}$为Mx1的列向量，$\boldsymbol{z}$为Nx1的列向量,Jacobian矩阵为NxM维。</p><script type="math/tex; mode=display">z_{i}=\sum_{k=1}^{m} W_{i k} x_{k}</script><script type="math/tex; mode=display">\left(\frac{\partial \boldsymbol{z}}{\partial \boldsymbol{x}}\right)_{i j}=\frac{\partial z_{i}}{\partial x_{j}}=\frac{\partial}{\partial x_{j}} \sum_{k=1}^{m} W_{i k} x_{k}=\sum_{k=1}^{m} W_{i k} \frac{\partial}{\partial x_{j}} x_{k}=W_{i j}</script><p>所以</p><script type="math/tex; mode=display">\frac{\partial{\boldsymbol{z}}}{\partial{\boldsymbol{x}}} = \boldsymbol{W}</script><h4 id="2-2-x-为行向量"><a href="#2-2-x-为行向量" class="headerlink" title="2.2 $x$为行向量"></a>2.2 $x$为行向量</h4><p>假设有$\boldsymbol{z}=\boldsymbol{x}\boldsymbol{W}$ ，$\boldsymbol{x}$为1xN的列向量，$\boldsymbol{z}$为1xM的列向量.W维度为NxM,Jacobian矩阵为MxN.</p><script type="math/tex; mode=display">\frac{\partial{\boldsymbol{z}}}{\partial{\boldsymbol{x}}} = \boldsymbol{W^T}</script><h3 id="3-向量对矩阵求导"><a href="#3-向量对矩阵求导" class="headerlink" title="3.向量对矩阵求导"></a>3.向量对矩阵求导</h3>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
