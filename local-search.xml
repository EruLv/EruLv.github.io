<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java基础2</title>
    <link href="/EruLv.github.io/2020/08/18/java%E5%9F%BA%E7%A1%802/"/>
    <url>/EruLv.github.io/2020/08/18/java%E5%9F%BA%E7%A1%802/</url>
    
    <content type="html"><![CDATA[<h2 id="Java基础2"><a href="#Java基础2" class="headerlink" title="Java基础2"></a>Java基础2</h2><h2 id="8-接口"><a href="#8-接口" class="headerlink" title="8.接口"></a>8.接口</h2><h3 id="1-抽象方法和抽象类"><a href="#1-抽象方法和抽象类" class="headerlink" title="1.抽象方法和抽象类"></a>1.抽象方法和抽象类</h3><p>仅有声明而没有方法体。</p><pre><code class="lang-java">abstract class Instrument {    //抽象类  private int i; // Storage allocated for each  public abstract void play(Note n);    //抽象方法  public String what() { return &quot;Instrument&quot;; }  public abstract void adjust();}</code></pre><p>包含抽象方法的类叫做抽象类。<strong>如果一个类包含一个或多个抽象方法，则该类必须是抽象的。</strong></p><p><strong>如果从一个抽象类继承，必须为基类中的所有抽象方法提供定义，否则该类也会被强制认为是抽象类。</strong></p><h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h3><p>更纯粹的抽象方法，<strong>接口内不能有方法体。</strong></p><p>用<code>interface</code>关键字代替<code>class</code></p><p>要想某个类遵循特定的接口，需要用<code>implements</code>关键字（类似于<code>extents</code>，必须实现接口的全部方法。</p><p>接口类中的方法必须被定义为<code>public</code>（默认<code>public</code>）。</p><pre><code class="lang-java">interface Instrument {  int VALUE = 5;   void play(Note n); // Automatically public  void adjust();}class Wind implements Instrument {  public void play(Note n) {    print(this + &quot;.play() &quot; + n);  }  public String toString() { return &quot;Wind&quot;; }  public void adjust() { print(this + &quot;.adjust()&quot;); }}</code></pre><h3 id="3-多重继承"><a href="#3-多重继承" class="headerlink" title="3.多重继承"></a>3.多重继承</h3><p>在<code>implements</code>可以添加多个接口，用逗号隔开。</p><p>当同时有继承操作时，需要把<code>extends</code>放在前面。</p><pre><code class="lang-java">interface CanFight {  void fight();}interface CanSwim {  void swim();}interface CanFly {  void fly();}class ActionCharacter {  public void fight() {}}  //继承+接口class Hero extends ActionCharacter    implements CanFight, CanSwim, CanFly {  public void swim() {}  public void fly() {}}</code></pre><h3 id="4-通过继承拓展接口"><a href="#4-通过继承拓展接口" class="headerlink" title="4.通过继承拓展接口"></a>4.通过继承拓展接口</h3><p>接口与类一样也可以继承。</p><pre><code class="lang-java">interface Monster {  void menace();}interface DangerousMonster extends Monster {  void destroy();}interface Lethal {  void kill();}class DragonZilla implements DangerousMonster {  public void menace() {}  public void destroy() {}}  interface Vampire extends DangerousMonster, Lethal {  void drinkBlood();}class VeryBadVampire implements Vampire {  public void menace() {}  public void destroy() {}  public void kill() {}  public void drinkBlood() {}}</code></pre><h3 id="5-接口中的域"><a href="#5-接口中的域" class="headerlink" title="5.接口中的域"></a>5.接口中的域</h3><p>接口中的域默认时<code>static</code>和<code>final</code>的，即全局常量。</p><pre><code class="lang-java">public interface RandVals {  Random RAND = new Random(47);  int RANDOM_INT = RAND.nextInt(10);  long RANDOM_LONG = RAND.nextLong() * 10;  float RANDOM_FLOAT = RAND.nextLong() * 10;  double RANDOM_DOUBLE = RAND.nextDouble() * 10;} public class TestRandVals {  public static void main(String[] args) {    print(RandVals.RANDOM_INT);    print(RandVals.RANDOM_LONG);    print(RandVals.RANDOM_FLOAT);    print(RandVals.RANDOM_DOUBLE);  }} /* Output:8-32032247016559954-8.5939291E185.779976127815049*///:~</code></pre><h3 id="6-嵌套接口"><a href="#6-嵌套接口" class="headerlink" title="6.嵌套接口"></a>6.嵌套接口</h3><p>在类中声明接口，接口是<code>static</code>的，其他类可以通过类名访问接口。类内的接口可以设置为<code>默认</code>,<code>public</code>，<code>private</code>。</p><pre><code class="lang-java">class A {  interface B {    void f();  }  public class BImp implements B {    public void f() {}  }  private class BImp2 implements B {    public void f() {}  }  public interface C {    void f();  }  class CImp implements C {    public void f() {}  }      private class CImp2 implements C {    public void f() {}  }  private interface D {    void f();  }  private class DImp implements D {    public void f() {}  }  public class DImp2 implements D {    public void f() {}  }  public D getD() { return new DImp2(); }  private D dRef;  public void receiveD(D d) {    dRef = d;    dRef.f();  }}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学复习</title>
    <link href="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
    <url>/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机图形学复习"><a href="#计算机图形学复习" class="headerlink" title="计算机图形学复习"></a>计算机图形学复习</h1><h2 id="1-CG基础"><a href="#1-CG基础" class="headerlink" title="1.CG基础"></a>1.CG基础</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念:"></a>1.1概念:</h3><p><strong>几何学(geometry)</strong>:几何学是研究在n维空间中物体之间关系的一门学科。</p><p><strong>几何学原语(primitives)</strong>:构建复杂的物体需要的最基础的元素。</p><p><strong>三个基本元素:</strong>标量(Scalars),向量(Vectors),点(Points)</p><p><strong>标量</strong>:标量是服从一组规则的对象，标量可以定义为集合的成员，可以通过两个操作（加法和乘法）结合一些基本公理（关联性，可交换性，逆函数）进行组合.标量没有几何属性。</p><p><strong>向量</strong>:向量由幅度和方向两个属性组成。</p><h3 id="1-2-Coordinate-Free-Geometry-无坐标几何"><a href="#1-2-Coordinate-Free-Geometry-无坐标几何" class="headerlink" title="1.2 Coordinate-Free Geometry(无坐标几何)"></a>1.2 Coordinate-Free Geometry(无坐标几何)</h3><p><strong>笛卡尔坐标系</strong>:直角坐标系和斜坐标系的统称。</p><p>物理上，点的存在与坐标系无关，如，如果两个三角形两条边及其夹角相等，则他们相同(全等)。</p><h3 id="1-3-向量空间"><a href="#1-3-向量空间" class="headerlink" title="1.3 向量空间"></a>1.3 向量空间</h3><p>1.向量空间中，向量的起点不同，但方向和长度相同的向量为同一向量。</p><p>欧几里得空间:是向量空间的扩展，增加了对大小或者距离的度量。</p><p>2.仿射空间(Affine Spaces): 点的集合+向量空间。</p><p>操作:</p><ul><li>Vector-vector addition -&gt; vector</li><li>Scalar-vector multiplication -&gt;vector</li><li>Point-vector addition -&gt; point</li><li>Scalar-scalar operations -&gt;scalar</li><li>scalar – 以上运算均与坐标系无关</li></ul><p>3.点的参数形式</p><p>参数坐标 : $P(\alpha) = P_0 + \alpha d $</p><p>点的线性运算:$P1 + P_2 = P_1 + (P2 - 0)$,得到的还是一个坐标</p><p>4.凸面体</p><p>如果该物体内部任意两个点之间组成的线段上的所有点均在该物体内部，则称该物体为凸的(convex).</p><p>5.点的仿射和(Affine Sum)</p><p>$P = a_1P_1 + a_2P_2 + …+a_nP_n$</p><p>当且仅当$a1+a2 + …a_n = 1$,则称这是点$P_1,…P_n$的仿射和。如果$a_i &gt; 0$则我们得到$P_i$的一个凸包(convex hull)</p><p>6.向量乘</p><p>点乘，叉乘(右手准则)</p><p>7.曲线和面</p><p>如何定义曲线和面</p><p>曲线:形式$为P（x）$的一个参数实体，其中函数是非线性的。</p><p>面:曲线由两个函数组成的参数定义$P(a,b)$</p><p>8.平面(Plane)</p><p>可以由一个点+两个向量或者三个点表示。</p><p>9.法向量</p><p>每个平面都有法向量，平面上的向量点乘法向量结果均为0.</p><p>10.线性无关</p><p>一系列向量$v_1,v_2,…,v_n$成为线性无关的如果:</p><script type="math/tex; mode=display">\alpha_1v_1 + \alpha_2v_2 + \alpha_3v_3 +... = 0 \\iff \alpha_1 = \alpha_2 = ... = 0</script><p>11.维度</p><p>向量空间中，线性无关向量的最大数量称为线性空间的维度。</p><p>12.坐标系中坐标的表示</p><p>设$v_1，v2,…v_n$是向量空间的一组基，一个向量可以表示为$v = \alpha_1v_1 + \alpha_2v_2 +… + \alpha_nv_n$</p><p>其中$\alpha_i$为标量</p><p>13.框架</p><p>因为坐标系只能表示向量而不能表示点，所以加上原点。即</p><p>原点+坐标系构成框架Frame,可以表示向量空间中的点。一个三维Frame的形式:$(P_0,v_1,v2,v3)$</p><p>每个点可以记作:</p><script type="math/tex; mode=display">P = P_0 + \beta_1 v_1 + \beta_2 v_2 + ... + \beta_n v_n</script><p>14.三维空间的四维表示</p><script type="math/tex; mode=display">v = \alpha_1 v_1 + \alpha_2 v_2 + \alpha_3 v_3 = [\alpha_1\alpha_2 \alpha_3][v_1 v_2 v_3 P_0]^T</script><script type="math/tex; mode=display">P = P_0 + \beta_1 v_1 + \beta_2 v_2 + \beta_3 v_3 = [\beta_1 \beta_2  \beta_3 ][v_1 v_2 v_3 P_0]^T</script><p>所以向量可以表示为:</p><script type="math/tex; mode=display">v = [\alpha_1 \alpha_2 \alpha_3 0]^T\\\p = [\beta_1 \beta_2 \beta_3 1]^T</script><p>15.同质坐标</p><p>w != 1 &amp;&amp; w != 0</p><h2 id="2-建模和渲染的Pipeline-amp-计算机观察"><a href="#2-建模和渲染的Pipeline-amp-计算机观察" class="headerlink" title="2. 建模和渲染的Pipeline&amp;计算机观察"></a>2. 建模和渲染的Pipeline&amp;计算机观察</h2><h3 id="2-1-Pipeline"><a href="#2-1-Pipeline" class="headerlink" title="2.1 Pipeline:"></a>2.1 Pipeline:</h3><ol><li>几何建模</li><li>将建模的物体放入世界坐标系。</li><li>选择摄像机的位置和方向</li><li>将物体从世界坐标系变换到视角坐标系并且投影到图像平面。</li></ol><p><strong>输入:</strong></p><p>几何模型(顶点，法向量，贴图坐标)</p><p>光照/材质模型（着色器，包括光源位置、光的颜色、光照强度、纹理映射、漫反射贴图等）</p><p>视点(ViewPoint)+投影平面(Projection Plane)</p><p><strong>输出:</strong></p><p>渲染好的彩色(深度)图片。</p><h3 id="2-2图形学渲染管线-Modern-Graphics-Pipeline"><a href="#2-2图形学渲染管线-Modern-Graphics-Pipeline" class="headerlink" title="2.2图形学渲染管线(Modern Graphics Pipeline)"></a>2.2图形学渲染管线(Modern Graphics Pipeline)</h3><p><strong>1.现代图形学渲染管线</strong></p><ol><li>把顶点投影到2D平面</li><li>三角形栅格化，查找对应的像素</li><li>计算每个像素的颜色</li><li>测试可见性(z-buffer),更新帧缓冲区颜色。</li></ol><p><strong>2.经典图形学渲染管线</strong></p><p>(几何绘制流水线)</p><p>顶点-&gt;<code>顶点处理模块</code>-&gt;<code>裁剪和图元组装模块</code>-&gt;<code>光栅化模块</code>-&gt;<code>片元处理模块</code>-&gt;像素</p><p><strong>Vertex Processor</strong>:</p><p>负责顶点的坐标变换，把顶点从一个坐标系转换到另一个坐标系。另外还负责计算每个顶点的颜色。</p><p><code>物体坐标系</code>-&gt;<code>世界坐标系</code>-&gt;<code>视角坐标系</code>-&gt;<code>图像坐标系</code></p><p><strong>Clipper and Primitive Assembler</strong>:</p><p>成像系统不可能一次对整个场景成像，所以需要将摄像机视角外的顶点裁剪掉。裁剪并须针对逐个图元进行，而不是针对逐个顶点，所以在裁剪之前必须把顶点组装成线段、多边形这样的对象，这一过程叫做图元组装。。</p><p><strong>Rasterize</strong></p><p>裁剪后的图元仍是用顶点表示的，为了生帧缓存中的像素还必须进一步处理。如果物体没有被裁剪出去，则必须为帧缓存区中的适当像素分配颜色。光栅化为每个图元生成一组片元(fragment)，片元是携带相关信息的潜在像素。每个片段都在帧缓存区中有位置，并且有颜色、深度等属性。</p><p><strong>Fragment Processor</strong></p><p>利用光栅化模块生成的片元来更新帧缓存中的元素。</p><p>片元确定帧缓冲区中相应像素的颜色，颜色可以通过纹理映射或顶点颜色的插值来确定，片元可能被更靠近相机的其他片段挡住。</p><p> 可编程流水线:</p><p>顶点处理模块和片元处理模块对于应用程序来说是可编程的，程序员只需要编写顶点着色器和片元着色器。</p><h3 id="2-3-变换"><a href="#2-3-变换" class="headerlink" title="2.3 变换"></a>2.3 变换</h3><p>1.简单变换</p><ul><li>平移Translation</li><li>旋转Rotation</li><li>等比例(各向同性)缩放Isotropic scaling</li></ul><p>简单变换是可逆的。</p><p>2.欧式变换/刚体变换</p><p>变换后角度不变，距离不变</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/rigidbody.png" srcset="/EruLv.github.io/img/loading.gif" alt="rigidbody"></p><p>3.相似度变换</p><p>保持角度不变，形状相同，只是比例，方向和位置不同.</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/similarity.png" srcset="/EruLv.github.io/img/loading.gif" alt="similarity"></p><p>4.线性变换</p><p>包括旋转，缩放，反射，错切(shear)，直观理解就是把物体一边固定，然后拉另外一边，定义如下:</p><script type="math/tex; mode=display">L(P + q) = L(p) + L(q)\\L(ap) = aL(p)</script><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Linear.png" srcset="/EruLv.github.io/img/loading.gif" alt="Linear"></p><p><strong>注意，平移变换不是线性变换，</strong></p><script type="math/tex; mode=display">f(p) = p + t\\f(ap) = ap + t 不等于a(p + t) = af(p)\\f(p+q) = p + q + t 不等于(p+t) + (q +t) = f(p) + f(q)</script><p>5.仿射变换</p><p>变换之前平行的边，变换后依旧平行</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/affine.png" srcset="/EruLv.github.io/img/loading.gif" alt="affine"></p><p>6.投影变换</p><p>线依旧是线</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/projective.png" srcset="/EruLv.github.io/img/loading.gif" alt="projective"></p><p>7.Transforms are groups</p><p>你可以用一个变换来代替一连串变换。</p><p>比如， object-to-world transformation, world-to-view transformation,view-to-image transformation能够用 object-to image transformation一个变换表示。</p><h3 id="2-4观察投影"><a href="#2-4观察投影" class="headerlink" title="2.4观察投影"></a>2.4观察投影</h3><p>二维的线性变换可以用二维矩阵来表示，但是二维的仿射变换需要用一个额外的坐标系来表示平移。</p><p>其次坐标系就是在原来的向量空间中添加一个额外的维度，比如用三维坐标系就可以表示二维空间的仿射变换。</p><p><strong>1.投影中的相等</strong>:</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/1.png" srcset="/EruLv.github.io/img/loading.gif" alt="1"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/2.png" srcset="/EruLv.github.io/img/loading.gif" alt="2"></p><p>w的值(不为0)归一化后不影响最终成像的位置。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/why.png" srcset="/EruLv.github.io/img/loading.gif" alt="why"></p><p>从相机的角度来看，线上的所有3D点都位于图像中相同的2D坐标上。从这个意义上讲，所有这些3D点都是“相同的”。</p><p>警告⚠:当我们把w归一化后，由于我们将场景展平到z = 1平面上，因此我们丢失了有关到相机距离的所有信息。(Z-buffer来解决这个问题)</p><p><strong>2.使用齐次坐标系的好处</strong></p><p>以上所有的投影变换在其次坐标系中都是线性的。</p><p><strong>3.投影 Orthographic vs. Perspective</strong></p><p>投影包括两个基本操作:<strong>模-视变换</strong>和<strong>投影变换</strong>。</p><p><strong>模-视变换</strong>:将模型从对象坐标系变换到世界坐标系(模型变换)，最后变换到相机坐标系(视角变换)。</p><p><strong>投影变换</strong>:把指定的投影应用于顶点，并把位于指定视见体内部的对象变换到位于裁剪坐标系中的裁剪立方体的内部。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/view.png" srcset="/EruLv.github.io/img/loading.gif" alt="view"></p><p><strong>4.两个主要投影</strong></p><p><strong>(1)正交投影Orthographic :</strong>其视景体为长方体，投影物体的大小不会随视点与远平面之间的距离而变.沿着z轴将所有点投影到z = 0的平面上。特点:变换矩阵中z所在行全为0.视见体为正六边形(边长为2的正方体)，正投影只“看到”了视见体内的对象。距离和形状都没有失真，适合在工程中使用。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/orthographic.png" srcset="/EruLv.github.io/img/loading.gif" alt="orthographic"></p><p><strong>(2)透视投影Perspective:</strong> 将沿z轴的所有点投影到z = d的平面上，并在原点上放置视点。特点:投影后距离观察者越远，成像越小。</p><p>【变换矩阵推导】</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/prespective.png" srcset="/EruLv.github.io/img/loading.gif" alt="prespective"></p><p>消失点(vanishing point)</p><p>透视投影中，物体上的平行线（不平行于投影平面）会聚在投影中的单个点上，这个点就是消失点。</p><p>透视投影的优缺点:</p><ul><li>物体离观察者越远成像越小，与人的现实感受相符。</li><li>不均匀缩短:沿线的相等距离投影后距离不一定相等。</li><li>只有与投影平面平行的平面上的角投影后角度不变。</li><li>用手构造比平行投影更困难（但用计算机难度更大）。</li></ul><p><strong>5.计算机视图Computer Viewing</strong></p><p>计算机中用到了3中视图处理:</p><p>摄像机定位，设置model-view 矩阵</p><p>选择镜头，设置投影方式</p><p>裁剪，设置投影的参数，选择视景范围。</p><h3 id="2-5-OpenGL-Camera"><a href="#2-5-OpenGL-Camera" class="headerlink" title="2.5 OpenGL Camera"></a>2.5 OpenGL Camera</h3><p><strong>1.基础</strong></p><p>OpenGL中，相机初始化在原点，指向z轴负方向，默认的投影方式是正交的。</p><p>如果我们想要显示一个在原点的物体，包括它的z轴正坐标和负坐标部分，我们需要使摄像机远离物体。可以采取的措施是:</p><ul><li>将摄像机朝z轴正方向平移。</li><li>或将物体朝z轴负方向平移。</li></ul><p>用代码表示是:</p><p>即使物体朝着z轴负方向移动。</p><pre><code class="lang-c++">glTranslatef(0.0,0.0,-d);     //物体向z轴正方向or相机朝z轴正方向平移//d &gt; 0</code></pre><p>旋转相机</p><pre><code class="lang-c++">glRotatef(-90.0, 0.0, 1.0, 0.0);     //旋转角度，选装轴，绕y轴顺时针旋转90°</code></pre><p>注意，OpenGL中，写在后面的变换会被先执行</p><pre><code class="lang-c++">glMatrixMode(GL_MODELVIEW)glLoadIdentity();glTranslatef(0.0, 0.0, -d);    //P1glRotatef(-90.0, 0.0, 1.0, 0.0); //P2</code></pre><p>上述代码表示先绕y轴顺时针旋转90°，再朝着z轴负方向平移距离d。$P_1P_2X = Y$</p><p><strong>2.LookAt</strong></p><p><code>gluLookAt(ex, ey, ez, cx, cy, cz, qx, qy, qz)</code>用于确定相机的位置和姿态。</p><p>分别表示<strong>相机位置、相机朝向、朝上向量(up vector)</strong></p><p><code>glLookAt</code>将世界坐标系转换为视角坐标系。</p><p>已知世界坐标系x-y-z，求t-u-v</p><pre><code class="lang-c++">v = (ex-cx,ey-cy,ez-cz)t = q×vu = v×t//最后需要Normalize t, u and v</code></pre><p>变换矩阵,先将相机移动到原点，然后将x-y-z变换为t-u-v</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/lookAt.png" srcset="/EruLv.github.io/img/loading.gif" alt="lookAt"></p><p><code>gluLookAt(ex, ey, ez, cx, cy, cz, qx, qy, qz)</code>等价于上述两个矩阵的乘机。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/eg1.png" srcset="/EruLv.github.io/img/loading.gif" alt="eg1"></p><p>model-view变换是最后执行的，所以从渲染的角度，代码应该写在最前面。</p><p><strong>3.正投影Orthogonal Projection</strong></p><pre><code class="lang-c++">void glOrtho(GLdouble left, GLdouble right,GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);</code></pre><p>设置一个矩形</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Ortho.png" srcset="/EruLv.github.io/img/loading.gif" alt="Ortho"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Ortho2.png" srcset="/EruLv.github.io/img/loading.gif" alt="Ortho2"></p><p><strong>4.透视投影Perspective Projection</strong></p><p><strong>Frustum视锥</strong></p><p><code>glFrustum(GLdouble left,GLdouble Right,GLdouble bottom,GLdouble top,GLdouble near,GLdouble far)</code></p><p>左右下上近远</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/frus.png" srcset="/EruLv.github.io/img/loading.gif" alt="frus"></p><p>不过不太常用，因为很难得到想要的视角，所以要用到另一个函数:</p><pre><code class="lang-c++">void gluPerspective (GLdouble fovy, GLdouble aspect,GLdouble zNear, GLdouble zFar)</code></pre><p>fovy:视角，度数,裁剪体的底面和顶面之间的夹角</p><p>asp:x和y的比例(w/h)</p><p>znear:相机到最近裁剪面的距离</p><p>zfar:相机到最远裁剪面的距离</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/per.png" srcset="/EruLv.github.io/img/loading.gif" alt="per"></p><p>透视投影的流水线:</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/proj.png" srcset="/EruLv.github.io/img/loading.gif" alt="proj"></p><h3 id="2-6-重点，两种投影-函数-的原理"><a href="#2-6-重点，两种投影-函数-的原理" class="headerlink" title="2.6 重点，两种投影(函数)的原理"></a>2.6 重点，两种投影(函数)的原理</h3><h3 id="2-7-Z-Buffer原理"><a href="#2-7-Z-Buffer原理" class="headerlink" title="2.7 Z-Buffer原理"></a>2.7 Z-Buffer原理</h3><p>z-buffer 作用:消除不可见面</p><h2 id="3-裁剪、光栅化和隐藏面消除"><a href="#3-裁剪、光栅化和隐藏面消除" class="headerlink" title="3.裁剪、光栅化和隐藏面消除"></a>3.裁剪、光栅化和隐藏面消除</h2><p>裁剪就是把位于视见体之外的对象删除，从而在最终显示的图像上这些对象是不可见的。</p><p>光栅化是从裁剪后的对象生成片元的过程。</p><p>隐藏面的消除就是确定可见对象的片元，即位于视见体之内且没有被阻挡的对象。</p><h3 id="3-1图形绘制的四个主要任务"><a href="#3-1图形绘制的四个主要任务" class="headerlink" title="3.1图形绘制的四个主要任务"></a>3.1图形绘制的四个主要任务</h3><p><strong>建模</strong>，寻找一组用来定义几何对象的顶点数据，除生成几何对象外，建模还能完成一切其他任务，如裁剪。</p><p><strong>几何处理</strong>， 几何处理包括四个处理过程:投影、图元装配、裁剪和明暗处理。</p><p><strong>光栅化</strong>，</p><p><strong>片元处理</strong></p><h3 id="3-2裁剪"><a href="#3-2裁剪" class="headerlink" title="3.2裁剪"></a>3.2裁剪</h3><p><strong>规范化设备坐标系</strong>: 经过投影变换后，所有图元潜在可见部分都位于一个变长为2中心位于原点的立方体的内部，这个坐标系称为规范化设备坐标系。</p><h4 id="3-2-1-线段的裁剪"><a href="#3-2-1-线段的裁剪" class="headerlink" title="3.2.1 线段的裁剪"></a>3.2.1 线段的裁剪</h4><p><strong>1.Cohen-Sutherland Algorithm</strong></p><p>思想:排除尽可能多的不需要计算交点的线段，使用浮点数减法和位操作代替大量高开销的浮点数乘法和除法。</p><p>步骤:</p><p>(1)首先把裁剪窗口的4条边延长到无限远，把整个二维空间分割成9个区域。</p><p>(2)给每个区域根据二进制编码。$y<em>{max}y</em>{min}x<em>{max}x</em>{min}$</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/code.png" srcset="/EruLv.github.io/img/loading.gif" alt="code"></p><p>(3)根据一条线段的两个端点的编码值进行讨论:</p><ul><li>case 1: o1 = o2 = 0,线段的两个端点都位于裁剪窗口内部，需要把该线段送入光栅化模块进行光栅化处理。</li><li>case 2: 一个为0，一个不为0，线段的一个端点位于裁剪窗口内，另一个位于裁剪窗口之外，必须进行裁剪处理，非0的端点编码说明了线段与裁剪窗口的哪条边或者哪两条边相交，必须计算一个或两个交点，需要注意的是，当计算完一个交点后，要计算该交点的编码，从而确定是否需要另一个求交运算。</li><li>case 3: $o_1 \&amp; O_2 ≠ 0$， 线段两个端点按位与操作，可以确定这两个端点是否位于裁剪窗口某条裁剪边的同一侧。如果满足，则可以丢弃该条线段。</li><li>case 4: $o_1 \&amp; o_2 = 0$,线段两个端点都为与裁剪窗口之外，但它们分别位于裁剪窗口的两条不同裁剪边的外侧，不能判断是否完全在窗口外，计算线段与裁剪窗口某边的交点，并根据新的交点编码重新进行上述判断。</li></ul><p>(4)根据上述判断该线段是接收还是裁剪，如果需要部分裁剪，找到位于窗口外的端点，然后寻找与线段相交的窗口边并且求出交点。</p><p>(5)把位于窗口外的顶点替换成交点从而实现裁剪。</p><p>推广到3维: 27个区域，6位编码。</p><p><strong>优点</strong>:</p><p>编码判断只需要进行布尔运算，大大减少了需要求交点的运算，当要处理的线段非常多而实际显示的线段非常少时，该算法很有效。可以有效地拓展到三维。</p><p><strong>缺点</strong>:</p><p>对某些线段，必须进行多次裁剪处理。在线段缩短过程中需要多次重复执行。</p><p><strong>2.Cyrus-Berk算法</strong></p><p><strong>3.Liang-Barsky裁剪算法</strong></p><p>将得不错:</p><p><a href="https://www.cnblogs.com/cnblog-wuran/p/9813841.html" target="_blank" rel="noopener">https://www.cnblogs.com/cnblog-wuran/p/9813841.html</a></p><p>优点:</p><p>不需要对线段进行多次裁剪处理，因此效率比Cohen-Sutherland算法效率高。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/cmp.png" srcset="/EruLv.github.io/img/loading.gif" alt="cmp"></p><h4 id="3-2-2-多边形裁剪"><a href="#3-2-2-多边形裁剪" class="headerlink" title="3.2.2 多边形裁剪"></a>3.2.2 多边形裁剪</h4><p>一般裁剪的对象时凸多边形，要么禁止使用凹多边形，要么将凹多边形剖分为一组凸多边形。</p><p><strong>1.Surtherland-Hodgeman算法</strong></p><p>思想:</p><p>分别考虑左上右下四条边所在的直线，依次裁剪掉位多边形于它们不可见一侧的部分。</p><p><a href="https://blog.csdn.net/damotiansheng/article/details/43274183" target="_blank" rel="noopener">https://blog.csdn.net/damotiansheng/article/details/43274183</a></p><h3 id="3-3-光栅化"><a href="#3-3-光栅化" class="headerlink" title="3.3 光栅化"></a>3.3 光栅化</h3><p>片元是潜在的像素，每个片元都具有一个颜色属性以及在屏幕坐标中的位置属性，还包括用于隐藏面消除的深度信息。</p><p>OpenGL中，像素的中心位于半整数值的位置。</p><h4 id="3-3-1线段光栅化"><a href="#3-3-1线段光栅化" class="headerlink" title="3.3.1线段光栅化"></a>3.3.1线段光栅化</h4><p><strong>1.DDA算法</strong></p><p>思想:</p><p>两个端点(x1,y1), (x2,y2)四舍五入后取整。</p><p>根据两个端点求斜率$\delta$。</p><p>$dy = \delta dx$</p><p>假设$0&lt;=\delta &lt;=1$</p><p>从x1开始$dx = 1$,$y = \delta$</p><p>如果斜率大于1，由于两个像素之间间隔很大，生成的线段可能连续性不好，所以可以交换x和y，再进行上面步骤。</p><p><strong>2.Bresenham 算法</strong></p><p>$d = (x_2 - x_1)(a - b)$</p><p>d&gt;0,选y，d&lt;0,选y+1.</p><pre><code>if d_k &gt; 0:    q = 2*m;else:    q = 2(1-m);</code></pre><script type="math/tex; mode=display">d_{k+1} = d_k - q</script><p>每个连续的像素计算只需要一个加法运算和一个符号判断，所以该算法效率非常高。</p><h4 id="3-3-2多边形光栅化"><a href="#3-3-2多边形光栅化" class="headerlink" title="3.3.2多边形光栅化"></a>3.3.2多边形光栅化</h4><p><strong>1.（xxx算法）</strong></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Raster.png" srcset="/EruLv.github.io/img/loading.gif" alt="Raster"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\edge.png" srcset="/EruLv.github.io/img/loading.gif" alt="edge"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\smarter.png" srcset="/EruLv.github.io/img/loading.gif" alt="smarter"></p><p><strong>2.Oldskool Rasterization</strong></p><p>思想:</p><p>使用线栅格化方法计算边界，然后从边界左边像素开始，从左向右填充内部像素，直到遇到右边边界。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\oldskool.png" srcset="/EruLv.github.io/img/loading.gif" alt="oldskool"></p><p><strong>3.Homogeneous Rasterization</strong></p><p>跟第一个算法有啥区别？</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\hr.png" srcset="/EruLv.github.io/img/loading.gif" alt="hr"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\hjrr.png" srcset="/EruLv.github.io/img/loading.gif" alt="hjrr"></p><h3 id="3-4隐藏面消除"><a href="#3-4隐藏面消除" class="headerlink" title="3.4隐藏面消除"></a>3.4隐藏面消除</h3><p><strong>Z-buffer算法</strong>Z</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\zbuffer.png" srcset="/EruLv.github.io/img/loading.gif" alt="zbuffer"></p><p>算法描述:</p><p>对多边形逐个进行光栅化处理，对某个多边形上的每个片元，进行光栅化处理，对片元内的每个像素，使用插值法计算深度值，再同一位置(x,y),如果z(x,y) &lt; zbuffer(x,y)，则更新zbuffer内的值。</p><p><strong>插值</strong></p><p>注意,在三维世界坐标系中的线性插值与投影后在屏幕坐标系中的线性插值不是等价的。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\interpolation.png" srcset="/EruLv.github.io/img/loading.gif" alt="interpolation"></p><p>插值方法:<strong>重力坐标插值(Barycentric Interpolation)</strong></p><p>算法流程:</p><p>计算重心$P = \alpha a + \beta b + \gamma c$,其中，a,b,c为点坐标，前面的为系数，我们求这三个系数，然后根据系数分配插值。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\b.png" srcset="/EruLv.github.io/img/loading.gif" alt="b"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\bary.png" srcset="/EruLv.github.io/img/loading.gif" alt="bary"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\zbf.png" srcset="/EruLv.github.io/img/loading.gif" alt="zbf"></p><h3 id="3-5走样Aliasing"><a href="#3-5走样Aliasing" class="headerlink" title="3.5走样Aliasing"></a>3.5走样Aliasing</h3><p><strong>走样</strong>:连续值转换为离散值导致图像出现视觉上可见的误差。</p><p><a href="https://blog.csdn.net/qq_38065509/article/details/105598277" target="_blank" rel="noopener">https://blog.csdn.net/qq_38065509/article/details/105598277</a></p><p><strong>1.超采样反走样(Super Sampling AA，SSAA)</strong></p><p>思想:</p><p>将每个像素点细分成多个采样点，使用更多的采样点采样，求每个像素点对应采样点的颜色的平均值，作为像素点的颜色。</p><p>先上采样，后降采样。</p><p><strong>2.多重采样MSAA</strong></p><p>Multi-sampling或者说Multi-sample Anti-Alias (简称MSAA)是一种抗锯齿的技术，它通过在一个像素上进行多次采样多次计算并最终汇总(Resolve to single-sample)，可使绘制的图像边缘更加平滑。通过这种方式绘制出来的图片质量更高，显得更真实。但同时，它对绘制的性能也会产生负面影响。所以，是否使用这项技术，需要开发者在图片质量(Quality)和性能(Performance)之间进行权衡。</p><p>MSAA其实是对SSAA的一个改进，显然SSAA的计算量是非常大的，每个像素点分成4个采样点，我们就要进行4次的shading来计算颜色，额外多了4倍的计算量。</p><p>MSAA的思路:</p><p>同样一个像素分为多个采样点，每个采样点判断是否被三角形覆盖，最后求颜色的平均值？（只计算被覆盖的采样点，最后用颜色乘以被覆盖采样点比例？）</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\muti.png" srcset="/EruLv.github.io/img/loading.gif" alt="muti"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\mass.png" srcset="/EruLv.github.io/img/loading.gif" alt="mass"></p>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础</title>
    <link href="/EruLv.github.io/2020/08/01/java%E5%9F%BA%E7%A1%80/"/>
    <url>/EruLv.github.io/2020/08/01/java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础笔记-《Java编程思想》阅读笔记"><a href="#Java基础笔记-《Java编程思想》阅读笔记" class="headerlink" title="Java基础笔记-《Java编程思想》阅读笔记"></a>Java基础笔记-《Java编程思想》阅读笔记</h1><h6 id="距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java"><a href="#距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java" class="headerlink" title="距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java."></a>距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java.</h6><h2 id="1-一切皆是对象"><a href="#1-一切皆是对象" class="headerlink" title="1.一切皆是对象"></a>1.一切皆是对象</h2><ol><li><p>java是一种更纯粹的面向对象的编程语言。</p></li><li><p>Java使用<code>new</code>关键字创建对象，对象的存储位置在<strong>堆</strong>内。对于一些基本类型，<code>new</code>对堆的操作开销较大，因此对于这些类型，java采取与c,c++相同的方法，即，不用<code>new</code>来创建这些变量，而直接创建一个并非是引用的变量，这个变量直接存储值，并置于堆栈中，音因此更加高效。</p></li><li><p>Java变量的<strong>基本类型</strong>:</p></li></ol><div class="table-container"><table><thead><tr><th>基本类型</th><th>大小</th><th>最小值</th><th>最大值</th><th>包装器类型</th></tr></thead><tbody><tr><td>boolean</td><td>—</td><td>—</td><td>—</td><td>Boolean</td></tr><tr><td>char</td><td>16 bits</td><td>Unicode 0</td><td>Unicode $2^{16} -1$</td><td>Character</td></tr><tr><td>byte</td><td>8 bits</td><td>-128</td><td>127</td><td>Byte</td></tr><tr><td>short</td><td>16 bits</td><td>-$2^{15}$</td><td>$2^{15}-1$</td><td>Short</td></tr><tr><td>int</td><td>32 bits</td><td>-$2^{31}$</td><td>$2^{31} - 1$</td><td>Integer</td></tr><tr><td>long</td><td>64 bits</td><td>-$2^{63}$</td><td>$2^{63} - 1$</td><td>Long</td></tr><tr><td>float</td><td>32 bits</td><td>IEEE 754</td><td>IEEE 754</td><td>Float</td></tr><tr><td>double</td><td>64 bits</td><td>IEEE 754</td><td>IEEE 754</td><td>Double</td></tr><tr><td>void</td><td>—</td><td>—</td><td>—</td><td>Void</td></tr></tbody></table></div><p>所有数值类型变量均有符号。</p><pre><code class="lang-java">//创建一个基本类型变量int a = 13;//使用包装器创建一个非基本对象Integer a = new Integer(13);//java自动将基本类型转换为包装器类型Integer a = 13;</code></pre><p>4.高精度</p><ul><li><p>高精度整数:<code>BigInteger</code>，支持任何精度的整数。</p></li><li><p>高精度浮点数:<code>BigDecimal</code>，支持任何精度的浮点数。</p></li></ul><p>只能通过<code>new</code>创建.</p><p>对象的作用域</p><p>由<code>new</code>创建的对象，只要你需要，就会一直保存下去，即超出作用域是不会被立即销毁。</p><p>6.类的要素:</p><ul><li><p>字段</p></li><li><p>方法</p></li></ul><p>7.当java的变量作为类的成员时，若该变量时基本类型并且未被赋值，则java会给它一个默认值(类似c++)。</p><p>8.导入类</p><pre><code class="lang-java">import java.utils.ArrayList;import java.utils.*;    //导入utils下所有类。</code></pre><p>9.static</p><p>当一个事物声明是static时，意味着这个域或方法不会与包含它的那个对象关联在一起。即无论创建多少个包含它的对象，系统只给它分配一个存储空间。</p><pre><code class="lang-java">class test{    static int a = 1;}class Main {    public static void main(String args[]){        test t = new test();        t.a ++;        test tt = new test();        tt.a ++;        test.a ++;    //可以直接通过类名调用静态方法        System.out.println(t.a);        System.out.println(tt.a);    }}结果:44</code></pre><p>同理，静态方法也可通过类名直接调用或通过对象调用。</p><p>10.</p><p>java.lang是默认导入到每个Java文件中的，不需要额外import.</p><p>11.编译</p><p>生成.class类</p><pre><code>javac xxx.java</code></pre><p>假设生成了A.class和B.class, 现在运行代码:</p><pre><code>java A</code></pre><p>12.注释</p><pre><code class="lang-java">class Main {    /** 类的作用是啥巴拉巴拉     * @author 作者名称     * @param args 参数解释     * @return xxx     * @version 1.0     */    public static void main(String args[]){        System.getProperties().list(System.out);    }}</code></pre><h2 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2.操作符"></a>2.操作符</h2><p>1.赋值</p><p><strong>基本类型的赋值</strong>: </p><p>直接把内容赋值给左边，如a = b, 当改变b的值时，a的内容不变。</p><p><strong>对象赋值</strong>:</p><p>把指向对象的引用复制给左边，如c = d,那么c和d都指向同一存储位置。</p><p>2.random</p><pre><code class="lang-java">import java.util.*;class Main {    public static void main(String args[]){        Random random = new Random(66);    //随机数对象，种子:66        int a = random.nextInt(100) + 1;    //设置Int范围1-100        float b = random.nextFloat()*10;    //设置float范围0-10        System.out.println(a);        System.out.println(b);    }}</code></pre><p>3.科学计数法</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        float a = 1e32f;        System.out.println(a);    }}</code></pre><p>4.按位操作</p><p><code>&amp;</code>:与</p><p><code>|</code>:或</p><p><code>~</code>:非</p><p><code>^</code>:异或</p><p><code>&lt;&lt;</code>:左移</p><p><code>&gt;&gt;</code>:右移</p><p>5.if-else操作</p><pre><code class="lang-java">boolean-exp ? a:b;</code></pre><p>6.类型转换</p><p><strong>窄化转换</strong>可能面临信息丢失的危险，所以必须显示转换。</p><p><strong>拓展转换</strong>不需要显示转换。</p><p>例如: long转int会报错，必须显示转换。</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        long a = 1000000;        int b = a;    }}</code></pre><p>7.截尾和舍入</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        double a = 9.7;        int b = (int)a;    //截尾        int c = (int)Math.round(a);    //四舍五入        System.out.println(b);        System.out.println(c);    }}</code></pre><p>8.其他</p><ul><li>比int小的类型(char,byte,short)在运算时会自动转换为int类型。</li><li>通常，表达式中最大数据类型决定了表达式最终结果的数据类型。</li></ul><h2 id="3-执行控制流程"><a href="#3-执行控制流程" class="headerlink" title="3.执行控制流程"></a>3.执行控制流程</h2><p>1.if else,while, for, switch</p><p>pass</p><p>2.Foreach</p><p>(c++11中也支持该语句)</p><p>Foreach可用于任何数组和Iterable对象。</p><pre><code class="lang-java">        Random r = new Random(6);        int a[] = new int[10];        for(int i = 0;i &lt; a.length; i++){            a[i] = r.nextInt(100);        }        for(int x:a){            System.out.println(x);        }</code></pre><pre><code class="lang-java">    public static void main(String args[]){        for(int x: range(5,10)){    //rang前提: import static net.mindview.util.Range.*;            print(x);        }    }</code></pre><p>3.goto</p><p>goto是java的一个保留字，但是java并不能使用goto语句。</p><p>4.标签</p><p><code>break label</code>: 跳出标签所指循环。</p><p><code>continue label</code>:跳过标签所指循环的这一步。</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        int i = 0;        outer:        for(;;){            inner:            for(;i &lt; 10; i++){                print(&quot;i = &quot;+i);                if(i == 5) break outer;    //直接跳出外部循环            }        }    }}</code></pre><h2 id="4-初始化与请理"><a href="#4-初始化与请理" class="headerlink" title="4.初始化与请理"></a>4.初始化与请理</h2><p>1.构造器</p><p>与类名相同的函数。</p><p>2.重载</p><p>方法名相同，形参不同。</p><p><strong>函数名和形参相同，返回值不同，不是重载，编译器会报错。</strong></p><p>3.this</p><p>在类内使用，表示该类的引用。可用于区分形参和类内参数。</p><p>一般的方法，如:</p><pre><code class="lang-java">class Person {    public void eat(Apple apple) {        print(&quot;Yummy&quot;);    }}//实际上隐含的代码是(实际不能把this写上，否则编译器报错):class Person {    public void eat(this, Apple apple) {        print(&quot;Yummy&quot;);    }}</code></pre><p>4.再看static</p><p>static方法是没有<code>this</code>的方法，在所以在static方法内部不能直接调用非静态方法，单反过来是可以的。</p><p>static很像全局方法，给java提供了一种访问全局变量和方法的思路。</p><p>5.finalize</p><p>类似于c++中的析构函数。但不建议使用。java9以上的版本该方法被<strong>Deprecated</strong> 并且<strong>will be removed</strong>.</p><p>6.构造器初始化</p><p>变量一定会在构造函数之前初始化(即使变量可能定义在构造函数后面)，变量之间的初始化顺序由定义的顺序决定。</p><p>7.静态数据初始化</p><p><code>static</code> 不能作用与局部数据，静态数据也会自动初始化(基本类型，对象类型)。</p><pre><code class="lang-java">import java.util.*;import static net.mindview.util.Print.*;import static net.mindview.util.Range.*;class Bowl{    Bowl(int marker){        print(&quot;Bowl(&quot;+marker+&quot;)&quot;);    }    void f1(int marker){        print(&quot;f1(&quot;+marker+&quot;)&quot;);    }}class Table{    static Bowl bowl1 = new Bowl(1);    Table(){        print(&quot;Table()&quot;);        bowl2.f1(1);    }    void f2(int marker){        print(&quot;f2(&quot;+marker+&quot;)&quot;);    }    static Bowl bowl2 = new Bowl(2);}class Cupboard{    Bowl bowl3 = new Bowl(3);    static Bowl bowl4 = new Bowl(4);    Cupboard(){        print(&quot;Cupboard&quot;);        bowl4.f1(2);    }    void f3(int marker){        print(&quot;f3(&quot;+marker+&quot;)&quot;);    }    static Bowl bowl5 = new Bowl(5);}class Main {    public static void main(String args[]){        print(&quot;create new Cupboard() in main !&quot;);        new Cupboard();        print(&quot;create new Cupboard() in main !&quot;);        new Cupboard();        table.f2(1);        cupboard.f3(1);    }    static Table table = new Table();    static Cupboard cupboard = new Cupboard();}</code></pre><pre><code>输出:Bowl(1)Bowl(2)Table()f1(1)Bowl(4)Bowl(5)Bowl(3)Cupboardf1(2)create new Cupboard() in main !Bowl(3)Cupboardf1(2)create new Cupboard() in main !Bowl(3)Cupboardf1(2)f2(1)f3(1)</code></pre><p><strong>总结初始化顺序:</strong></p><p>静态对象(只会被初始化一次)-&gt;非静态对象-&gt;构造器。</p><p>8.静态子句</p><p>只会被执行一次的域</p><pre><code class="lang-java">static{    int i = 1;    xxxx}</code></pre><p>9.数组初始化</p><pre><code>int a[];int[] a;int[] a = {1,2,3,4};int a[] = new int[10];</code></pre><pre><code class="lang-java">a2 = a1;//把a1的引用赋值给a2;</code></pre><pre><code class="lang-java">Arrays.toString(a); //把数组转化为字符串,需要引用java.utils.*标准库</code></pre><p>创建对象数组时，需要分两步:</p><p>创建应用数组，给每个引用赋初值。</p><pre><code class="lang-java">A[] a = new A[10];for(int i = 0; i  &lt; a.length; i++){    a = new A();}</code></pre><p>或者直接初始化</p><pre><code class="lang-java">A[] a = {new A(1),new A(2)};A[] a = new A[]{new A(1), new A(2)};</code></pre><p>10.可变参数列表</p><pre><code class="lang-java">public class VarArgs{    static void printArray(Object... args){    //将你的输入自动封装成数组，疮长度不固定，可以是0        for(Object obj: args){            System.out.print(obj + &quot; &quot;);        }        print();    }}class DynamicArray{    public static void main(String[] args){        VarArgs.printArray(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);        VarArgs.printArray(new Object[]{                new Integer(1),                new Integer(2),                new Integer(3)        });    }}</code></pre><p>11.枚举类型</p><pre><code class="lang-java">enum E{    A,B,C,D}class Main{    public static void main(String[] args){        for(E e: E.values()){            print(e);        }        print(E.A);            }}</code></pre><p>enum类有toString方法，可以在switch中使用。</p><h2 id="5-访问权限控制"><a href="#5-访问权限控制" class="headerlink" title="5.访问权限控制"></a>5.访问权限控制</h2><p>1.包Package</p><p> 每个<code>.java</code>文件都只能有一个public类，该类的名称必须与文件名相同，如果改文件还有额外的类的话，包之外的世界(其他文件)是无法看见这个类的。即每个文件都有一个<code>public</code>类，以及许多非<code>public</code>类。</p><p>每个文件都有一个构件，如果希望这些构件从属于同一个群组，就可以使用关键字<code>package</code>,必须放在程序最前面。</p><p>新建package access</p><pre><code class="lang-java">package access;public class A {    public A(){        System.out.println(&quot;access A !&quot;);    }}class AA{    public AA(){        System.out.println(&quot;access AA !&quot;);    }}</code></pre><p>在<code>access</code>包外调用包内的内容。</p><pre><code class="lang-java">import access.*;public class B {    public static void main(String[] args){//        AA aa = new AA();        A a = new A();    }}</code></pre><p>java解释器寻找类库的过程：</p><p>比如导入包</p><pre><code class="lang-java">import net.mindview.test.*</code></pre><p>当编译器遇到<code>test</code>的<code>import</code>语句时，就开始在<code>CLASSPATH</code>所指定的目录中查找，查找到子目录<code>net/mindview/test</code>，然后从已编译的文件中找出名称相符者。</p><p>如果导入的两个类库中存在冲突类，如果你恰好使用到了冲突的类，编译器会报错。</p><p><strong>自己一个print包</strong></p><pre><code class="lang-java">package access;public class Print {    public static void print(Object obj){        System.out.println(obj);    }    public static void print(){        System.out.println();    }}</code></pre><p>调用:</p><pre><code class="lang-java">import static access.Print.*;public class B {    public static void main(String[] args){        print();    }}</code></pre><p><code>import static 包名.类名.*;</code></p><p>意思是导入这个类里的静态成员（静态方法、静态变量）,可以直接使用静态方法而不用通过<code>类名.方法名()</code>,可以导入的静态成员包括静态对象引用、静态常量和静态方法。</p><p>2.<strong>访问权限修饰词</strong></p><p>2.1包访问权限(默认权限)</p><p>没有访问权限修饰词，则默认为包访问权限(<code>friendly</code>),则当前包中的其他类堆那个成员对具有访问权限。对于包外的所有类都是不可见的。</p><p>如果你没有设置当前文件所属的包，即没有定义<code>package xxxx</code>,则位于同一目录的这样文件被java看作位于隶属于该目录的默认包中，于是对于同级目录下的没有设置包的文件来说，它们有<strong>包访问权限</strong>。</p><p>2.2 public</p><p>在任何位置都可以访问。</p><p>2.3 private</p><p>除了包含该成员的类之外，其他任何类都无法访问这个成员。</p><p>2.4 protected</p><p>继承的子类可以访问基类中的<code>protected</code>的成员（当然也可以访问<code>public</code>的）。</p><p><code>protected</code>也提供包继承，即同一个包内的类也可以访问含有<code>protected</code>声明的成员。</p><p>3.注意，类(外部类)不可以时<code>protected</code>或者<code>privated</code>.可以把构造器设置为<code>private</code>,阻止其他类创建该类的实例。</p><h2 id="6-复用类"><a href="#6-复用类" class="headerlink" title="6.复用类"></a>6.复用类</h2><p>1.复用类的两种实现方法</p><p>组合:在新类中<code>new</code>一个现有类。</p><p>继承:在基类的基础上添加代码。</p><p>2.toString方法</p><p>在每一个非基本类型的对象都有一个<code>toString()</code>方法，当编译器需要一个String而你只有一个对象时，该方法会被调用。可以自己定义<code>toString()</code>方法:</p><pre><code class="lang-java">public String toString(){    return &quot;This is toString&quot;;}</code></pre><pre><code class="lang-java">import static access.Print.*;public class B {    public static void main(String[] args){        Print p = new Print();        System.out.println(p);    }}</code></pre><p>3.继承</p><p>java默认从<code>Object</code>类继承。</p><p>继承关键字:<code>extends</code>.</p><pre><code class="lang-java">public A ectends B{    //balabala}</code></pre><p>A类从B类继承。</p><pre><code class="lang-java">class C{    C(){        System.out.println(&quot;initialize C!&quot;);    }}class B extends C{    B(){        System.out.println(&quot;initialize B!&quot;);    }}public class A extends B{    A(){        System.out.println(&quot;initialize A!&quot;);    }    public static void main(String[] args){        A a = new A();    }}</code></pre><p><strong>java会首先初始化基类。</strong></p><p>如果没有默认的基类构造器，或者基类构造器带参数，则必须使用<code>super</code>，显示地调用基类构造器。并且<code>super</code>要位于最前面。</p><p>4.代理</p><p>继承和组合的一个折中，不直接继承，而是创建基类的一个实例，根据定义当前类需要的方法。</p><p>5.名称屏蔽</p><p>如果基类中有一个方法，在子类中被重载了，那么基类中的这个方法依然是可用的。</p><p>使用<code>@override</code>会检查你写的下面的代码是否覆盖掉基类代码，如果只是重载而不是覆盖，则编译器会报错。</p><pre><code class="lang-java">class B {    B(int i) {        System.out.println(&quot;initialize B!&quot;);    }    void f(int x){        System.out.println(&quot;f(&quot;+x+&quot;)&quot;);    }}public class A extends B{    A(){        super(1);        System.out.println(&quot;initialize A!&quot;);    }    void f(String s){        System.out.println(&quot;f(&quot;+s+&quot;)&quot;);    }    public static void main(String[] args){        A a = new A();        a.f(&quot;你好&quot;);        a.f(1);    }}/* outputs:initialize B!initialize A!f(你好)f(1)*/</code></pre><pre><code class="lang-java">public class A extends B{    A(){        super(1);        System.out.println(&quot;initialize A!&quot;);    }    //限定只能覆盖,重写会报错    @Override    void f(int x){        System.out.println(&quot;ff(&quot;+x+&quot;)&quot;);    }    public static void main(String[] args){        A a = new A();        a.f(1);    }}</code></pre><p>6.组合和继承的选择</p><p>组合是使用现有类的一些功能，来实现我们需要的功能，比如car类可能需要wheel类，Engine类等。</p><p>继承一般是把一个通用类的功能特殊化，具体化。</p><p>7.向上转型</p><p>将导出类(子类)转换为基类的动作（从一个特殊类转换为通用类）。如:</p><pre><code class="lang-java">Instrument x = new Flute();</code></pre><p>8.final关键字</p><p><strong>1.数据</strong></p><p><code>final</code>代表常量，如果修饰基本类型，则表示该数据不能修改，如果修饰对象，表示改引用不能指向其他对象(但对象可以改变)。</p><p><code>final static</code>命名一般是大写字幕+下划线。</p><p><code>final</code>必须在定义时初始化。当然，如果作为类成员变量，可以先不初始化，但一定要在构造函数里初始化。</p><pre><code class="lang-java">class Test{    private final int j = 1;    private final int i;    Test(){        i = 1;    }}</code></pre><p><strong>2.方法</strong></p><p><code>final</code>修饰方法作用和<code>private</code>关键字类似，可以防止子类覆盖。</p><pre><code class="lang-java">class WithFinals {    // Identical to &quot;private&quot; alone:    private final void f() { print(&quot;WithFinals.f()&quot;); }    // Also automatically &quot;final&quot;:    public final void g() { print(&quot;WithFinals.g()&quot;); }}class OverridingPrivate extends WithFinals {    private final void f() {        print(&quot;OverridingPrivate.f()&quot;);    }    public void g() {   //会报错        print(&quot;OverridingPrivate.g()&quot;);    }}</code></pre><p><strong>3.类</strong></p><p>在类前加<code>final</code>关键字表示改类不能被继承。final类不会被继承，因此它的所有方法都隐式指定为final的。</p><h2 id="7-多态"><a href="#7-多态" class="headerlink" title="7.多态"></a>7.<strong>多态</strong></h2><p>在<strong>oop</strong>中，多态时继数据抽象和继承之后的第三种基本特征。多态的作用是消除类型之间的耦合关系</p><p>1.向上转型</p><p>对象既可作为它自己本身的类型使用，也可作为它的基类型使用。</p><pre><code class="lang-java">class Instrument {  public void play(Note n) {    print(&quot;Instrument.play()&quot;);  }}public class Wind extends Instrument {  // Redefine interface method:  public void play(Note n) {    System.out.println(&quot;Wind.play() &quot; + n);  }} public class Music {  public static void tune(Instrument i) {    // ...    i.play(Note.MIDDLE_C);  }  public static void main(String[] args) {    Wind flute = new Wind();    tune(flute); // Upcasting  }} /* Output:Wind.play() MIDDLE_C*///:~</code></pre><p>接收Instrument类型的对象，调用的却是Wind的方法。</p><p>为什么会这样？因为java中除了<code>final</code>和<code>static</code>均采用动态绑定，在运行时判断对象类型。</p><p>你以为你把它转到基类了，实际上如果可以，它还是会调用子类的方法。</p><pre><code class="lang-java">class A{    public void play(){        System.out.println(&quot;A.play()&quot;);    }}class B extends A{    public void play(){        System.out.println(&quot;B.play()&quot;);    }}public class test {    public static void main(String[] args){        A a = new B();        a.play();    }}B/* Output:B.play() *///:~</code></pre><p>2.“覆盖”私有方法</p><pre><code class="lang-java">public class PrivateOverride {  private void f() { print(&quot;private f()&quot;); }      public static void main(String[] args) {    PrivateOverride po = new Derived();    po.f();  }}class Derived extends PrivateOverride {  public void f() { print(&quot;public f()&quot;); }    } /* Output:private f()*///:~</code></pre><p>上面的基类中f()是私有的，与<code>final</code>等价，下面继承的方法看作是个全新的方法，基类中的方法f()在导出类中不可见，不能被重载，<strong>只有非<code>private</code>方法才可以被覆盖</strong>。</p><p>满足多态的条件:</p><ul><li>基类和子类中都有非<code>private</code>方法f().</li><li>A a = new B()形式，其中B继承A。</li></ul><p>最终a.f()调用B的f()。</p><p><strong>另外，向上转型后不能访问子类中存在但基类中不存在的方法。</strong></p><p>3.“域”(类变量)访问</p><p>如果你直接访问某个域，这个访问就会在编译期间进行解析，不具有多态性。</p><pre><code class="lang-java">class Super {  public int field = 0;  public int getField() { return field; }}class Sub extends Super {  public int field = 1;  public int getField() { return field; }  public int getSuperField() { return super.field; }}public class FieldAccess {  public static void main(String[] args) {    Super sup = new Sub(); // Upcast    System.out.println(&quot;sup.field = &quot; + sup.field +      &quot;, sup.getField() = &quot; + sup.getField());    Sub sub = new Sub();    System.out.println(&quot;sub.field = &quot; +      sub.field + &quot;, sub.getField() = &quot; +      sub.getField() +      &quot;, sub.getSuperField() = &quot; +      sub.getSuperField());  }}/* Output:sup.field = 0, sup.getField() = 1sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0*///:~</code></pre><p>向上转型后，访问sup的域，因为sup是Super类，所以访问的是Super的类变量。</p><p>如果某个方法是静态的，它的行为也不具有多态性。因为静态方法与类关联而不是单个对象。</p><pre><code class="lang-java">class StaticSuper {  public static String staticGet() {    return &quot;Base staticGet()&quot;;  }  public String dynamicGet() {    return &quot;Base dynamicGet()&quot;;  }}class StaticSub extends StaticSuper {  public static String staticGet() {    return &quot;Derived staticGet()&quot;;  }  public String dynamicGet() {    return &quot;Derived dynamicGet()&quot;;  }}public class StaticPolymorphism {  public static void main(String[] args) {    StaticSuper sup = new StaticSub(); // Upcast    System.out.println(sup.staticGet());    System.out.println(sup.dynamicGet());  }} /* Output:Base staticGet()Derived dynamicGet()*///:~</code></pre><p>4.构造器和多态</p><p>构造器是<code>static</code>的，因此不具有多态性。</p><p>构造器调用顺序:</p><p><strong>从上往下初始化基类构造器-&gt;初始化当前类的变量-&gt;初始化当前类的构造器。</strong></p><p>5.清理</p><p>如果需要显示地写辣鸡回收方法，子类覆盖父类的请理方法，子类的清理方法中一定要添加<code>super().请理()</code>方法，否则父类的清理方法一直不会执行。</p><p>6.构造器中调用被覆盖的类</p><pre><code class="lang-java">class Glyph {  void draw() { print(&quot;Glyph.draw()&quot;); }  Glyph() {    print(&quot;Glyph() before draw()&quot;);    draw();    print(&quot;Glyph() after draw()&quot;);  }}  class RoundGlyph extends Glyph {  private int radius = 1;  RoundGlyph(int r) {    radius = r;    print(&quot;RoundGlyph.RoundGlyph(), radius = &quot; + radius);  }  void draw() {    print(&quot;RoundGlyph.draw(), radius = &quot; + radius);  }}  public class PolyConstructors {  public static void main(String[] args) {    new RoundGlyph(5);  }} /* Output:Glyph() before draw()RoundGlyph.draw(), radius = 0Glyph() after draw()RoundGlyph.RoundGlyph(), radius = 5*///:~</code></pre><p>可以看到基类的draw()方法被重写了，在基类构造器中调用draw()方法依旧调用的是子类的draw()方法，但由于子类还未初始化，所以radius为0.（之前编译器会给所有对象分配好空间，然后初始化成二进制的0.</p><p>7.协变返回类型</p><pre><code class="lang-java">class Grain {  public String toString() { return &quot;Grain&quot;; }}class Wheat extends Grain {  public String toString() { return &quot;Wheat&quot;; }}class Mill {  Grain process() { return new Grain(); }}class WheatMill extends Mill {  Wheat process() { return new Wheat(); }}public class CovariantReturn {  public static void main(String[] args) {    Mill m = new Mill();    Grain g = m.process();    System.out.println(g);    m = new WheatMill();    g = m.process();    System.out.println(g);  }} /* Output:GrainWheat*///:~</code></pre><p>8.向下转型</p><pre><code class="lang-java">class Useful {  public void f() {}  public void g() {}}class MoreUseful extends Useful {  public void f() {}  public void g() {}  public void u() {}  public void v() {}  public void w() {}}  public class RTTI {  public static void main(String[] args) {    Useful[] x = {      new Useful(),      new MoreUseful()    };    x[0].f();    x[1].g();    // Compile time: method not found in Useful:    x[1].u();    //编译报错    ((MoreUseful)x[1]).u(); //通过    ((MoreUseful)x[0]).u(); // 抛出异常  }} ///:~</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/EruLv.github.io/2020/07/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/EruLv.github.io/2020/07/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划题目总结"><a href="#动态规划题目总结" class="headerlink" title="动态规划题目总结"></a>动态规划题目总结</h1><h2 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.背包问题"></a>1.背包问题</h2><h3 id="1-1-01背包问题"><a href="#1-1-01背包问题" class="headerlink" title="1.1 01背包问题"></a>1.1 01背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>每件物品只能使用一次</strong>。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数$v_i, w_i$，用空格隔开，分别表示第i件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例：</strong></p><pre><code>8</code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h4><p>$f[i][j]$表示状态，从前i件物品中选择不超过质量j的最大总价值。</p><p>划分为两个集合:</p><p>不选择第i件物品,则$f[i][j] = f[i-1][j]$</p><p>选择第i件物品，考虑如何使用前面的状态表示，$f[i][j] = f[i - 1][j - v[i]] + w[i]$,选择第i件物品质量不超过j，需要从前i-1件物品中的质量不超过$j - v[i]$的物品中获得。前提是$j &gt;= v[i]$</p><p>上面两者求最大值即可。</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N][N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i]&gt;&gt; w[i];    }    //f[i][j] = max(f[i-1][j], f[i - 1][j - v[i]] + w[i])    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;=m ; j++){            f[i][j] = f[i-1][j];            if(j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j-v[i]] + w[i]);         }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>可以使用一维数组代替二维数组，因为计算$f[i][j]$是只用到了$f[i-1]$的状态，所以i这一维可以压缩到一个数组中。</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i]&gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = m; j &gt;= v[i] ; j--){            //注意要从后往前遍历，因为我们要确保公式右边都是没有更新过的，j一定在j-v[i]前更新            f[j] = max(f[j], f[j-v[i]] + w[i]);         }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="1-2-完全背包问题"><a href="#1-2-完全背包问题" class="headerlink" title="1.2 完全背包问题"></a>1.2 完全背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>每件物品都有无限件可用</strong>。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数$v_i, w_i$，用空格隔开，分别表示第i件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例：</strong></p><pre><code>10</code></pre><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析:"></a>分析:</h4><p>跟01背包相似，不过集合划分时，把情况划分为第i件物品选0,1,2,…,k件。</p><p>$f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i], f[i-1][j-2<em>v[i]] + 2</em>w[i],…,f[i-1][j-k<em>v[i]] + k</em>w[i])$</p><p>所以有:</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int f[N][N];int n, m;int v[N], w[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j&lt;=m; j++){            for(int k = 0; k*v[i] &lt;= j; k++)            f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + K*w[i]);        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>上述时间复杂读为$O(nm^2)$,可以优化。</p><p>考虑:</p><p>$f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i], f[i-1][j-2<em>v[i]] + 2</em>w[i],…,f[i-1][j-k<em>v[i]] + k</em>w[i])$</p><p>$f[i][j-v[i]] + w[i] = max(f[i-1][j - v[i]] + w[i], f[i-1][j-2 <em> v[i]] + 2</em>w[i], f[i-1][j-3<em>v[i]] + 3</em>w[i],…)$</p><p>所以</p><p>$f[i][j] = max(f[i-1][j], f[i][j-v[i]] + w[i])$</p><p>注意与01背包的区别，区别在它是从i转移来的而不是i - 1</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int f[N][N];int n, m;int v[N], w[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j&lt;=m; j++){            f[i][j] = f[i-1][j];            if(j &gt;= v[i])                f[i][j] = max(f[i-1][j], f[i][j - v[i]] + w[i]);        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>一维的形式</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int f[N];int n, m;int v[N], w[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = v[i]; j&lt;=m; j++){            //注意j是从小到大遍历，因为左边是从已经更新过的i转移来的            f[j] = max(f[j], f[j - v[i]] + w[i]);        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="1-3-多重背包问题"><a href="#1-3-多重背包问题" class="headerlink" title="1.3 多重背包问题"></a>1.3 多重背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>第i种物品最多有$s_i$件</strong>。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数$v_i, w_i$，用空格隔开，分别表示第i件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N≤1000$<br>$0&lt;V≤2000$<br>$0&lt;vi,wi,si≤2000$</p><p><strong>输入样例</strong></p><pre><code>4 51 2 32 4 13 4 34 5 2</code></pre><p><strong>输出样例：</strong></p><pre><code>10</code></pre><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析:"></a>分析:</h4><p>思路同完全背包，把第i件物品划分为选择0,1,2,…s[i]件</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int v[N],w[N],s[N];int n, m;int f[N][N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;=n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;= m; j++){            for(int k = 0; k &lt;= s[i] &amp;&amp; k*v[i] &lt;= j; k++){                f[i][j] = max(f[i][j], f[i-1][j - k*v[i]] + k*w[i]);            }        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>根据完全背包问题做优化:</p><pre><code>f[i][j] = max(f[i-1][j], f[i-1][j - v[i]] + w[i],...,f[i-1][j - s*v[i]] + s* w[i])f[i][j-v[i]] = max(      f[i-1][j - v[i]],      ... ,f[i-1][j - s*v[i]] + (s-1)*w[i],  f[i-1][j - (s+1)*v[i]])</code></pre><p>发现后面多了一项，不能根据后面的最大值，求前面的最大值。</p><p>所以使用二进制优化。</p><p><strong>思想</strong>:</p><p>假设第i组的数量为s，则可以将s分解为$logs$组，每组的数量为$1,2,4…2^k,c$,其中$1+2+…+2^k+c = s$,可以证明0-s种的任意一个整数可以用上面的二进制组合表示。</p><p>所以将每一种物品分成数量为$1,2,4…2^k,c$的组，最后转换为01背包问题。</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;// N = log(s) * Nconst int N = 15000, M = 2010;int v[N], w[N];int n, m;int f[M];int main(){    cin &gt;&gt; n &gt;&gt; m;    int cnt = 0;    //新的集合的编号    for(int i = 0; i &lt; n; i++){        int a, b, s;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;        //分组        int k = 1;  //该组的数量        while(k &lt;= s){            cnt ++;            v[cnt] = a * k;            w[cnt] = b * k;            s -= k;            k *= 2;        }        //剩下的        if(s &gt; 0){            cnt ++ ;            v[cnt] = a * s;            w[cnt] = b * s;        }    }    n = cnt;    //01背包问题    for(int i = 1; i &lt;= n; i++){        for(int j = m; j &gt;= v[i]; j--){            f[j] = max(f[j], f[j - v[i]] + w[i]);        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;}</code></pre><h3 id="1-4分组背包问题"><a href="#1-4分组背包问题" class="headerlink" title="1.4分组背包问题"></a>1.4分组背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>每组物品有若干个，同一组内的物品最多只能选一个</strong>。每件物品的体积是 $v<em>{ij}$，价值是 $w</em>{ij}$，其中 i是组号，j是组内编号。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$组数据：</p><ul><li>每组数据第一行有一个整数 $S_i$，表示第i 个物品组的物品数量；</li><li>每组数据接下来有$S<em>i$行，每行有两个整数 $v</em>{ij},w_{ij}$，用空格隔开，分别表示第 i个物品组的第 jj 个物品的体积和价值；</li></ul><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N,V≤100$<br>$0&lt;v<em>{ij},w</em>{ij}≤100$</p><p>$0&lt;S_i&lt;=100$</p><p><strong>输入样例</strong></p><pre><code>3 521 22 413 414 5</code></pre><p><strong>输出样例：</strong></p><pre><code>8</code></pre><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析:"></a>分析:</h4><p>集合的表示:前i组中总体积不超过j的最大价值。</p><p>集合划分:第i组，选择0个，第一个，第二个，…,第$s[i]$个</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int v[N][N], w[N][N], s[N];int f[N][N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        int cnt;        cin &gt;&gt; cnt;        s[i] = cnt;        for(int j = 1; j &lt;= cnt; j++){            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];        }    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;= m; j++){            for(int k = 0; k &lt;= s[i]; k++){                if(j - v[i][k] &gt;=0 )                    f[i][j] = max(f[i][j], f[i-1][j-v[i][k]] + w[i][k]);            }        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int v[N][N], w[N][N], s[N];int f[N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; s[i];        for(int j = 1; j &lt;= s[i]; j++){            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];        }    }    for(int i = 1; i &lt;= n; i++){        for(int j = m; j &gt;= 0; j--){            for(int k = 0; k &lt;= s[i]; k++){                if(j - v[i][k] &gt;=0 )                    f[j] = max(f[j], f[j-v[i][k]] + w[i][k]);            }        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习复习</title>
    <link href="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/"/>
    <url>/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="1-判别模型vs生成模型"><a href="#1-判别模型vs生成模型" class="headerlink" title="1.判别模型vs生成模型"></a>1.判别模型vs生成模型</h2><p>生成模型是由数据先学习联合概率分布$P(X,Y)$，然后求出条件概率分布作为预测模型。如朴素贝叶斯和隐马尔可夫模型。</p><p>判别方法是直接根据数据学习决策函数$f(X)$或者条件概率分布$P(Y|X)$作为预测的模型(学习一个决策边界)。典型的模型由SVM，k近邻，感知机，决策树、最大熵模型、条件随机场等。</p><p>判别: discriminative</p><p>生成: generative</p><h2 id="2-评测指标"><a href="#2-评测指标" class="headerlink" title="2.评测指标"></a>2.评测指标</h2><h3 id="2-1-准确率，精确率，召回率，F1值"><a href="#2-1-准确率，精确率，召回率，F1值" class="headerlink" title="2.1 准确率，精确率，召回率，F1值"></a>2.1 准确率，精确率，召回率，F1值</h3><ul><li>tp: 预测为正类，实际为正类</li><li>fp:预测为正类，实际为负类</li><li>tn:预测为负类，实际为负类</li><li>fn:预测为负类，实际为正类</li></ul><p>准确率</p><script type="math/tex; mode=display">acc = \frac{tp + tn}{tp + tn + fp + fn}</script><p>精确率</p><script type="math/tex; mode=display">p = \frac{tp}{tp + fp}</script><p>召回率</p><script type="math/tex; mode=display">r = \frac{tp}{tp + fn}</script><p>F1值:精确率和召回率的调和平均</p><script type="math/tex; mode=display">F1 = \frac{2*p*r}{p+r}</script><h2 id="3-朴素贝叶斯"><a href="#3-朴素贝叶斯" class="headerlink" title="3. 朴素贝叶斯"></a>3. 朴素贝叶斯</h2><p>先验概率分布: $P(Y = c_k)$</p><p>条件概率分布:$P(X = x|Y = c_k)$</p><p>由上面两个概率得到联合概率分布:</p><script type="math/tex; mode=display">P(X = x,Y = c_k) = P(X = x| y = c_k) P(y = c_k)</script><p>朴素贝叶斯<strong>条件独立性假设</strong>（朴素的含义）:</p><p>当$Y$确定时，$X$的各个特征分量取值之间相互独立，用公式表示:</p><script type="math/tex; mode=display">P(X=x|y = c_k) = P(X = x_1,x_2,...,x_n|y = c_k) = \prod_{j = 1}^{n}P(X_j = x_j|y = c_k)</script><p>后验概率:(结合上式计算)</p><script type="math/tex; mode=display">P(Y = c_k|X) = \frac{P(X = x|Y = c_k)P(Y = c_k)}{P(X)} = \frac{P(X = x|Y = c_k)P(Y = c_k)}{\sum_{k} P(X = x|y = c_k)P(y = c_k)}</script><p><strong>在估计条件概率$P(X)$时出现概率为0的情况怎么办？</strong></p><p>贝叶斯估计:</p><p>在每个随机变量的哥哥取值的频数上各加一个正数$\lambda$,常取$\lambda = 1$</p><h2 id="4-决策树"><a href="#4-决策树" class="headerlink" title="4.决策树"></a>4.决策树</h2><h3 id="4-1算法流程"><a href="#4-1算法流程" class="headerlink" title="4.1算法流程"></a>4.1算法流程</h3><p><img src="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/dtree.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200701214058220"></p><h3 id="4-2-决策树的三个停止条件"><a href="#4-2-决策树的三个停止条件" class="headerlink" title="4.2 决策树的三个停止条件:"></a><strong>4.2 决策树的三个停止条件:</strong></h3><ul><li>当前节点包含的样本属于同一类别，无需划分。</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无需划分。把当前节点标记为叶节点，类别设定为它的父节点所含样本最多的类别</li><li>当前节点包含的样本集合为空，不能划分。把父节点样本分布作为当前结点的先验分布。</li></ul><h3 id="4-3划分选择"><a href="#4-3划分选择" class="headerlink" title="4.3划分选择:"></a><strong>4.3划分选择:</strong></h3><h4 id="4-3-1信息增益ID3"><a href="#4-3-1信息增益ID3" class="headerlink" title="4.3.1信息增益ID3"></a>4.3.1信息增益ID3</h4><p>信息熵: 度量样本集合纯度，熵越大，越混乱。公式如下:$p_k$表示样本集合D中第k类样本所占比例。</p><script type="math/tex; mode=display">Ent(D)  =- \sum_{k = 1}^{C}p_klog(p_k)</script><p>信息增益,使用a属性划分，划分后产生V个分支节点，信息增益公式为:</p><script type="math/tex; mode=display">Gain(D,a) = Ent(D) - \sum_{v = 1}^{V}\frac{D^v}{D}Ent(D^v)</script><h4 id="4-3-2增益率C4-5"><a href="#4-3-2增益率C4-5" class="headerlink" title="4.3.2增益率C4.5"></a>4.3.2增益率C4.5</h4><p>信息增益准则对可取数目比较多的属性有所偏好，(可取属性越多，划分越纯)，为减少这种偏好可能带来的不利影响，使用增益率作为划分依据。</p><script type="math/tex; mode=display">Gain_ratio(D,a) = \frac{Gain(D,a)}{IV(a)}\\IV (a)  =-\sum_{v = 1}^V\frac{|D^v|}{|D|}log2\frac{|D^v|}{|D|}</script><p>属性a的可能取值越多，IV越大</p><h4 id="4-3-3基尼指数CART"><a href="#4-3-3基尼指数CART" class="headerlink" title="4.3.3基尼指数CART"></a>4.3.3基尼指数CART</h4><p>从数据集D中随机抽取两个样本，类别不一致的概率。Gini越小，纯度越高。</p><script type="math/tex; mode=display">Gini(D) = \sum_{k=1}^C\sum_{u != k}p_k p_u = 1 - \sum_{k = 1}^{C}p_{k}^2</script><p>基尼指数为:选择使基尼指数最小a的作为划分依据。</p><script type="math/tex; mode=display">Gini_index(D,a) = \sum_{v=1}^{V}\frac{|D^v|}{|D|}Gini(D^v)</script><h3 id="4-4-剪枝"><a href="#4-4-剪枝" class="headerlink" title="4.4 剪枝"></a>4.4 剪枝</h3><p>提高泛化能力，避免过拟合。</p><h4 id="4-4-1预剪枝"><a href="#4-4-1预剪枝" class="headerlink" title="4.4.1预剪枝"></a>4.4.1预剪枝</h4><p>比较划分前后的验证集精度，如果划分后验证集精度不能提升，则禁止划分，类别标记为最多的类。有欠拟合的风险。</p><h4 id="4-4-2-后剪枝"><a href="#4-4-2-后剪枝" class="headerlink" title="4.4.2 后剪枝"></a>4.4.2 后剪枝</h4><p>自底向上的剪枝方法。后续遍历决策树内部节点，比较剪枝前后的验证集精度。</p><h3 id="4-5-连续值处理"><a href="#4-5-连续值处理" class="headerlink" title="4.5 连续值处理"></a>4.5 连续值处理</h3><p>二分法。与离散属性不同，若当前节点划分属性为连续属性，该属性还可作为其后代节点的划分属性。</p><h2 id="5-线性回归"><a href="#5-线性回归" class="headerlink" title="5.线性回归"></a>5.线性回归</h2><p>损失函数为L2距离</p><h2 id="6-逻辑回归"><a href="#6-逻辑回归" class="headerlink" title="6.逻辑回归"></a>6.逻辑回归</h2><h3 id="6-1二项式逻辑回归"><a href="#6-1二项式逻辑回归" class="headerlink" title="6.1二项式逻辑回归"></a>6.1二项式逻辑回归</h3><script type="math/tex; mode=display">P(Y = 1|x)  = \frac{exp(w^T x+b)}{1+exp(w^T x+b)}\\P(Y = 0|x) = \frac{1}{1+exp(w^T x+b)}</script><p>损失函数为交叉熵，可以根据极大似然估计获得。</p><h3 id="6-2多项式逻辑回归"><a href="#6-2多项式逻辑回归" class="headerlink" title="6.2多项式逻辑回归"></a>6.2多项式逻辑回归</h3><script type="math/tex; mode=display">P(Y = k|x)  = \frac{exp(w^T x_k+b)}{1+\sum_{k=1}^{K-1}exp(w^T x_k+b)},k = 1,2,..K-1\\P(Y = K|x) = \frac{1}{1+\sum_{k=1}^{K-1}exp(w^T x_k+b)}</script><h2 id="7-隐马尔可夫模型"><a href="#7-隐马尔可夫模型" class="headerlink" title="7.隐马尔可夫模型"></a>7.隐马尔可夫模型</h2><h3 id="7-1HMM属性"><a href="#7-1HMM属性" class="headerlink" title="7.1HMM属性"></a>7.1HMM属性</h3><ul><li>Q:所有可能状态集合${q_1,q_2,…,q_N}$</li><li>V:所有可能的观测集合${v_1,v_2,…,v_M}$</li><li>I:长度为T的状态序列${i_1,i_2,…i_T}$</li><li>O::长度为T的观测序列${o_1,o_2,…,o_T}$</li><li>A:状态转移矩阵,$N×N$,$a_{ij}$表示在时刻t处于状态$q_i$的条件下在时刻t+1转移到状态$q_j$的概率。</li><li>B:观测概率矩阵,$N×M$，$b_j$表示t时刻处于状态$q_j$生成观测$v_k$的概率。</li><li>$\pi$:初始状态概率向量，$\pi_i = P(i_1 = q_i)$</li></ul><h3 id="7-2-隐马尔可夫三要素"><a href="#7-2-隐马尔可夫三要素" class="headerlink" title="7.2 隐马尔可夫三要素"></a>7.2 隐马尔可夫三要素</h3><script type="math/tex; mode=display">\lambda = (A,B,\pi)</script><h3 id="7-3-隐马尔可夫两个基本假设"><a href="#7-3-隐马尔可夫两个基本假设" class="headerlink" title="7.3 隐马尔可夫两个基本假设"></a>7.3 隐马尔可夫两个基本假设</h3><p><strong>齐次马尔可夫性假设</strong>:马尔可夫在t+1时刻的状态只依赖于其前一时刻的状态。</p><p><strong>观测独立性假设</strong>：当前观测值只依赖于当前状态。</p><h3 id="7-4隐马尔可夫的三个问题"><a href="#7-4隐马尔可夫的三个问题" class="headerlink" title="7.4隐马尔可夫的三个问题"></a>7.4隐马尔可夫的三个问题</h3><ul><li><strong>概率问题</strong>:已知模型和观测序列，计算观测序列出现的概率$P(O|\lambda)$。</li><li><strong>学习问题</strong>:已知观测序列，估计模型参数，使得在该模型下观测序列概率$P(O|\lambda)$最大。</li><li><strong>预测问题</strong>:已知模型和观测序列，求对给定观测序列条件概率$P(I|O)$最大的状态序列I,即给定观测序列，求最有可能对应的状态序列。解码，分词。维特比(Viterbi)算法.</li></ul><h3 id="7-5-预测问题"><a href="#7-5-预测问题" class="headerlink" title="7.5 预测问题"></a>7.5 预测问题</h3><h2 id="8-聚类"><a href="#8-聚类" class="headerlink" title="8.聚类"></a>8.聚类</h2><h3 id="8-1-K-means"><a href="#8-1-K-means" class="headerlink" title="8.1 K-means"></a>8.1 K-means</h3><p><strong>算法流程:</strong></p><ul><li>输入聚类簇的个数k。</li><li>从数据集中随机选择k个数据点作为初始的质心。</li><li>对训练集中的每一个样本，计算它于质心的距离，距离哪个质心进，就属于那一组。</li><li>然后每个组重新求质心。</li><li>如果新的质心于原来质心的距离的和小于某个阈值，算法停止，否则继续迭代。</li></ul><p>细节问题:</p><p>​    1. K值怎么定？我怎么知道应该几类？ 答：这个真的没有确定的做法，分几类主要取决于个人的经验与感觉，通常的做法是多尝试几个K值，看分成几类的结果更好解释，更符合分析目的等。或者可以把各种K值算出的SSE做比较，取最小的SSE的K值。</p><p>​    2. 初始的K个质心怎么选？ 答：最常用的方法是随机选，初始质心的选取对最终聚类结果有影响，因此算法一定要多执行几次，哪个结果更reasonable，就用哪个结果。 当然也有一些优化的方法，第一种是选择彼此距离最远的点，具体来说就是先选第一个点，然后选离第一个点最远的当第二个点，然后选第三个点，第三个点到第一、第二两点的距离之和最小，以此类推。第二种是先根据其他聚类算法（如层次聚类）得到聚类结果，</p><pre><code>3. K-Means会不会陷入一直选质心的过程，永远停不下来？ 答：不会，有数学证明K-Means一定会收敛，大致思路是利用SSE的概念（也就是误差平方和），即每个点到自身所归属质心的距离的平方和，这个平方和是一个函数，然后能够证明这个函数是可以最终收敛的函数。 4. 缺点:只能处理球形的簇(只适用于凸样本集)。</code></pre><h3 id="8-2-DBSCAN"><a href="#8-2-DBSCAN" class="headerlink" title="8.2 DBSCAN"></a>8.2 DBSCAN</h3><p>​    DBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种基于密度的空间聚类算法。 该算法将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，它将簇定义为密度相连的点的最大集合。DBSCAN算法的显著优点是聚类速度快且能够有效处理噪声点和发现<strong>任意形状的空间聚类</strong>。<br>​     该算法利用基于密度的聚类的概念，即要求聚类空间中的一定区域内所包含对象（点或其他空间对象）的数目不小于某一给定阈值。过滤低密度区域，发现稠密度样本点。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</p><p>思想:同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</p><p><strong>概念:</strong></p><ul><li>核心对象: 对一个样本，在它的一个给定邻域内，样本的个数大于等于给定的阈值，则称该样本是核心对象。</li><li>密度直达: 如果$x_i$位于$x_j$的邻域中，且$x_j$是核心对象，那么$x_i$可由$x_j$密度直达。</li><li>密度可达:对于$x_i$和$x_j$,如果存在样本序列$p_1,p_2,…,p_T$满足$p_1 = x_i,p_t = x_j$,$p_t+1$可有$p_t$密度直达，则$x_j$由$x_i$密度可达。注意$p_1,…p_t+1$是核心对象。</li><li>密度相连:对于$x_i$和$x_j$,如果存在核心对象样本$x_k$,使得$x_i$和$x_j$均有$x_k$ 密度可达。</li></ul><p><strong>算法流程</strong>:</p><ul><li>找出所有核心对象 </li><li>从一个核心对象出发建立一个簇 </li><li>从核心对象集中去除已经被分簇的核心对象</li><li>对剩余核心对象重复执行第2、3步，至核心对象集为空。</li></ul><p><strong>如何从一个核心对象出发建立簇</strong>:</p><pre><code> 初始，给定数据集D中所有对象都被标记为“unvisited”，DBSCAN随机选择一个未访问的对象p，标记p为“visited”，并检查p的**ϵ-**领域是否至少包含MinPts个对象。如果不是，则p被标记为噪声点。否则为p创建一个新的簇C，并且把p的**ϵ-**领域中所有对象都放在候选集合N中。DBSCAN迭代地把N中不属于其他簇的对象添加到C中。在此过程中，对应N中标记为“unvisited”的对象 P&#39; ,DBSCAN把它标记为“visited”，并且检查它的**ϵ-**领域，如果 P&#39; 的**ϵ-**领域至少包含MinPts个对象，则P&#39; 的**ϵ-**领域中的对象都被添加到N中。DBSCAN继续添加对象到C，直到C不能扩展，即直到N为空。此时簇C完成生成，输出。</code></pre><h3 id="8-3评价指标"><a href="#8-3评价指标" class="headerlink" title="8.3评价指标"></a>8.3评价指标</h3><p>标准: 簇内相似度高，簇间相似度低</p><p>内部指标:</p><p>DB指数</p><p><img src="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/dbi.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200721150259920"></p><p>外部指标:</p><p>Jaccard 系数</p><p><img src="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/jaccard.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200721151105353"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL</title>
    <link href="/EruLv.github.io/2020/06/20/C-STL/"/>
    <url>/EruLv.github.io/2020/06/20/C-STL/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcoed_week_1</title>
    <link href="/EruLv.github.io/2020/06/17/Leetcode-week-1/"/>
    <url>/EruLv.github.io/2020/06/17/Leetcode-week-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-打卡-week-1"><a href="#Leetcode-打卡-week-1" class="headerlink" title="Leetcode 打卡 week 1"></a>Leetcode 打卡 week 1</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例</strong></p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><p>暴力枚举$O(n^2)$</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; res;        int n = nums.size();        for(int i = 0; i &lt; n; i++){            for(int j = i; j&lt;n; j++){                if( i!=j &amp;&amp; nums[i] + nums[j] == target){                    res.push_back(i);                    res.push_back(j);                }            }        }        return res;    }};</code></pre><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>排序 + 双指针, 参考<a href="https://www.acwing.com/problem/content/802/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/802/</a></p><p>因为需要存下标，很不推荐这种方法。</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; res;        vector&lt;pair&lt;int, int&gt;&gt; a;        for(int i = 0; i&lt; nums.size();i++) a.push_back({nums[i], i});        sort(a.begin(),a.end());  //升序，nlogn        for(int i = 0, j = 0; i&lt;a.size(); i++){    //O(2n)            while(a[i].first + a[j].first &lt; target) j++;            if( i != j &amp;&amp;a[i].first + a[j].first == target) {                res.push_back(a[i].second);                res.push_back(a[j].second);            }        }        sort(res.begin(), res.end());        return res;    }};</code></pre><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h4><p>Hash map</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int, int&gt; heap;    //基于散列表，查找时间为O(1)        for(int i = 0; i&lt; nums.size(); i++){            int r = target - nums[i];   //寻找目标值            if (heap.count(r)) return {heap[r], i};    //判断是否存在该键            heap[nums[i]] = i;        }        return {};    }};</code></pre><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><pre><code class="lang-c++">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="lang-c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {        ListNode* head = new ListNode(-1);        ListNode* cur = head;        int t = 0;  //进位        while(l1 || l2 || t){   //若t最后为1，需要添加一个节点            if(l1) t += l1-&gt;val, l1 = l1-&gt;next;            if(l2) t += l2-&gt;val, l2 = l2-&gt;next;            cur-&gt;next = new ListNode(t % 10);            cur = cur-&gt;next;            t /= 10;        }        return head-&gt;next;    }};</code></pre><h3 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>双指针算法.</p><p> 假设[j,i]为最长无重复字串，i向后移动时，j只能不动或向后移动。</p><pre><code class="lang-c++">class Solution {public:    int lengthOfLongestSubstring(string s) {        unordered_map&lt;char, int&gt; heap;        int res = 0;        for(int i =0, j = 0; i&lt;s.size();i++){            heap[s[i]] ++;            while(heap[s[i]] &gt; 1){                heap[s[j]] --;                j ++;            }            res = max(res, i - j + 1);        }    return res;    }};</code></pre><p>以”pwwkew”为例：</p><pre><code class="lang-c++">i = 0, j = 0, {p:1}i = 1, j = 0, {p:1, w:1}i = 2, j = 0, {p:1, w:2}     -&gt; j++, {w:2}     -&gt; j++, {w:1}i = 3, j = 2, {k:1, w:1}i = 4, j = 2, {k:1, w:1, e:1}i = 5, j = 2, {k:1, w:2, e:1}...</code></pre><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h3><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p><strong>示例 1:</strong></p><pre><code>nums1 = [1, 3]nums2 = [2]则中位数是 2.0</code></pre><p><strong>示例 2:</strong></p><pre><code>nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>思想和归并排序相同。$O(m+n)$</p><pre><code class="lang-c++">class Solution {public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        double res;        vector&lt;int&gt; r;        int i = 0 , j = 0;        while(i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()){            if(nums1[i] &lt; nums2[j]) r.push_back(nums1[i++]);            else r.push_back(nums2[j++]);        }        while(i &lt; nums1.size()) r.push_back(nums1[i++]);        while(j &lt; nums2.size()) r.push_back(nums2[j++]);        int n = nums1.size() +  nums2.size();        if(n%2 == 0)            res = double(r[n&gt;&gt;1] + r[n-1&gt;&gt;1])/2;        else res = r[n&gt;&gt;1];        return res;    }};</code></pre><h4 id="Solution-2-1"><a href="#Solution-2-1" class="headerlink" title="Solution 2"></a>Solution 2</h4>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oj好题错题集</title>
    <link href="/EruLv.github.io/2020/06/11/oj%E9%94%99%E9%A2%98%E9%9B%86/"/>
    <url>/EruLv.github.io/2020/06/11/oj%E9%94%99%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="oj好题错题集"><a href="#oj好题错题集" class="headerlink" title="oj好题错题集"></a>oj好题错题集</h1><h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1.模拟"></a>1.模拟</h2><h3 id="1-1-蚂蚁坠落"><a href="#1-1-蚂蚁坠落" class="headerlink" title="1.1 蚂蚁坠落"></a>1.1 蚂蚁坠落</h3><pre><code>https://www.nowcoder.com/practice/fdd6698014c340178a8b1f28ea5fadf8?tpId=40&amp;&amp;tqId=21420&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/kaoyan/question-ranking</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>c++ 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm排序</title>
    <link href="/EruLv.github.io/2020/06/11/Algoritm%E6%8E%92%E5%BA%8F/"/>
    <url>/EruLv.github.io/2020/06/11/Algoritm%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="基础算法-一-——排序"><a href="#基础算法-一-——排序" class="headerlink" title="基础算法(一)——排序"></a>基础算法(一)——排序</h2><h3 id="1-快排"><a href="#1-快排" class="headerlink" title="1.快排"></a>1.快排</h3><p>快排是不稳定的。</p><p>基于<strong>分治</strong>，步骤:</p><ol><li>确定分界点</li><li>调整区间，&lt;=x在x左边，&gt;=x的在x右边。</li><li>递归，左边右边排序。</li></ol><pre><code class="lang-c++">void quick_sort(int q[], int l, int r){    if(l&gt;=r) return;    int x = q[l+r&gt;&gt;1], i = l - 1, j = r + 1;    while(i &lt; j){        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);    }    quick_sort(q,l,j);    quick_sort(q,j+1,r);}</code></pre><h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h3><p>归并排序是稳定的。</p><ol><li>确定分界点。mid = (l+r)/2</li><li>递归排序left,right</li><li>归并，合二为一</li></ol><pre><code class="lang-c++">void merge_sort(int q[], int l, int r){    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法 排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algoritm模板</title>
    <link href="/EruLv.github.io/2020/06/10/Algoritm%E6%A8%A1%E6%9D%BF/"/>
    <url>/EruLv.github.io/2020/06/10/Algoritm%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="C-常用算法模板（一）"><a href="#C-常用算法模板（一）" class="headerlink" title="C++常用算法模板（一）"></a>C++常用算法模板（一）</h2><p>字符串、数字、数组的基础操作。</p><h3 id="1-反序数"><a href="#1-反序数" class="headerlink" title="1.反序数"></a>1.反序数</h3><p>1234-&gt;4321。</p><p>可用于判断数字是否对称。</p><pre><code class="lang-c++">int reverse(int x){    //反序数    int r = 0;    while(x!=0){        r *= 10;        r += x%10;        x /= 10;    }     return r;}</code></pre><h4 id="2-字符串反转"><a href="#2-字符串反转" class="headerlink" title="2.字符串反转"></a>2.字符串反转</h4><pre><code class="lang-c++">string reverse(string s){    string r = &quot;&quot;;    for(int i=s.size()-1;i&gt;=0;i--){        r += s[i];    }    return r;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法 c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT甲级1001</title>
    <link href="/EruLv.github.io/2020/05/22/PAT%E7%94%B2%E7%BA%A71001/"/>
    <url>/EruLv.github.io/2020/05/22/PAT%E7%94%B2%E7%BA%A71001/</url>
    
    <content type="html"><![CDATA[<h2 id="A-B-Format"><a href="#A-B-Format" class="headerlink" title="A+B Format"></a>A+B Format</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Calculate A + B and output the sum in standard format—hat is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where  </p><script type="math/tex; mode=display">-10^6<= a,b <= 10^6</script><p>The numbers are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="lang-c++">-1000000 9</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="lang-c++">-999,991</code></pre><h3 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution:"></a>My Solution:</h3><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    int a,b;    cin&gt;&gt;a&gt;&gt;b;    int r = a+b;    if(r==0){        cout&lt;&lt;0&lt;&lt;endl;        return 0;    }    int flag = r/abs(r);    if(flag==-1)        cout&lt;&lt;&quot;-&quot;;    string s = to_string(abs(r));    int j = 3-s.size()%3;    bool f = j==0;    for(int i=0;i&lt;s.size();i++){        if((i+j)%3==0 &amp;&amp; i!=0){             cout&lt;&lt;&quot;,&quot;;        }        cout&lt;&lt;s[i];    }    cout&lt;&lt;endl;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>字符串处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/EruLv.github.io/2020/05/22/test/"/>
    <url>/EruLv.github.io/2020/05/22/test/</url>
    
    <content type="html"><![CDATA[<h1 id="This-is-a-test"><a href="#This-is-a-test" class="headerlink" title="This is a test."></a>This is a test.</h1><p><img src="/EruLv.github.io/2020/05/22/test/test1.jpg" srcset="/EruLv.github.io/img/loading.gif" alt="test1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp常用函数</title>
    <link href="/EruLv.github.io/2020/03/19/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/EruLv.github.io/2020/03/19/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="c-常用函数"><a href="#c-常用函数" class="headerlink" title="c++常用函数"></a>c++常用函数</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort:"></a>sort:</h4><p>头文件:</p><pre><code class="lang-c++">#include&lt;algorithm&gt;</code></pre><p>使用方法:</p><pre><code class="lang-c++">void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></pre><p>（1）第一个参数first：是要排序的数组的起始地址。</p><p>（2）第二个参数last：是结束的地址（最后一个数据的后一个数据的地址）</p><p>（3）第三个参数comp是排序的方法：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是<strong>从小到大</strong>排序。</p><h4 id="qsort"><a href="#qsort" class="headerlink" title="qsort:"></a>qsort:</h4><pre><code class="lang-c++">void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</code></pre><ul><li><p><strong>base</strong> — 指向要排序的数组的第一个元素的指针。</p></li><li><p><strong>nitems</strong> — 由 base 指向的数组中元素的个数。</p></li><li><p><strong>size</strong> — 数组中每个元素的大小，以字节为单位。</p></li><li><p><strong>compar</strong> — 用来比较两个元素的函数。</p></li></ul><h3 id="2-输出保留小数后几位"><a href="#2-输出保留小数后几位" class="headerlink" title="2.输出保留小数后几位"></a>2.输出保留小数后几位</h3><p>头文件:</p><pre><code class="lang-c++">#include&lt;iomanip&gt;</code></pre><p>需要补零:</p><pre><code class="lang-c++">cout&lt;&lt;fixed&lt;&lt;setprecision(需要精确到小数点后几位)&lt;&lt;ans&lt;&lt;endl;</code></pre><p>不需要补零:</p><pre><code class="lang-c++">cout&lt;&lt;setprecision(需要精确到小数点后几位)&lt;&lt;ans&lt;&lt;endl;</code></pre><p><strong>推荐</strong>：更简单的方法:使用printf()</p><pre><code class="lang-c++">float d = 0.235;printf(&quot;%.5f\n&quot;,d);</code></pre><p>结果:0.23500</p><pre><code class="lang-c++">float d = 0.235;printf(&quot;%.2f\n&quot;,d);</code></pre><p>结果: 0.23</p><h3 id="3-格式化输出-日期"><a href="#3-格式化输出-日期" class="headerlink" title="3.格式化输出(日期)"></a>3.格式化输出(日期)</h3><pre><code class="lang-c++">printf(&quot;%04d-%02d-%02d\n&quot;,yyyy,mm,dd);</code></pre><p>会右对齐左补0.</p><h3 id="4-全局变量声明"><a href="#4-全局变量声明" class="headerlink" title="4.全局变量声明"></a>4.全局变量声明</h3><p>声明的int 的全局变量，数组会默认初始化为0.</p><h3 id="5-无限大与无限小-inf"><a href="#5-无限大与无限小-inf" class="headerlink" title="5.无限大与无限小(inf)"></a>5.无限大与无限小(inf)</h3><pre><code class="lang-c++">int inf = 1e9;//更好的: int最大2^31 - 1, 约等于10^9。int inf = 0x3f3f3f3f;</code></pre><h3 id="6-string与int互转"><a href="#6-string与int互转" class="headerlink" title="6.string与int互转"></a>6.string与int互转</h3><p>atoi:(表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。</p><pre><code class="lang-c++">string s = &quot;123&quot;;int x = atoi(s.c_str());cout&lt;&lt;x&lt;&lt;endl;</code></pre><p>int转字符串</p><pre><code class="lang-c++">#include&lt;string&gt;string s = &quot;&quot;;int x = 5;s = to_string(x);</code></pre><p>c</p><h3 id="7-输入带空格的字符串"><a href="#7-输入带空格的字符串" class="headerlink" title="7.输入带空格的字符串"></a>7.输入带空格的字符串</h3><pre><code class="lang-c++">#include&lt;string.h&gt;char str[1000];gets(str);int len = strlen(str);</code></pre><p>or</p><pre><code class="lang-c++">#include&lt;string&gt;string str;getline(cin , str);cout&lt;&lt;str&lt;&lt;endl;</code></pre><h3 id="8-清空数组"><a href="#8-清空数组" class="headerlink" title="8.清空数组"></a>8.清空数组</h3><p>memset函数</p><pre><code class="lang-c++">#include &lt;cstring&gt;const int N = 128;int hs[N];int main(){    hs[0] = 5;    cout&lt;&lt;hs[0]&lt;&lt;endl;    memset(hs, 0 , sizeof(hs));    cout&lt;&lt;hs[0]&lt;&lt;endl;    return 0;}</code></pre><h3 id="9-分词"><a href="#9-分词" class="headerlink" title="9. 分词"></a>9. 分词</h3><pre><code class="lang-c++">    //分词    s += &quot; &quot;;    string tmp = &quot;&quot;;    int m = 0;    for(int i = 0; i &lt; s.size(); i++){        if(s[i] == &#39; &#39;){            w[m++] = tmp;            tmp = &quot;&quot;;        }        else{            tmp += s[i];        }    }</code></pre><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵求导运算</title>
    <link href="/EruLv.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E8%BF%90%E7%AE%97/"/>
    <url>/EruLv.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵求导运算推导与总结"><a href="#矩阵求导运算推导与总结" class="headerlink" title="矩阵求导运算推导与总结"></a>矩阵求导运算推导与总结</h2><h3 id="1-标量对向量求导"><a href="#1-标量对向量求导" class="headerlink" title="1.标量对向量求导"></a>1.标量对向量求导</h3><p>输入向量，输出标量。即映射关系为$f:R^N➡R$ 。</p><p>设$y = f(\boldsymbol{x})$ ,$\boldsymbol{x}$是Nx1的矢量，y是标量。</p><p>则求导结果为:</p><script type="math/tex; mode=display">\frac{\partial y}{\partial \boldsymbol{x}}=\left(\frac{\partial y}{\partial x_{1}}, \frac{\partial y}{\partial x_{2}}, \ldots, \frac{\partial y}{\partial x_{N}}\right)</script><h3 id="2-向量对向量求导"><a href="#2-向量对向量求导" class="headerlink" title="2.向量对向量求导"></a>2.向量对向量求导</h3><p>输入向量，输出也是向量，则需要用到 Jacobian矩阵。</p><p>假设映射关系为$f:R^N➡R^M$ ,输入输出都为向量。$\boldsymbol{y} = f(\boldsymbol{x})$ ,则有:</p><script type="math/tex; mode=display">\frac{\partial y}{\partial x}=\left(\begin{array}{ccc}\frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{1}}{\partial x_{N}} \\\vdots & \ddots & \vdots \\\frac{\partial y_{M}}{\partial x_{1}} & \cdots & \frac{\partial y_{M}}{\partial x_{N}}\end{array}\right)</script><p>输出MxN的矩阵。</p><script type="math/tex; mode=display">\left(\frac{\partial \boldsymbol{y}}{\partial \boldsymbol{x}}\right)_{i j}=\frac{\partial y_{i}}{\partial x_{j}}</script><h4 id="2-1-x-为列向量"><a href="#2-1-x-为列向量" class="headerlink" title="2.1$x$为列向量"></a>2.1$x$为列向量</h4><p>假如$W$ 是一个NxM的矩阵，$\boldsymbol{z}=\boldsymbol{W}\boldsymbol{x}$ ，$\boldsymbol{x}$为Mx1的列向量，$\boldsymbol{z}$为Nx1的列向量,Jacobian矩阵为NxM维。</p><script type="math/tex; mode=display">z_{i}=\sum_{k=1}^{m} W_{i k} x_{k}</script><script type="math/tex; mode=display">\left(\frac{\partial \boldsymbol{z}}{\partial \boldsymbol{x}}\right)_{i j}=\frac{\partial z_{i}}{\partial x_{j}}=\frac{\partial}{\partial x_{j}} \sum_{k=1}^{m} W_{i k} x_{k}=\sum_{k=1}^{m} W_{i k} \frac{\partial}{\partial x_{j}} x_{k}=W_{i j}</script><p>所以</p><script type="math/tex; mode=display">\frac{\partial{\boldsymbol{z}}}{\partial{\boldsymbol{x}}} = \boldsymbol{W}</script><h4 id="2-2-x-为行向量"><a href="#2-2-x-为行向量" class="headerlink" title="2.2 $x$为行向量"></a>2.2 $x$为行向量</h4><p>假设有$\boldsymbol{z}=\boldsymbol{x}\boldsymbol{W}$ ，$\boldsymbol{x}$为1xN的列向量，$\boldsymbol{z}$为1xM的列向量.W维度为NxM,Jacobian矩阵为MxN.</p><script type="math/tex; mode=display">\frac{\partial{\boldsymbol{z}}}{\partial{\boldsymbol{x}}} = \boldsymbol{W^T}</script><h3 id="3-向量对矩阵求导"><a href="#3-向量对矩阵求导" class="headerlink" title="3.向量对矩阵求导"></a>3.向量对矩阵求导</h3>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
