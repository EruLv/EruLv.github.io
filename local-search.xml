<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>“机器学习复习”</title>
    <link href="/EruLv.github.io/2020/07/01/%E2%80%9C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0%E2%80%9D/"/>
    <url>/EruLv.github.io/2020/07/01/%E2%80%9C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0%E2%80%9D/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="1-判别模型vs生成模型"><a href="#1-判别模型vs生成模型" class="headerlink" title="1.判别模型vs生成模型"></a>1.判别模型vs生成模型</h2><p>生成模型是由数据先学习联合概率分布$P(X,Y)$，然后求出条件概率分布作为预测模型。如朴素贝叶斯和隐马尔可夫模型。</p><p>判别方法是直接根据数据学习决策函数$f(X)$或者条件概率分布$P(Y|X)$作为预测的模型(学习一个决策边界)。典型的模型由SVM，k近邻，感知机，决策树、最大熵模型、条件随机场等。</p><p>判别: discriminative</p><p>生成: generative</p><h2 id="2-评测指标"><a href="#2-评测指标" class="headerlink" title="2.评测指标"></a>2.评测指标</h2><h3 id="2-1-准确率，精确率，召回率，F1值"><a href="#2-1-准确率，精确率，召回率，F1值" class="headerlink" title="2.1 准确率，精确率，召回率，F1值"></a>2.1 准确率，精确率，召回率，F1值</h3><ul><li>tp: 预测为正类，实际为正类</li><li>fp:预测为正类，实际为负类</li><li>tn:预测为负类，实际为负类</li><li>fn:预测为负类，实际为正类</li></ul><p>准确率</p><script type="math/tex; mode=display">acc = \frac{tp + tn}{tp + tn + fp + fn}</script><p>精确率</p><script type="math/tex; mode=display">p = \frac{tp}{tp + fp}</script><p>召回率</p><script type="math/tex; mode=display">r = \frac{tp}{tp + fn}</script><p>F1值:精确率和召回率的调和平均</p><script type="math/tex; mode=display">F1 = \frac{2*p*r}{p+r}</script><h2 id="3-朴素贝叶斯"><a href="#3-朴素贝叶斯" class="headerlink" title="3. 朴素贝叶斯"></a>3. 朴素贝叶斯</h2><p>先验概率分布: $P(Y = c_k)$</p><p>条件概率分布:$P(X = x|Y = c_k)$</p><p>由上面两个概率得到联合概率分布:</p><script type="math/tex; mode=display">P(X = x,Y = c_k) = P(X = x| y = c_k) P(y = c_k)</script><p>朴素贝叶斯<strong>条件独立性假设</strong>（朴素的含义）:</p><p>当$Y$确定时，$X$的各个特征分量取值之间相互独立，用公式表示:</p><script type="math/tex; mode=display">P(X=x|y = c_k) = P(X = x_1,x_2,...,x_n|y = c_k) = \prod_{j = 1}^{n}P(X_j = x_j|y = c_k)</script><p>后验概率:(结合上式计算)</p><script type="math/tex; mode=display">P(Y = c_k|X) = \frac{P(X = x|Y = c_k)P(Y = c_k)}{P(X)} = \frac{P(X = x|Y = c_k)P(Y = c_k)}{\sum_{k} P(X = x|y = c_k)P(y = c_k)}</script><p><strong>在估计条件概率$P(X)$时出现概率为0的情况怎么办？</strong></p><p>贝叶斯估计:</p><p>在每个随机变量的哥哥取值的频数上各加一个正数$\lambda$,常取$\lambda = 1$</p><h2 id="4-决策树"><a href="#4-决策树" class="headerlink" title="4.决策树"></a>4.决策树</h2><h3 id="4-1算法流程"><a href="#4-1算法流程" class="headerlink" title="4.1算法流程"></a>4.1算法流程</h3><p><img src="/EruLv.github.io/2020/07/01/%E2%80%9C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0%E2%80%9D/dtree.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200701214058220"></p><h3 id="4-2-决策树的三个停止条件"><a href="#4-2-决策树的三个停止条件" class="headerlink" title="4.2 决策树的三个停止条件:"></a><strong>4.2 决策树的三个停止条件:</strong></h3><ul><li>当前节点包含的样本属于同一类别，无需划分。</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无需划分。把当前节点标记为叶节点，类别设定为它的父节点所含样本最多的类别</li><li>当前节点包含的样本集合为空，不能划分。把父节点样本分布作为当前结点的先验分布。</li></ul><h3 id="4-3划分选择"><a href="#4-3划分选择" class="headerlink" title="4.3划分选择:"></a><strong>4.3划分选择:</strong></h3><h4 id="4-3-1信息增益ID3"><a href="#4-3-1信息增益ID3" class="headerlink" title="4.3.1信息增益ID3"></a>4.3.1信息增益ID3</h4><p>信息熵: 度量样本集合纯度，熵越大，越混乱。公式如下:$p_k$表示样本集合D中第k类样本所占比例。</p><script type="math/tex; mode=display">Ent(D)  =- \sum_{k = 1}^{C}p_klog(p_k)</script><p>信息增益,使用a属性划分，划分后产生V个分支节点，信息增益公式为:</p><script type="math/tex; mode=display">Gain(D,a) = Ent(D) - \sum_{v = 1}^{V}\frac{D^v}{D}Ent(D^v)</script><h4 id="4-3-2增益率C4-5"><a href="#4-3-2增益率C4-5" class="headerlink" title="4.3.2增益率C4.5"></a>4.3.2增益率C4.5</h4><p>信息增益准则对可取数目比较多的属性有所偏好，(可取属性越多，划分越纯)，为减少这种偏好可能带来的不利影响，使用增益率作为划分依据。</p><script type="math/tex; mode=display">Gain_ratio(D,a) = \frac{Gain(D,a)}{IV(a)}\\IV (a)  =-\sum_{v = 1}^V\frac{|D^v|}{|D|}log2\frac{|D^v|}{|D|}</script><p>属性a的可能取值越多，IV越大</p><h4 id="4-3-3基尼指数CART"><a href="#4-3-3基尼指数CART" class="headerlink" title="4.3.3基尼指数CART"></a>4.3.3基尼指数CART</h4><p>从数据集D中随机抽取两个样本，类别不一致的概率。Gini越小，纯度越高。</p><script type="math/tex; mode=display">Gini(D) = \sum_{k=1}^C\sum_{u != k}p_k p_u = 1 - \sum_{k = 1}^{C}p_{k}^2</script><p>基尼指数为:选择使基尼指数最小a的作为划分依据。</p><script type="math/tex; mode=display">Gini_index(D,a) = \sum_{v=1}^{V}\frac{|D^v|}{|D|}Gini(D^v)</script><h3 id="4-4-剪枝"><a href="#4-4-剪枝" class="headerlink" title="4.4 剪枝"></a>4.4 剪枝</h3><p>提高泛化能力，避免过拟合。</p><h4 id="4-4-1预剪枝"><a href="#4-4-1预剪枝" class="headerlink" title="4.4.1预剪枝"></a>4.4.1预剪枝</h4><p>比较划分前后的验证集精度，如果划分后验证集精度不能提升，则禁止划分，类别标记为最多的类。有欠拟合的风险。</p><h4 id="4-4-2-后剪枝"><a href="#4-4-2-后剪枝" class="headerlink" title="4.4.2 后剪枝"></a>4.4.2 后剪枝</h4><p>自底向上的剪枝方法。后续遍历决策树内部节点，比较剪枝前后的验证集精度。</p><h3 id="4-5-连续值处理"><a href="#4-5-连续值处理" class="headerlink" title="4.5 连续值处理"></a>4.5 连续值处理</h3><p>二分法。与离散属性不同，若当前节点划分属性为连续属性，该属性还可作为其后代节点的划分属性。</p><h2 id="5-线性回归"><a href="#5-线性回归" class="headerlink" title="5.线性回归"></a>5.线性回归</h2><p>损失函数为L2距离</p><h2 id="6-逻辑回归"><a href="#6-逻辑回归" class="headerlink" title="6.逻辑回归"></a>6.逻辑回归</h2><h3 id="6-1二项式逻辑回归"><a href="#6-1二项式逻辑回归" class="headerlink" title="6.1二项式逻辑回归"></a>6.1二项式逻辑回归</h3><script type="math/tex; mode=display">P(Y = 1|x)  = \frac{exp(w^T x+b)}{1+exp(w^T x+b)}\\P(Y = 0|x) = \frac{1}{1+exp(w^T x+b)}</script><p>损失函数为交叉熵，可以根据极大似然估计获得。</p><h3 id="6-2多项式逻辑回归"><a href="#6-2多项式逻辑回归" class="headerlink" title="6.2多项式逻辑回归"></a>6.2多项式逻辑回归</h3><script type="math/tex; mode=display">P(Y = k|x)  = \frac{exp(w^T x_k+b)}{1+\sum_{k=1}^{K-1}exp(w^T x_k+b)},k = 1,2,..K-1\\P(Y = K|x) = \frac{1}{1+\sum_{k=1}^{K-1}exp(w^T x_k+b)}</script><h2 id="7-隐马尔可夫模型"><a href="#7-隐马尔可夫模型" class="headerlink" title="7.隐马尔可夫模型"></a>7.隐马尔可夫模型</h2><h3 id="7-1HMM属性"><a href="#7-1HMM属性" class="headerlink" title="7.1HMM属性"></a>7.1HMM属性</h3><ul><li>Q:所有可能状态集合${q_1,q_2,…,q_N}$</li><li>V:所有可能的观测集合${v_1,v_2,…,v_M}$</li><li>I:长度为T的状态序列${i_1,i_2,…i_T}$</li><li>O::长度为T的观测序列${o_1,o_2,…,o_T}$</li><li>A:状态转移矩阵,$N×N$,$a_{ij}$表示在时刻t处于状态$q_i$的条件下在时刻t+1转移到状态$q_j$的概率。</li><li>B:观测概率矩阵,$N×M$，$b_j$表示t时刻处于状态$q_j$生成观测$v_k$的概率。</li><li>$\pi$:初始状态概率向量，$\pi_i = P(i_1 = q_i)$</li></ul><h3 id="7-2-隐马尔可夫三要素"><a href="#7-2-隐马尔可夫三要素" class="headerlink" title="7.2 隐马尔可夫三要素"></a>7.2 隐马尔可夫三要素</h3><script type="math/tex; mode=display">\lambda = (A,B,\pi)</script><h3 id="7-3-隐马尔可夫两个基本假设"><a href="#7-3-隐马尔可夫两个基本假设" class="headerlink" title="7.3 隐马尔可夫两个基本假设"></a>7.3 隐马尔可夫两个基本假设</h3><p><strong>齐次马尔可夫性假设</strong>:马尔可夫在t+1时刻的状态只依赖于其前一时刻的状态。</p><p><strong>观测独立性假设</strong>：当前观测值只依赖于当前状态。</p><h3 id="7-4隐马尔可夫的三个问题"><a href="#7-4隐马尔可夫的三个问题" class="headerlink" title="7.4隐马尔可夫的三个问题"></a>7.4隐马尔可夫的三个问题</h3><ul><li><strong>概率问题</strong>:已知模型和观测序列，计算观测序列出现的概率$P(O|\lambda)$。</li><li><strong>学习问题</strong>:已知观测序列，估计模型参数，使得在该模型下观测序列概率$P(O|\lambda)$最大。</li><li><strong>预测问题</strong>:已知模型和观测序列，求对给定观测序列条件概率$P(I|O)$最大的状态序列I,即给定观测序列，求最有可能对应的状态序列。解码，分词。维特比(Viterbi)算法.</li></ul><h3 id="7-5-预测问题"><a href="#7-5-预测问题" class="headerlink" title="7.5 预测问题"></a>7.5 预测问题</h3><h2 id="8-聚类"><a href="#8-聚类" class="headerlink" title="8.聚类"></a>8.聚类</h2><h3 id="8-1-K-means"><a href="#8-1-K-means" class="headerlink" title="8.1 K-means"></a>8.1 K-means</h3><p><strong>算法流程:</strong></p><ul><li>输入聚类簇的个数k。</li><li>从数据集中随机选择k个数据点作为初始的质心。</li><li>对训练集中的每一个样本，计算它于质心的距离，距离哪个质心进，就属于那一组。</li><li>然后每个组重新求质心。</li><li>如果新的质心于原来质心的距离的和小于某个阈值，算法停止，否则继续迭代。</li></ul><p>细节问题:</p><p>​    1. K值怎么定？我怎么知道应该几类？ 答：这个真的没有确定的做法，分几类主要取决于个人的经验与感觉，通常的做法是多尝试几个K值，看分成几类的结果更好解释，更符合分析目的等。或者可以把各种K值算出的SSE做比较，取最小的SSE的K值。</p><p>​    2. 初始的K个质心怎么选？ 答：最常用的方法是随机选，初始质心的选取对最终聚类结果有影响，因此算法一定要多执行几次，哪个结果更reasonable，就用哪个结果。 当然也有一些优化的方法，第一种是选择彼此距离最远的点，具体来说就是先选第一个点，然后选离第一个点最远的当第二个点，然后选第三个点，第三个点到第一、第二两点的距离之和最小，以此类推。第二种是先根据其他聚类算法（如层次聚类）得到聚类结果，</p><pre><code>3. K-Means会不会陷入一直选质心的过程，永远停不下来？ 答：不会，有数学证明K-Means一定会收敛，大致思路是利用SSE的概念（也就是误差平方和），即每个点到自身所归属质心的距离的平方和，这个平方和是一个函数，然后能够证明这个函数是可以最终收敛的函数。 4. 缺点:只能处理球形的簇(只适用于凸样本集)。</code></pre><h3 id="8-2-DBSCAN"><a href="#8-2-DBSCAN" class="headerlink" title="8.2 DBSCAN"></a>8.2 DBSCAN</h3><p>​    DBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种基于密度的空间聚类算法。 该算法将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，它将簇定义为密度相连的点的最大集合。DBSCAN算法的显著优点是聚类速度快且能够有效处理噪声点和发现<strong>任意形状的空间聚类</strong>。<br>​     该算法利用基于密度的聚类的概念，即要求聚类空间中的一定区域内所包含对象（点或其他空间对象）的数目不小于某一给定阈值。过滤低密度区域，发现稠密度样本点。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</p><p>思想:同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</p><p><strong>概念:</strong></p><ul><li>核心对象: 对一个样本，在它的一个给定邻域内，样本的个数大于等于给定的阈值，则称该样本是核心对象。</li><li>密度直达: 如果$x_i$位于$x_j$的邻域中，且$x_j$是核心对象，那么$x_i$可由$x_j$密度直达。</li><li>密度可达:对于$x_i$和$x_j$,如果存在样本序列$p_1,p_2,…,p_T$满足$p_1 = x_i,p_t = x_j$,$p_t+1$可有$p_t$密度直达，则$x_j$由$x_i$密度可达。注意$p_1,…p_t+1$是核心对象。</li><li>密度相连:对于$x_i$和$x_j$,如果存在核心对象样本$x_k$,使得$x_i$和$x_j$均有$x_k$ 密度可达。</li></ul><p><strong>算法流程</strong>:</p><ul><li>找出所有核心对象 </li><li>从一个核心对象出发建立一个簇 </li><li>从核心对象集中去除已经被分簇的核心对象</li><li>对剩余核心对象重复执行第2、3步，至核心对象集为空。</li></ul><p><strong>如何从一个核心对象出发建立簇</strong>:</p><pre><code> 初始，给定数据集D中所有对象都被标记为“unvisited”，DBSCAN随机选择一个未访问的对象p，标记p为“visited”，并检查p的**ϵ-**领域是否至少包含MinPts个对象。如果不是，则p被标记为噪声点。否则为p创建一个新的簇C，并且把p的**ϵ-**领域中所有对象都放在候选集合N中。DBSCAN迭代地把N中不属于其他簇的对象添加到C中。在此过程中，对应N中标记为“unvisited”的对象 P&#39; ,DBSCAN把它标记为“visited”，并且检查它的**ϵ-**领域，如果 P&#39; 的**ϵ-**领域至少包含MinPts个对象，则P&#39; 的**ϵ-**领域中的对象都被添加到N中。DBSCAN继续添加对象到C，直到C不能扩展，即直到N为空。此时簇C完成生成，输出。</code></pre><h3 id="8-3评价指标"><a href="#8-3评价指标" class="headerlink" title="8.3评价指标"></a>8.3评价指标</h3><p>标准: 簇内相似度高，簇间相似度低</p><p>内部指标:</p><p>DB指数</p><p><img src="/EruLv.github.io/2020/07/01/%E2%80%9C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0%E2%80%9D/dbi.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200721150259920"></p><p>外部指标:</p><p>Jaccard 系数</p><p><img src="/EruLv.github.io/2020/07/01/%E2%80%9C%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0%E2%80%9D/jaccard.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200721151105353"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL</title>
    <link href="/EruLv.github.io/2020/06/20/C-STL/"/>
    <url>/EruLv.github.io/2020/06/20/C-STL/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcoed_week_1</title>
    <link href="/EruLv.github.io/2020/06/17/Leetcode-week-1/"/>
    <url>/EruLv.github.io/2020/06/17/Leetcode-week-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-打卡-week-1"><a href="#Leetcode-打卡-week-1" class="headerlink" title="Leetcode 打卡 week 1"></a>Leetcode 打卡 week 1</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例</strong></p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><p>暴力枚举$O(n^2)$</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; res;        int n = nums.size();        for(int i = 0; i &lt; n; i++){            for(int j = i; j&lt;n; j++){                if( i!=j &amp;&amp; nums[i] + nums[j] == target){                    res.push_back(i);                    res.push_back(j);                }            }        }        return res;    }};</code></pre><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>排序 + 双指针, 参考<a href="https://www.acwing.com/problem/content/802/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/802/</a></p><p>因为需要存下标，很不推荐这种方法。</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; res;        vector&lt;pair&lt;int, int&gt;&gt; a;        for(int i = 0; i&lt; nums.size();i++) a.push_back({nums[i], i});        sort(a.begin(),a.end());  //升序，nlogn        for(int i = 0, j = 0; i&lt;a.size(); i++){    //O(2n)            while(a[i].first + a[j].first &lt; target) j++;            if( i != j &amp;&amp;a[i].first + a[j].first == target) {                res.push_back(a[i].second);                res.push_back(a[j].second);            }        }        sort(res.begin(), res.end());        return res;    }};</code></pre><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h4><p>Hash map</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int, int&gt; heap;    //基于散列表，查找时间为O(1)        for(int i = 0; i&lt; nums.size(); i++){            int r = target - nums[i];   //寻找目标值            if (heap.count(r)) return {heap[r], i};    //判断是否存在该键            heap[nums[i]] = i;        }        return {};    }};</code></pre><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><pre><code class="lang-c++">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="lang-c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {        ListNode* head = new ListNode(-1);        ListNode* cur = head;        int t = 0;  //进位        while(l1 || l2 || t){   //若t最后为1，需要添加一个节点            if(l1) t += l1-&gt;val, l1 = l1-&gt;next;            if(l2) t += l2-&gt;val, l2 = l2-&gt;next;            cur-&gt;next = new ListNode(t % 10);            cur = cur-&gt;next;            t /= 10;        }        return head-&gt;next;    }};</code></pre><h3 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>双指针算法.</p><p> 假设[j,i]为最长无重复字串，i向后移动时，j只能不动或向后移动。</p><pre><code class="lang-c++">class Solution {public:    int lengthOfLongestSubstring(string s) {        unordered_map&lt;char, int&gt; heap;        int res = 0;        for(int i =0, j = 0; i&lt;s.size();i++){            heap[s[i]] ++;            while(heap[s[i]] &gt; 1){                heap[s[j]] --;                j ++;            }            res = max(res, i - j + 1);        }    return res;    }};</code></pre><p>以”pwwkew”为例：</p><pre><code class="lang-c++">i = 0, j = 0, {p:1}i = 1, j = 0, {p:1, w:1}i = 2, j = 0, {p:1, w:2}     -&gt; j++, {w:2}     -&gt; j++, {w:1}i = 3, j = 2, {k:1, w:1}i = 4, j = 2, {k:1, w:1, e:1}i = 5, j = 2, {k:1, w:2, e:1}...</code></pre><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h3><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p><strong>示例 1:</strong></p><pre><code>nums1 = [1, 3]nums2 = [2]则中位数是 2.0</code></pre><p><strong>示例 2:</strong></p><pre><code>nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>思想和归并排序相同。$O(m+n)$</p><pre><code class="lang-c++">class Solution {public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        double res;        vector&lt;int&gt; r;        int i = 0 , j = 0;        while(i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()){            if(nums1[i] &lt; nums2[j]) r.push_back(nums1[i++]);            else r.push_back(nums2[j++]);        }        while(i &lt; nums1.size()) r.push_back(nums1[i++]);        while(j &lt; nums2.size()) r.push_back(nums2[j++]);        int n = nums1.size() +  nums2.size();        if(n%2 == 0)            res = double(r[n&gt;&gt;1] + r[n-1&gt;&gt;1])/2;        else res = r[n&gt;&gt;1];        return res;    }};</code></pre><h4 id="Solution-2-1"><a href="#Solution-2-1" class="headerlink" title="Solution 2"></a>Solution 2</h4>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oj好题错题集</title>
    <link href="/EruLv.github.io/2020/06/11/oj%E9%94%99%E9%A2%98%E9%9B%86/"/>
    <url>/EruLv.github.io/2020/06/11/oj%E9%94%99%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="oj好题错题集"><a href="#oj好题错题集" class="headerlink" title="oj好题错题集"></a>oj好题错题集</h1><h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1.模拟"></a>1.模拟</h2><h3 id="1-1-蚂蚁坠落"><a href="#1-1-蚂蚁坠落" class="headerlink" title="1.1 蚂蚁坠落"></a>1.1 蚂蚁坠落</h3><pre><code>https://www.nowcoder.com/practice/fdd6698014c340178a8b1f28ea5fadf8?tpId=40&amp;&amp;tqId=21420&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/kaoyan/question-ranking</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>c++ 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm排序</title>
    <link href="/EruLv.github.io/2020/06/11/Algoritm%E6%8E%92%E5%BA%8F/"/>
    <url>/EruLv.github.io/2020/06/11/Algoritm%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="基础算法-一-——排序"><a href="#基础算法-一-——排序" class="headerlink" title="基础算法(一)——排序"></a>基础算法(一)——排序</h2><h3 id="1-快排"><a href="#1-快排" class="headerlink" title="1.快排"></a>1.快排</h3><p>快排是不稳定的。</p><p>基于<strong>分治</strong>，步骤:</p><ol><li>确定分界点</li><li>调整区间，&lt;=x在x左边，&gt;=x的在x右边。</li><li>递归，左边右边排序。</li></ol><pre><code class="lang-c++">void quick_sort(int q[], int l, int r){    if(l&gt;=r) return;    int x = q[l+r&gt;&gt;1], i = l - 1, j = r + 1;    while(i &lt; j){        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);    }    quick_sort(q,l,j);    quick_sort(q,j+1,r);}</code></pre><h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h3><p>归并排序是稳定的。</p><ol><li>确定分界点。mid = (l+r)/2</li><li>递归排序left,right</li><li>归并，合二为一</li></ol><pre><code class="lang-c++">void merge_sort(int q[], int l, int r){    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法 排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algoritm模板</title>
    <link href="/EruLv.github.io/2020/06/10/Algoritm%E6%A8%A1%E6%9D%BF/"/>
    <url>/EruLv.github.io/2020/06/10/Algoritm%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="C-常用算法模板（一）"><a href="#C-常用算法模板（一）" class="headerlink" title="C++常用算法模板（一）"></a>C++常用算法模板（一）</h2><p>字符串、数字、数组的基础操作。</p><h3 id="1-反序数"><a href="#1-反序数" class="headerlink" title="1.反序数"></a>1.反序数</h3><p>1234-&gt;4321。</p><p>可用于判断数字是否对称。</p><pre><code class="lang-c++">int reverse(int x){    //反序数    int r = 0;    while(x!=0){        r *= 10;        r += x%10;        x /= 10;    }     return r;}</code></pre><h4 id="2-字符串反转"><a href="#2-字符串反转" class="headerlink" title="2.字符串反转"></a>2.字符串反转</h4><pre><code class="lang-c++">string reverse(string s){    string r = &quot;&quot;;    for(int i=s.size()-1;i&gt;=0;i--){        r += s[i];    }    return r;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法 c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT甲级1001</title>
    <link href="/EruLv.github.io/2020/05/22/PAT%E7%94%B2%E7%BA%A71001/"/>
    <url>/EruLv.github.io/2020/05/22/PAT%E7%94%B2%E7%BA%A71001/</url>
    
    <content type="html"><![CDATA[<h2 id="A-B-Format"><a href="#A-B-Format" class="headerlink" title="A+B Format"></a>A+B Format</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Calculate A + B and output the sum in standard format—hat is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where  </p><script type="math/tex; mode=display">-10^6<= a,b <= 10^6</script><p>The numbers are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="lang-c++">-1000000 9</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="lang-c++">-999,991</code></pre><h3 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution:"></a>My Solution:</h3><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    int a,b;    cin&gt;&gt;a&gt;&gt;b;    int r = a+b;    if(r==0){        cout&lt;&lt;0&lt;&lt;endl;        return 0;    }    int flag = r/abs(r);    if(flag==-1)        cout&lt;&lt;&quot;-&quot;;    string s = to_string(abs(r));    int j = 3-s.size()%3;    bool f = j==0;    for(int i=0;i&lt;s.size();i++){        if((i+j)%3==0 &amp;&amp; i!=0){             cout&lt;&lt;&quot;,&quot;;        }        cout&lt;&lt;s[i];    }    cout&lt;&lt;endl;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>字符串处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/EruLv.github.io/2020/05/22/test/"/>
    <url>/EruLv.github.io/2020/05/22/test/</url>
    
    <content type="html"><![CDATA[<h1 id="This-is-a-test"><a href="#This-is-a-test" class="headerlink" title="This is a test."></a>This is a test.</h1><p><img src="/EruLv.github.io/2020/05/22/test/test1.jpg" srcset="/EruLv.github.io/img/loading.gif" alt="test1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp常用函数</title>
    <link href="/EruLv.github.io/2020/03/19/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/EruLv.github.io/2020/03/19/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="c-常用函数"><a href="#c-常用函数" class="headerlink" title="c++常用函数"></a>c++常用函数</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort:"></a>sort:</h4><p>头文件:</p><pre><code class="lang-c++">#include&lt;algorithm&gt;</code></pre><p>使用方法:</p><pre><code class="lang-c++">void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></pre><p>（1）第一个参数first：是要排序的数组的起始地址。</p><p>（2）第二个参数last：是结束的地址（最后一个数据的后一个数据的地址）</p><p>（3）第三个参数comp是排序的方法：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是<strong>从小到大</strong>排序。</p><h4 id="qsort"><a href="#qsort" class="headerlink" title="qsort:"></a>qsort:</h4><pre><code class="lang-c++">void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</code></pre><ul><li><p><strong>base</strong> — 指向要排序的数组的第一个元素的指针。</p></li><li><p><strong>nitems</strong> — 由 base 指向的数组中元素的个数。</p></li><li><p><strong>size</strong> — 数组中每个元素的大小，以字节为单位。</p></li><li><p><strong>compar</strong> — 用来比较两个元素的函数。</p></li></ul><h3 id="2-输出保留小数后几位"><a href="#2-输出保留小数后几位" class="headerlink" title="2.输出保留小数后几位"></a>2.输出保留小数后几位</h3><p>头文件:</p><pre><code class="lang-c++">#include&lt;iomanip&gt;</code></pre><p>需要补零:</p><pre><code class="lang-c++">cout&lt;&lt;fixed&lt;&lt;setprecision(需要精确到小数点后几位)&lt;&lt;ans&lt;&lt;endl;</code></pre><p>不需要补零:</p><pre><code class="lang-c++">cout&lt;&lt;setprecision(需要精确到小数点后几位)&lt;&lt;ans&lt;&lt;endl;</code></pre><p><strong>推荐</strong>：更简单的方法:使用printf()</p><pre><code class="lang-c++">float d = 0.235;printf(&quot;%.5f\n&quot;,d);</code></pre><p>结果:0.23500</p><pre><code class="lang-c++">float d = 0.235;printf(&quot;%.2f\n&quot;,d);</code></pre><p>结果: 0.23</p><h3 id="3-格式化输出-日期"><a href="#3-格式化输出-日期" class="headerlink" title="3.格式化输出(日期)"></a>3.格式化输出(日期)</h3><pre><code class="lang-c++">printf(&quot;%04d-%02d-%02d\n&quot;,yyyy,mm,dd);</code></pre><p>会右对齐左补0.</p><h3 id="4-全局变量声明"><a href="#4-全局变量声明" class="headerlink" title="4.全局变量声明"></a>4.全局变量声明</h3><p>声明的int 的全局变量，数组会默认初始化为0.</p><h3 id="5-无限大与无限小-inf"><a href="#5-无限大与无限小-inf" class="headerlink" title="5.无限大与无限小(inf)"></a>5.无限大与无限小(inf)</h3><pre><code class="lang-c++">int inf = 1e9;//更好的: int最大2^31 - 1, 约等于10^9。int inf = 0x3f3f3f3f;</code></pre><h3 id="6-string与int互转"><a href="#6-string与int互转" class="headerlink" title="6.string与int互转"></a>6.string与int互转</h3><p>atoi:(表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。</p><pre><code class="lang-c++">string s = &quot;123&quot;;int x = atoi(s.c_str());cout&lt;&lt;x&lt;&lt;endl;</code></pre><p>int转字符串</p><pre><code class="lang-c++">#include&lt;string&gt;string s = &quot;&quot;;int x = 5;s = to_string(x);</code></pre><p>c</p><h3 id="7-输入带空格的字符串"><a href="#7-输入带空格的字符串" class="headerlink" title="7.输入带空格的字符串"></a>7.输入带空格的字符串</h3><pre><code class="lang-c++">#include&lt;string.h&gt;char str[1000];gets(str);int len = strlen(str);</code></pre><p>or</p><pre><code class="lang-c++">#include&lt;string&gt;string str;getline(cin , str);cout&lt;&lt;str&lt;&lt;endl;</code></pre><h3 id="8-清空数组"><a href="#8-清空数组" class="headerlink" title="8.清空数组"></a>8.清空数组</h3><p>memset函数</p><pre><code class="lang-c++">#include &lt;cstring&gt;const int N = 128;int hs[N];int main(){    hs[0] = 5;    cout&lt;&lt;hs[0]&lt;&lt;endl;    memset(hs, 0 , sizeof(hs));    cout&lt;&lt;hs[0]&lt;&lt;endl;    return 0;}</code></pre><h3 id="9-分词"><a href="#9-分词" class="headerlink" title="9. 分词"></a>9. 分词</h3><pre><code class="lang-c++">    //分词    s += &quot; &quot;;    string tmp = &quot;&quot;;    int m = 0;    for(int i = 0; i &lt; s.size(); i++){        if(s[i] == &#39; &#39;){            w[m++] = tmp;            tmp = &quot;&quot;;        }        else{            tmp += s[i];        }    }</code></pre><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵求导运算</title>
    <link href="/EruLv.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E8%BF%90%E7%AE%97/"/>
    <url>/EruLv.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵求导运算推导与总结"><a href="#矩阵求导运算推导与总结" class="headerlink" title="矩阵求导运算推导与总结"></a>矩阵求导运算推导与总结</h2><h3 id="1-标量对向量求导"><a href="#1-标量对向量求导" class="headerlink" title="1.标量对向量求导"></a>1.标量对向量求导</h3><p>输入向量，输出标量。即映射关系为$f:R^N➡R$ 。</p><p>设$y = f(\boldsymbol{x})$ ,$\boldsymbol{x}$是Nx1的矢量，y是标量。</p><p>则求导结果为:</p><script type="math/tex; mode=display">\frac{\partial y}{\partial \boldsymbol{x}}=\left(\frac{\partial y}{\partial x_{1}}, \frac{\partial y}{\partial x_{2}}, \ldots, \frac{\partial y}{\partial x_{N}}\right)</script><h3 id="2-向量对向量求导"><a href="#2-向量对向量求导" class="headerlink" title="2.向量对向量求导"></a>2.向量对向量求导</h3><p>输入向量，输出也是向量，则需要用到 Jacobian矩阵。</p><p>假设映射关系为$f:R^N➡R^M$ ,输入输出都为向量。$\boldsymbol{y} = f(\boldsymbol{x})$ ,则有:</p><script type="math/tex; mode=display">\frac{\partial y}{\partial x}=\left(\begin{array}{ccc}\frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{1}}{\partial x_{N}} \\\vdots & \ddots & \vdots \\\frac{\partial y_{M}}{\partial x_{1}} & \cdots & \frac{\partial y_{M}}{\partial x_{N}}\end{array}\right)</script><p>输出MxN的矩阵。</p><script type="math/tex; mode=display">\left(\frac{\partial \boldsymbol{y}}{\partial \boldsymbol{x}}\right)_{i j}=\frac{\partial y_{i}}{\partial x_{j}}</script><h4 id="2-1-x-为列向量"><a href="#2-1-x-为列向量" class="headerlink" title="2.1$x$为列向量"></a>2.1$x$为列向量</h4><p>假如$W$ 是一个NxM的矩阵，$\boldsymbol{z}=\boldsymbol{W}\boldsymbol{x}$ ，$\boldsymbol{x}$为Mx1的列向量，$\boldsymbol{z}$为Nx1的列向量,Jacobian矩阵为NxM维。</p><script type="math/tex; mode=display">z_{i}=\sum_{k=1}^{m} W_{i k} x_{k}</script><script type="math/tex; mode=display">\left(\frac{\partial \boldsymbol{z}}{\partial \boldsymbol{x}}\right)_{i j}=\frac{\partial z_{i}}{\partial x_{j}}=\frac{\partial}{\partial x_{j}} \sum_{k=1}^{m} W_{i k} x_{k}=\sum_{k=1}^{m} W_{i k} \frac{\partial}{\partial x_{j}} x_{k}=W_{i j}</script><p>所以</p><script type="math/tex; mode=display">\frac{\partial{\boldsymbol{z}}}{\partial{\boldsymbol{x}}} = \boldsymbol{W}</script><h4 id="2-2-x-为行向量"><a href="#2-2-x-为行向量" class="headerlink" title="2.2 $x$为行向量"></a>2.2 $x$为行向量</h4><p>假设有$\boldsymbol{z}=\boldsymbol{x}\boldsymbol{W}$ ，$\boldsymbol{x}$为1xN的列向量，$\boldsymbol{z}$为1xM的列向量.W维度为NxM,Jacobian矩阵为MxN.</p><script type="math/tex; mode=display">\frac{\partial{\boldsymbol{z}}}{\partial{\boldsymbol{x}}} = \boldsymbol{W^T}</script><h3 id="3-向量对矩阵求导"><a href="#3-向量对矩阵求导" class="headerlink" title="3.向量对矩阵求导"></a>3.向量对矩阵求导</h3>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
