<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java基础4</title>
    <link href="/EruLv.github.io/2020/10/04/java%E5%9F%BA%E7%A1%804/"/>
    <url>/EruLv.github.io/2020/10/04/java%E5%9F%BA%E7%A1%804/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础4"><a href="#java基础4" class="headerlink" title="java基础4"></a>java基础4</h1><h2 id="19-类型信息-反射机制"><a href="#19-类型信息-反射机制" class="headerlink" title="19.类型信息(反射机制)"></a>19.类型信息(反射机制)</h2><blockquote><p>RTTI（RunTime Type Information，运行时类型信息）能够在程序运行时发现和使用类型信息</p></blockquote><ol><li>“传统的” RTTI：假定我们在编译时已经知道了所有的类型；</li><li>“反射”机制：允许我们在运行时发现和使用类的信息</li></ol><h3 id="1-RTTI"><a href="#1-RTTI" class="headerlink" title="1.RTTI"></a>1.RTTI</h3><p>在 Java 中，所有类型转换的正确性检查都是在<strong>运行时进行</strong>的。这也正是 RTTI 的含义所在：在运行时，识别一个对象的类型。</p><pre><code class="lang-java">// typeinfo/Shapes.javaimport java.util.stream.*;abstract class Shape {    void draw() { System.out.println(this + &quot;.draw()&quot;); }    @Override    public abstract String toString();}class Circle extends Shape {    @Override    public String toString() { return &quot;Circle&quot;; }}class Square extends Shape {    @Override    public String toString() { return &quot;Square&quot;; }}class Triangle extends Shape {    @Override    public String toString() { return &quot;Triangle&quot;; }}public class Shapes {    public static void main(String[] args) {        Stream.of(            new Circle(), new Square(), new Triangle())            .forEach(Shape::draw);    }}</code></pre><p>在这个例子中，类型转换并不彻底：<code>Object</code> 被转型为 <code>Shape</code> ，而不是 <code>Circle</code>、<code>Square</code> 或者 <code>Triangle</code>。这是因为目前我们只能确保这个 <code>Stream&lt;Shape&gt;</code> 保存的都是 <code>Shape</code>：</p><ul><li>编译期，<code>stream</code> 和 Java 泛型系统确保放入 <code>stream</code> 的都是 <code>Shape</code> 对象（<code>Shape</code> 子类的对象也可视为 <code>Shape</code> 的对象），否则编译器会报错；</li><li>运行时，自动类型转换确保了从 <code>stream</code> 中取出的对象都是 <code>Shape</code> 类型。</li></ul><p>接下来就是多态机制的事了，<code>Shape</code> 对象实际执行什么样的代码，是由引用所指向的具体对象（<code>Circle</code>、<code>Square</code> 或者 <code>Triangle</code>）决定的。</p><h3 id="2-Class对象"><a href="#2-Class对象" class="headerlink" title="2.Class对象"></a>2.Class对象</h3><p>类是程序的一部分，每个类都有一个 <code>Class</code> 对象。换言之，每当我们编写并且编译了一个新类，就会产生一个 <code>Class</code> 对象（更恰当的说，是被保存在一个同名的 <code>.class</code> 文件中）。为了生成这个类的对象，Java 虚拟机 (JVM) 先会调用”类加载器”子系统把这个类加载到内存中。</p><p>所有的类都是第一次使用时动态加载到 JVM 中的，当程序创建<strong>第一个对类的静态成员的引用时</strong>，就会加载这个类。</p><blockquote><p>其实构造器也是类的静态方法，虽然构造器前面并没有 <code>static</code> 关键字。所以，使用 <code>new</code> 操作符创建类的新对象，这个操作也算作对类的静态成员引用。</p></blockquote><p>因此，Java 程序在它开始运行之前并没有被完全加载，很多部分是在需要时才会加载。这一点与许多传统编程语言不同，动态加载使得 Java 具有一些静态加载语言（如 C++）很难或者根本不可能实现的特性。</p><p>类加载器首先会检查这个类的 <code>Class</code> 对象是否已经加载，如果尚未加载，默认的类加载器就会根据类名查找 <code>.class</code> 文件（如果有附加的类加载器，这时候可能就会在数据库中或者通过其它方式获得字节码）。这个类的字节码被加载后，JVM 会对其进行验证，确保它没有损坏，并且不包含不良的 Java 代码(这是 Java 安全防范的一种措施)。</p><pre><code class="lang-java">// typeinfo/SweetShop.java// 检查类加载器工作方式class Cookie {    static { System.out.println(&quot;Loading Cookie&quot;); }}class Gum {    static { System.out.println(&quot;Loading Gum&quot;); }}class Candy {    static { System.out.println(&quot;Loading Candy&quot;); }}public class SweetShop {    public static void main(String[] args) {        System.out.println(&quot;inside main&quot;);        new Candy();        System.out.println(&quot;After creating Candy&quot;);        try {            Class.forName(&quot;Gum&quot;);        } catch(ClassNotFoundException e) {            System.out.println(&quot;Couldn&#39;t find Gum&quot;);        }        System.out.println(&quot;After Class.forName(\&quot;Gum\&quot;)&quot;);        new Cookie();        System.out.println(&quot;After creating Cookie&quot;);    }}</code></pre><pre><code>inside mainLoading CandyAfter creating CandyLoading GumAfter Class.forName(&quot;Gum&quot;)Loading CookieAfter creating Cookie</code></pre><p>从输出中可以看到，<code>Class</code> 对象<strong>仅在需要的时候才会被加载</strong>，<code>static</code> 初始化是在类加载时进行的。</p><pre><code>Class.forName(&quot;Gum&quot;);</code></pre><p><code>forName()</code> 是 <code>Class</code> 类的一个静态方法，我们可以使用 <code>forName()</code> 根据目标类的类名（<code>String</code>）得到该类的 <code>Class</code> 对象。上面的代码忽略了 <code>forName()</code> 的返回值，因为那个调用是为了得到它产生的“副作用”。从结果可以看出，<code>forName()</code> 执行的副作用是如果 <code>Gum</code> 类没有被加载就加载它，而在加载的过程中，<code>Gum</code> 的 <code>static</code> 初始化块被执行了。</p><p>无论何时，只要你想在运行时使用类型信息，就必须先得到那个 <code>Class</code> 对象的引用。<code>Class.forName()</code> 就是实现这个功能的一个便捷途径，因为使用该方法你不需要先持有这个类型 的对象。但是，如果你已经拥有了目标类的对象，那就可以通过调用 <code>getClass()</code> 方法来获取 <code>Class</code> 引用了，这个方法来自根类 <code>Object</code>，它将返回表示该对象实际类型的 <code>Class</code> 对象的引用。</p>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础3</title>
    <link href="/EruLv.github.io/2020/10/03/java%E5%9F%BA%E7%A1%803/"/>
    <url>/EruLv.github.io/2020/10/03/java%E5%9F%BA%E7%A1%803/</url>
    
    <content type="html"><![CDATA[<h1 id="java基础3"><a href="#java基础3" class="headerlink" title="java基础3"></a>java基础3</h1><h2 id="13-异常"><a href="#13-异常" class="headerlink" title="13.异常"></a>13.异常</h2><p>当抛出异常后，有几件事会随之发生。首先，同 Java 中其他对象的创建一样，将<strong>使用 new 在堆上创建异常对象</strong>。然后，当前的执行路径（它不能继续下去了）被终止，并且从当前环境中弹出对异常对象的引用。此时，<strong>异常处理机制接管程序</strong>，并开始寻找一个恰当的地方来继续执行程序。这个恰当的地方就是异常处理程序，它的任务是将程序从错误状态中恢复，以使程序能要么换一种方式运行，要么继续运行下去。</p><p>与使用 Java 中的其他对象一样，我们总是用 new 在堆上创建异常对象，这也伴随着存储空间的分配和构造器的调用。所有标准异常类都有两个java构造器：一个是无参构造器；另一个是接受字符串作为参数，以便能把相关信息放入异常对象的构造器：</p><pre><code class="lang-java">if(t == null)    throw new NullPointerException();</code></pre><pre><code class="lang-java">throw new NullPointerException(&quot;t = null&quot;);</code></pre><h3 id="1-异常捕获"><a href="#1-异常捕获" class="headerlink" title="1.异常捕获"></a>1.异常捕获</h3><pre><code class="lang-java">try {    // Code that might generate exceptions} catch(Type1 id1) {    // Handle exceptions of Type1} catch(Type2 id2) {    // Handle exceptions of Type2} catch(Type3 id3) {    // Handle exceptions of Type3}// etc.</code></pre><p>异常处理程序必须紧跟在 try 块之后。当异常被抛出时，异常处理机制将负责搜寻参数与异常类型相匹配的第一个处理程序。然后进入 catch 子句执行，此时认为异常得到了处理。一旦 catch 子句结束，则处理程序的查找过程结束。注意，只有匹配的 catch 子句才能得到执行；这与 switch 语句不同，switch 语句需要在每一个 case 后面跟一个 break，以避免执行后续的 case 子句。</p><h3 id="2-自定义异常"><a href="#2-自定义异常" class="headerlink" title="2.自定义异常"></a>2.自定义异常</h3><p>要自己定义异常类，必须从已有的异常类继承，最好是选择意思相近的异常类继承（不过这样的异常并不容易找）。建立新的异常类型最简单的方法就是让编译器为你产生无参构造器，所以这几乎不用写多少代码：</p><pre><code class="lang-java">class SimpleException extends Exception {}    //自定义异常public class InheritingExceptions {  public void f() throws SimpleException {    System.out.println(      &quot;Throw SimpleException from f()&quot;);    throw new SimpleException();  }  public static void main(String[] args) {    InheritingExceptions sed = new InheritingExceptions();    try {      sed.f();    } catch(SimpleException e) {      System.out.println(&quot;Caught it!&quot;);    }  }}/* Output:Throw SimpleException from f()Caught it!*/</code></pre><p>你也可以为异常类创建一个接受字符串参数的构造器：</p><p>使用<code>e.printStackTrace(System.out);</code>来打印异常。</p><pre><code class="lang-java">class MyException extends Exception {  MyException() {}  MyException(String msg) { super(msg); }}public class FullConstructors {  public static void f() throws MyException {    System.out.println(&quot;Throwing MyException from f()&quot;);    throw new MyException();  }  public static void g() throws MyException {    System.out.println(&quot;Throwing MyException from g()&quot;);    throw new MyException(&quot;Originated in g()&quot;);  }  public static void main(String[] args) {    try {      f();    } catch(MyException e) {      e.printStackTrace(System.out);    }    try {      g();    } catch(MyException e) {      e.printStackTrace(System.out);    }  }}/* Output:Throwing MyException from f()MyException        at FullConstructors.f(FullConstructors.java:11)        atFullConstructors.main(FullConstructors.java:19)Throwing MyException from g()MyException: Originated in g()        at FullConstructors.g(FullConstructors.java:15)        atFullConstructors.main(FullConstructors.java:24)*/</code></pre><p>在异常处理程序中，调用了在 Throwable 类声明（Exception 即从此类继承）的 printStackTrace() 方法。就像从输出中看到的，它将打印“从方法调用处直到异常抛出处”的方法调用序列。这里，信息被发送到了 System.out，并自动地被捕获和显示在输出中。但是，如果调用默认版本：</p><pre><code class="lang-java">e.printStackTrace();</code></pre><p>信息就会被输出到标准错误流(红色的)。</p><pre><code class="lang-java">import java.util.logging.*;import java.io.*;class LoggingException extends Exception {  private static Logger logger =    Logger.getLogger(&quot;LoggingException&quot;);  LoggingException() {    StringWriter trace = new StringWriter();    printStackTrace(new PrintWriter(trace));    logger.severe(trace.toString());  }}public class LoggingExceptions {  public static void main(String[] args) {    try {      throw new LoggingException();    } catch(LoggingException e) {      System.err.println(&quot;Caught &quot; + e);    }    try {      throw new LoggingException();    } catch(LoggingException e) {      System.err.println(&quot;Caught &quot; + e);    }  }}/* Output:___[ Error Output ]___May 09, 2017 6:07:17 AM LoggingException &lt;init&gt;SEVERE: LoggingException        atLoggingExceptions.main(LoggingExceptions.java:20)Caught LoggingExceptionMay 09, 2017 6:07:17 AM LoggingException &lt;init&gt;SEVERE: LoggingException        atLoggingExceptions.main(LoggingExceptions.java:25)Caught LoggingException*/</code></pre><p>静态的 Logger.getLogger() 方法创建了一个 String 参数相关联的 Logger 对象（通常与错误相关的包名和类名），这个 Logger 对象会将其输出发送到 System.err。</p><p>向 Logger 写入的最简单方式就是直接调用与日志记录消息的级别相关联的方法，这里使用的是 severe()，表示异常的级别。</p><p>各级别按降序排列如下：</p><ul><li>SEVERE（最高值）</li><li>WARNING</li><li>INFO</li><li>CONFIG</li><li>FINE</li><li>FINER</li><li>FINEST（最低值）</li></ul><p>另外，自定义异常可以添加构造器和重写<code>getMessage()</code>方法，类似于<code>toString()</code>。</p><h3 id="3-异常声明"><a href="#3-异常声明" class="headerlink" title="3.异常声明"></a>3.异常声明</h3><p>异常声明告知程序员某个方法可能会抛出的异常类型。异常说明使用了附加的关键字 throws，后面接一个所有潜在异常类型的列表，所以方法定义可能看起来像这样：</p><pre><code class="lang-java">void f() throws TooBig, TooSmall, DivZero { // ...</code></pre><p>代码必须与异常说明保持一致。如果方法里的代码产生了异常却没有进行处理，编译器会发现这个问题并提醒你：要么处理这个异常，要么就在异常说明中表明此方法将产生异常。通过这种自顶向下强制执行的异常说明机制，Java 在编译时就可以保证一定水平的异常正确性。</p><p>可以声明可能抛出的异常但实际却并没有该异常，相当于为异常占个位子。在定义抽象基类和接口时这种能力很重要，这样派生类或接口实现就能够抛出这些预先声明的异常。</p><h3 id="4-异常捕获"><a href="#4-异常捕获" class="headerlink" title="4.异常捕获"></a>4.异常捕获</h3><p>可以<code>catch</code>异常基类Exception来捕获所有类型异常。</p><pre><code class="lang-java">catch(Exception e) {    System.out.println(&quot;Caught an exception&quot;);}</code></pre><p>这将捕获所有异常，所以最好把它放在处理程序列表的末尾，以防它抢在其他处理程序之前先把异常捕获了。</p><p><code>Exception</code>继承<code>Throwable</code>,主要有两个获取异常信息的方法:</p><pre><code class="lang-java">String getMessage()String getLocalizedMessage()</code></pre><pre><code class="lang-java">public class ExceptionMethods {  public static void main(String[] args) {    try {      throw new Exception(&quot;My Exception&quot;);    } catch(Exception e) {      System.out.println(&quot;Caught Exception&quot;);      System.out.println(        &quot;getMessage():&quot; + e.getMessage());      System.out.println(&quot;getLocalizedMessage():&quot; +        e.getLocalizedMessage());      System.out.println(&quot;toString():&quot; + e);      System.out.println(&quot;printStackTrace():&quot;);      e.printStackTrace(System.out);    }  }}/* Output:Caught ExceptiongetMessage():My ExceptiongetLocalizedMessage():My ExceptiontoString():java.lang.Exception: My ExceptionprintStackTrace():java.lang.Exception: My Exception        atExceptionMethods.main(ExceptionMethods.java:7)*/</code></pre><p>可以发现每个方法都比前一个提供了更多的信息一一实际上它们每一个都是前一个的超集。</p><p><strong>多重捕获</strong></p><p>java7 之前的写法:</p><pre><code class="lang-java">class EBase1 extends Exception {}class Except1 extends EBase1 {}class EBase2 extends Exception {}class Except2 extends EBase2 {}class EBase3 extends Exception {}class Except3 extends EBase3 {}class EBase4 extends Exception {}class Except4 extends EBase4 {}public class SameHandler {  void x() throws Except1, Except2, Except3, Except4 {}  void process() {}  void f() {    try {      x();    } catch(Except1 e) {      process();    } catch(Except2 e) {      process();    } catch(Except3 e) {      process();    } catch(Except4 e) {      process();    }  }}</code></pre><p>java7 加入了多重捕获机制,你可以使用“或”将不同类型的异常组合起来，只需要一行 catch 语句：:</p><pre><code class="lang-java">// exceptions/MultiCatch.javapublic class MultiCatch {    void x() throws Except1, Except2, Except3, Except4 {}    void process() {}    void f() {        try {            x();        } catch(Except1 | Except2 | Except3 | Except4 e) {            process();        }    }}</code></pre><pre><code class="lang-java">// exceptions/MultiCatch2.javapublic class MultiCatch2 {    void x() throws Except1, Except2, Except3, Except4 {}    void process1() {}    void process2() {}    void f() {        try {            x();        } catch(Except1 | Except2 e) {            process1();        } catch(Except3 | Except4 e) {            process2();        }    }}</code></pre><h3 id="5-栈轨迹"><a href="#5-栈轨迹" class="headerlink" title="5.栈轨迹"></a>5.栈轨迹</h3><p>可以通过<code>e.getStackTrace()</code>来访问栈轨迹信息，你将得到一个StackTraceElement数组，可以使用<code>.getMethodName()</code>获取先后经过的方法名。</p><pre><code class="lang-java">package exceptions;// exceptions/WhoCalled.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.// Programmatic access to stack trace informationpublic class WhoCalled {  static void f() {    // Generate an exception to fill in the stack trace    try {      throw new Exception();    } catch(Exception e) {      for(StackTraceElement ste : e.getStackTrace())        System.out.println(ste.getMethodName());    }  }  static void g() { f(); }  static void h() { g(); }  public static void main(String[] args) {    f();    System.out.println(&quot;*******&quot;);    g();    System.out.println(&quot;*******&quot;);    h();  }}/* Output:fmain*******fgmain*******fghmain*/</code></pre><p>这里，我们只打印了方法名，但实际上还可以打印整个 StackTraceElement，它包含其他附加的信息。</p><h3 id="6-抛出异常"><a href="#6-抛出异常" class="headerlink" title="6.抛出异常"></a>6.抛出异常</h3><p><strong>重新抛出异常</strong></p><p>有时希望把刚捕获的异常重新抛出，尤其是在使用 Exception 捕获所有异常的时候。既然已经得到了对当前异常对象的引用，可以直接把它重新抛出,这样，他的上级也会捕获该异常：</p><pre><code class="lang-java">catch(Exception e) {    System.out.println(&quot;An exception was thrown&quot;);    throw e;}</code></pre><p>如果只是把当前异常对象重新抛出，那么 printStackTrace() 方法显示的将是<strong>原来异常抛出点的调用栈信息</strong>，而并非重新抛出点的信息。要想更新这个信息，可以调用 <strong>fillInStackTrace()</strong> 方法，这将返回一个 Throwable 对象，它是通过把当前调用栈信息填入原来那个异常对象而建立的，就像这样：</p><pre><code class="lang-java">package exceptions;// exceptions/Rethrowing.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.// Demonstrating fillInStackTrace()public class Rethrowing {  public static void f() throws Exception {    System.out.println(      &quot;originating the exception in f()&quot;);    throw new Exception(&quot;thrown from f()&quot;);  }  public static void g() throws Exception {    try {      f();    } catch(Exception e) {      System.out.println(        &quot;Inside g(), e.printStackTrace()&quot;);      e.printStackTrace(System.out);      throw e;    }  }  public static void h() throws Exception {    try {      f();    } catch(Exception e) {      System.out.println(        &quot;Inside h(), e.printStackTrace()&quot;);      e.printStackTrace(System.out);      throw (Exception)e.fillInStackTrace();    //此时，上级从这里捕获，这个地方变成了异常的新发地    }  }  public static void main(String[] args) {    try {      g();    } catch(Exception e) {      System.out.println(&quot;main: printStackTrace()&quot;);      e.printStackTrace(System.out);    }    System.out.println(&quot;-----------------&quot;);    try {      h();    } catch(Exception e) {      System.out.println(&quot;main: printStackTrace()&quot;);      e.printStackTrace(System.out);    }  }}/* Output:originating the exception in f()Inside g(), e.printStackTrace()java.lang.Exception: thrown from f()        at Rethrowing.f(Rethrowing.java:8)        at Rethrowing.g(Rethrowing.java:12)        at Rethrowing.main(Rethrowing.java:32)main: printStackTrace()java.lang.Exception: thrown from f()        at Rethrowing.f(Rethrowing.java:8)        at Rethrowing.g(Rethrowing.java:12)        at Rethrowing.main(Rethrowing.java:32)originating the exception in f()Inside h(), e.printStackTrace()java.lang.Exception: thrown from f()        at Rethrowing.f(Rethrowing.java:8)        at Rethrowing.h(Rethrowing.java:22)        at Rethrowing.main(Rethrowing.java:38)main: printStackTrace()java.lang.Exception: thrown from f()        at Rethrowing.h(Rethrowing.java:27)        at Rethrowing.main(Rethrowing.java:38)*/</code></pre><p>有可能在捕获异常之后抛出<strong>另一种异常</strong>。这么做的话，得到的效果类似于使用 fillInStackTrace()，有关原来异常发生点的信息会丢失，剩下的是与新的抛出点有关的信息。</p><p>java7以后，异常可以被他的基类捕获。</p><h3 id="7-异常链"><a href="#7-异常链" class="headerlink" title="7.异常链"></a>7.异常链</h3><p>常常会想要在捕获一个异常后抛出另一个异常，并且希望把原始异常的信息保存下来，这被称为异常链。 Throwable 的子类在构造器中都可以接受一个 cause（因由）对象作为参数。这个 cause 就用来表示原始异常，这样通过把原始异常传递给新的异常，使得即使在当前位置创建并抛出了新的异常，也能通过这个异常链追踪到异常最初发生的位置。</p><p>有趣的是，在 Throwable 的子类中，只有三种基本的异常类提供了带 cause 参数的构造器。它们是 Error（用于 Java 虚拟机报告系统错误）、Exception 以及 RuntimeException。如果要把其他类型的异常链接起来，应该使用 initCause() 方法而不是构造器。</p><h3 id="8-java标准异常"><a href="#8-java标准异常" class="headerlink" title="8.java标准异常"></a>8.java标准异常</h3><p>Throwable 这个 Java 类被用来表示任何可以作为异常被抛出的类。Throwable 对象可分为两种类型（指从 Throwable 继承而得到的类型）：</p><p>Error 用来表示编译时和系统错误（除特殊情况外，一般不用你关心）；Exception 是可以被抛出的基本类型，在 Java 类库、用户方法以及运行时故障中都可能抛出 Exception 型异常。</p><p>异常并非全是在 java.lang 包里定义的；有些异常是用来支持其他像 util、net 和 io 这样的程序包，这些异常可以通过它们的完整名称或者从它们的父类中看出端倪。比如，所有的输入/输出异常都是从 java.io.IOException 继承而来的。</p><p><strong>RuntimeException</strong></p><p>有的异常不必你手写，比如检查每个对象的引用是否为空，空指针异常。属于运行时异常的类型有很多，它们被 java 自动抛出，所以不必在异常说明中把它们列出来。非常方便的是，通过将这些异常设置为 <code>RuntimeException</code>的子类而把它们归类起来，这是继承的一个绝佳例子：建立具有相同特征和行为的一组类型。</p><p>RuntimeException 代表的是编程错误：</p><ol><li>无法预料的错误。比如从你控制范围之外传递进来的 null 引用。</li><li>作为程序员，应该在代码中进行检查的错误。（比如对于 ArrayIndexOutOfBoundsException，就得注意一下数组的大小了。）在一个地方发生的异常，常常会在另一个地方导致错误。</li></ol><p>如果 RuntimeException 没有被捕获而直达 main()，那么在程序退出前将调用异常的 printStackTrace() 方法。</p><pre><code class="lang-java">public class NeverCaught {  static void f() {    throw new RuntimeException(&quot;From f()&quot;);  }  static void g() {    f();  }  public static void main(String[] args) {    g();  }}/* Output:___[ Error Output ]___Exception in thread &quot;main&quot; java.lang.RuntimeException:From f()        at NeverCaught.f(NeverCaught.java:7)        at NeverCaught.g(NeverCaught.java:10)        at NeverCaught.main(NeverCaught.java:13)*/</code></pre><p>请务必记住：代码中只有 RuntimeException（及其子类）类型的异常可以被忽略，因为编译器强制要求处理所有受检查类型的异常。</p><h3 id="9-finally"><a href="#9-finally" class="headerlink" title="9.finally"></a>9.finally</h3><p>有一些代码片段，可能会希望<strong>无论 try 块中的异常是否抛出，它们都能得到执行。</strong>这通常适用于内存回收之外的情况（因为回收由垃圾回收器完成），为了达到这个效果，可以在异常处理程序后面加上 finally 子句。完整的异常处理程序看起来像这样：</p><pre><code class="lang-java">try {// The guarded region: Dangerous activities// that might throw A, B, or C} catch(A a1) {// Handler for situation A} catch(B b1) {// Handler for situation B} catch(C c1) {// Handler for situation C} finally {// Activities that happen every time}</code></pre><p>finally的另类用法,在return后使用finally:</p><pre><code class="lang-java">package exceptions;// exceptions/MultipleReturns.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.public class MultipleReturns {  public static void f(int i) {    System.out.println(      &quot;Initialization that requires cleanup&quot;);    try {      System.out.println(&quot;Point 1&quot;);      if(i == 1) return;      System.out.println(&quot;Point 2&quot;);      if(i == 2) return;      System.out.println(&quot;Point 3&quot;);      if(i == 3) return;      System.out.println(&quot;End&quot;);      return;    } finally {      System.out.println(&quot;Performing cleanup&quot;);    }  }  public static void main(String[] args) {    for(int i = 1; i &lt;= 4; i++)      f(i);  }}/* Output:Initialization that requires cleanupPoint 1Performing cleanupInitialization that requires cleanupPoint 1Point 2Performing cleanupInitialization that requires cleanupPoint 1Point 2Point 3Performing cleanupInitialization that requires cleanupPoint 1Point 2Point 3EndPerforming cleanup*/</code></pre><p>从输出中可以看出，从何处返回无关紧要，finally 子句永远会执行。</p><h3 id="10-异常丢失"><a href="#10-异常丢失" class="headerlink" title="10.异常丢失"></a>10.异常丢失</h3><p>遗憾的是，Java 的异常实现也有瑕疵。异常作为程序出错的标志，决不应该被忽略，但它还是有可能被轻易地忽略。用某些特殊的方式使用 finally 子句，就会发生这种情况：</p><pre><code class="lang-java">// exceptions/LostMessage.java// How an exception can be lostclass VeryImportantException extends Exception {    @Override    public String toString() {        return &quot;A very important exception!&quot;;    }}class HoHumException extends Exception {    @Override    public String toString() {        return &quot;A trivial exception&quot;;    }}public class LostMessage {    void f() throws VeryImportantException {        throw new VeryImportantException();    }    void dispose() throws HoHumException {        throw new HoHumException();    }    public static void main(String[] args) {        try {            LostMessage lm = new LostMessage();            try {                lm.f();    //该异常丢失            } finally {                lm.dispose();            }        } catch(VeryImportantException | HoHumException e) {            System.out.println(e);        }    }}//A trivial exception</code></pre><h3 id="11-异常限制"><a href="#11-异常限制" class="headerlink" title="11.异常限制"></a>11.异常限制</h3><p>在抽线基类和接口中定义抛出的异常，可以限制子类只能抛出已经声明的异常。</p><pre><code class="lang-java">class BaseballException extends Exception {}class Foul extends BaseballException {}class Strike extends BaseballException {}abstract class Inning {  Inning() throws BaseballException {}  public void event() throws BaseballException {    // Doesn&#39;t actually have to throw anything  }  public abstract void atBat() throws Strike, Foul;  public void walk() {} // Throws no checked exceptions}class StormException extends Exception {}class RainedOut extends StormException {}class PopFoul extends Foul {}interface Storm {  void event() throws RainedOut;  void rainHard() throws RainedOut;}</code></pre><h3 id="12-Try-With-Resources用法"><a href="#12-Try-With-Resources用法" class="headerlink" title="12.Try-With-Resources用法"></a>12.Try-With-Resources用法</h3><p>java7前处理文件流的可能做法:</p><pre><code class="lang-java">// exceptions/MessyExceptions.javaimport java.io.*;public class MessyExceptions {    public static void main(String[] args) {        InputStream in = null;        try {            in = new FileInputStream(                    new File(&quot;MessyExceptions.java&quot;));            int contents = in.read();            // Process contents        } catch(IOException e) {            // Handle the error        } finally {            if(in != null) {                try {                    in.close();                } catch(IOException e) {                    // Handle the close() error                }            }        }    }}</code></pre><p>幸运的是，Java 7 引入了 try-with-resources 语法，它可以非常清楚地简化上面的代码：</p><pre><code class="lang-java">// exceptions/TryWithResources.javaimport java.io.*;public class TryWithResources {    public static void main(String[] args) {        try(                InputStream in = new FileInputStream(                        new File(&quot;TryWithResources.java&quot;))        ) {            int contents = in.read();            // Process contents        } catch(IOException e) {            // Handle the error        }    }}</code></pre><p>在 Java 7 之前，try 后面总是跟着一个 {，但是现在可以跟一个带括号的定义 ——这里是我们创建的 FileInputStream 对象。括号内的部分称为资源规范头（resource specification header）。现在 <code>in</code> 在整个 try 块的其余部分都是可用的。</p><p> try-with-resources 定义子句中创建的对象（在括号内）必须实现 <code>java.lang.AutoCloseable</code> 接口，这个接口只有一个方法：<code>close()</code>。查看 Javadocs 中的 AutoCloseable，可以找到所有实现该接口的类列表，其中包括 <code>Stream</code> 对象：</p><pre><code class="lang-java">// exceptions/StreamsAreAutoCloseable.javaimport java.io.*;import java.nio.file.*;import java.util.stream.*;public class StreamsAreAutoCloseable {    public static void    main(String[] args) throws IOException{        try(                Stream&lt;String&gt; in = Files.lines(                        Paths.get(&quot;StreamsAreAutoCloseable.java&quot;));                PrintWriter outfile = new PrintWriter(                        &quot;Results.txt&quot;); // [1]        ) {            in.skip(5)                    .limit(1)                    .map(String::toLowerCase)                    .forEachOrdered(outfile::println);        } // [2]    }}</code></pre><ul><li>[1] 你在这里可以看到其他的特性：资源规范头中可以包含多个定义，并且通过分号进行分割（最后一个分号是可选的）。规范头中定义的每个对象都会在 try 语句块运行结束之后调用 close() 方法。</li><li>[2] try-with-resources 里面的 try 语句块可以不包含 catch 或者 finally 语句而独立存在。在这里，IOException 被 main() 方法抛出，所以这里并不需要在 try 后面跟着一个 catch 语句块。</li></ul><p><strong>自定义AutoCloseable类</strong></p><pre><code class="lang-java">package exceptions;// exceptions/AutoCloseableDetails.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.class Reporter implements AutoCloseable {  String name = getClass().getSimpleName();  Reporter() {    System.out.println(&quot;Creating &quot; + name);  }  @Override  public void close() {    System.out.println(&quot;Closing &quot; + name);  }}class First extends Reporter {}class Second extends Reporter {}public class AutoCloseableDetails {  public static void main(String[] args) {    try(      First f = new First();      Second s = new Second()    ) {      System.out.println(&quot;do something !&quot;);    }  }}/* Output:Creating FirstCreating Seconddo something !Closing SecondClosing First*/</code></pre><p>退出 try 块会调用两个对象的 close() 方法，并以与创建顺序<strong>相反的顺序关闭它们</strong>。顺序很重要，因为在这种情况下，Second 对象可能依赖于 First 对象，因此如果 First 在第 Second 关闭时已经关闭。 Second 的 close() 方法可能会尝试访问 First 中不再可用的某些功能。</p><p>如果中间某个对象创建时异常怎么办:</p><pre><code class="lang-java">package exceptions;// exceptions/ConstructorException.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.class CE extends Exception {}class SecondExcept extends Reporter {  SecondExcept() throws CE {    super();    throw new CE();  }}public class ConstructorException {  public static void main(String[] args) {    try(      First f = new First();      SecondExcept s = new SecondExcept();      Second s2 = new Second()    ) {      System.out.println(&quot;In body&quot;);    } catch(CE e) {      System.out.println(&quot;Caught: &quot; + e);    }  }}/* Output:Creating FirstCreating SecondExceptClosing FirstCaught: CE*/</code></pre><p>正如预期的那样，First 创建时没有发生意外，SecondExcept 在创建期间抛出异常。请注意，不会为 SecondExcept 调用 close()，因为如果构造函数失败，则无法假设你可以安全地对该对象执行任何操作，包括关闭它。由于 SecondExcept 的异常，Second 对象实例 s2 不会被创建，因此也不会有清除事件发生。</p><p>如果没有构造函数抛出异常，但在 try 的主体中可能抛出异常，那么你将再次被强制要求提供一个catch 子句：</p><pre><code class="lang-java">// exceptions/BodyException.javaclass Third extends Reporter {}public class BodyException {    public static void main(String[] args) {        try(                First f = new First();                Second s2 = new Second()        ) {            System.out.println(&quot;In body&quot;);            Third t = new Third();            new SecondExcept();            System.out.println(&quot;End of body&quot;);        } catch(CE e) {            System.out.println(&quot;Caught: &quot; + e);        }    }}</code></pre><p>请注意，第 3 个对象永远不会被清除。那是因为它不是在资源规范头中创建的，所以它没有被保护。</p><p><strong>closed中抛出异常</strong></p><pre><code class="lang-java">package exceptions;// exceptions/CloseExceptions.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.class CloseException extends Exception {}class Reporter2 implements AutoCloseable {  String name = getClass().getSimpleName();  Reporter2() {    System.out.println(&quot;Creating &quot; + name);  }  public void close() throws CloseException {    System.out.println(&quot;Closing &quot; + name);  }}class Closer extends Reporter2 {  @Override  public void close() throws CloseException {    super.close();    throw new CloseException();  }}public class CloseExceptions {  public static void main(String[] args) {    try(            First f = new First();            Closer c = new Closer();            Second s = new Second()    ) {      System.out.println(&quot;In body&quot;);    } catch(CloseException e) {      System.out.println(&quot;Caught: &quot; + e);    }  }}/* Output:Creating FirstCreating CloserCreating SecondIn bodyClosing SecondClosing CloserClosing FirstCaught: CloseException*/</code></pre><p>请注意，因为所有三个对象都已创建，所以它们都以相反的顺序关闭 - 即使 Closer.close() 抛出异常也是如此。</p><h3 id="13-异常指南"><a href="#13-异常指南" class="headerlink" title="13.异常指南"></a>13.异常指南</h3><p>应该在下列情况下使用异常：</p><ol><li>尽可能使用 try-with-resource。</li><li>在恰当的级别处理问题。（在知道该如何处理的情况下才捕获异常。）</li><li>解决问题并且重新调用产生异常的方法。</li><li>进行少许修补，然后绕过异常发生的地方继续执行。</li><li>用别的数据进行计算，以代替方法预计会返回的值。</li><li>把当前运行环境下能做的事情尽量做完，然后把相同的异常重抛到更高层。</li><li>把当前运行环境下能做的事情尽量做完，然后把不同的异常抛到更高层。</li><li>终止程序。</li><li>进行简化。（如果你的异常模式使问题变得太复杂，那用起来会非常痛苦也很烦人。）</li><li>让类库和程序更安全。（这既是在为调试做短期投资，也是在为程序的健壮性做长期投资。）</li></ol><h2 id="17-文件"><a href="#17-文件" class="headerlink" title="17.文件"></a>17.文件</h2><p><strong>java.nio.file</strong> 库终于将 Java 文件操作带到与其他编程语言相同的水平。最重要的是 Java8 新增的 streams 与文件结合使得文件操作编程变得更加优雅。我们将看一下文件操作的两个基本组件：</p><ol><li>文件或者目录的路径；</li><li>文件本身。</li></ol><h3 id="1-文件和目录路径"><a href="#1-文件和目录路径" class="headerlink" title="1.文件和目录路径"></a>1.文件和目录路径</h3><p><strong>java.nio.file.Paths</strong> 类包含一个重载方法 <strong>static get()</strong>，该方法接受一系列 <strong>String</strong> 字符串或一个<em>统一资源标识符</em>(URI)作为参数，并且进行转换返回一个 <strong>Path</strong> 对象：Path对象里包含了很多有用信息:</p><pre><code class="lang-java">import java.nio.file.*;import java.net.URI;import java.io.File;import java.io.IOException;public class PathInfo {  static void show(String id, Object p) {    System.out.println(id + &quot;: &quot; + p);  }  static void info(Path p) {    show(&quot;toString&quot;, p);    //获得完整路径    show(&quot;Exists&quot;, Files.exists(p));    //文件或路径是否存在    show(&quot;RegularFile&quot;, Files.isRegularFile(p));    //是文件？    show(&quot;Directory&quot;, Files.isDirectory(p));    //是路径？    show(&quot;Absolute&quot;, p.isAbsolute());    show(&quot;FileName&quot;, p.getFileName());    //文件名    show(&quot;Parent&quot;, p.getParent());    //获得上一级目录    show(&quot;Root&quot;, p.getRoot());    //获得根目录    System.out.println(&quot;******************&quot;);  }  public static void main(String[] args) {    System.out.println(System.getProperty(&quot;os.name&quot;));    info(Paths.get(      &quot;F:\\work\\thinkinjava&quot;));    //目录    Path p = Paths.get(&quot;src\\files\\PathInfo.java&quot;);    //相对路径    info(p);    Path ap = p.toAbsolutePath();    //转换到绝对路径    info(ap);    info(ap.getParent());    try {      info(p.toRealPath());    } catch(IOException e) {      System.out.println(e);    }    URI u = p.toUri();    System.out.println(&quot;URI: &quot; + u);    Path puri = Paths.get(u);    System.out.println(Files.exists(puri));    File f = ap.toFile(); // Don&#39;t be fooled  }}</code></pre><h3 id="2-选取路径部分片段"><a href="#2-选取路径部分片段" class="headerlink" title="2.选取路径部分片段"></a>2.选取路径部分片段</h3><pre><code class="lang-java">import java.nio.file.*;public class PartsOfPaths {  public static void main(String[] args) {    System.out.println(System.getProperty(&quot;os.name&quot;));    Path p =      Paths.get(&quot;src/files/PartsOfPaths.java&quot;).toAbsolutePath();    for(int i = 0; i &lt; p.getNameCount(); i++)    //获取目录名字      System.out.println(p.getName(i));    System.out.println(&quot;ends with &#39;.java&#39;: &quot; +      p.endsWith(&quot;.java&quot;));    //后缀    for(Path pp : p) {      System.out.print(pp + &quot;: &quot;);      System.out.print(p.startsWith(pp) + &quot; : &quot;);      System.out.println(p.endsWith(pp));    }    System.out.println(&quot;Starts with &quot; + p.getRoot() +      &quot; &quot; + p.startsWith(p.getRoot()));  }}/*Windows 10workthinkinjavasrcfilesPartsOfPaths.javaends with &#39;.java&#39;: falsework: false : falsethinkinjava: false : falsesrc: false : falsefiles: false : falsePartsOfPaths.java: false : trueStarts with F:\ true*/</code></pre><p><strong>Path</strong> 也实现了 <strong>Iterable</strong> 接口，因此我们也可以通过增强的 for-each 进行遍历。请注意，即使路径以 <strong>.java</strong> 结尾，使用 <strong>endsWith()</strong> 方法也会返回 <strong>false</strong>。这是因为使用 <strong>endsWith()</strong> 比较的是整个路径部分，而不会包含文件路径的后缀。通过使用 <strong>startsWith()</strong> 和 <strong>endsWith()</strong> 也可以完成路径的遍历。但是我们可以看到，遍历 <strong>Path</strong> 对象并不包含根路径，只有使用 <strong>startsWith()</strong> 检测根路径时才会返回 <strong>true</strong>。</p><h3 id="3-路径分析"><a href="#3-路径分析" class="headerlink" title="3.路径分析"></a>3.路径分析</h3><p><strong>Files</strong> 工具类包含一系列完整的方法用于获得 <strong>Path</strong> 相关的信息。</p><pre><code class="lang-java">// files/PathAnalysis.javaimport java.nio.file.*;import java.io.IOException;public class PathAnalysis {    static void say(String id, Object result) {        System.out.print(id + &quot;: &quot;);        System.out.println(result);    }    public static void main(String[] args) throws IOException {        System.out.println(System.getProperty(&quot;os.name&quot;));        Path p = Paths.get(&quot;PathAnalysis.java&quot;).toAbsolutePath();        say(&quot;Exists&quot;, Files.exists(p));        say(&quot;Directory&quot;, Files.isDirectory(p));        say(&quot;Executable&quot;, Files.isExecutable(p));        say(&quot;Readable&quot;, Files.isReadable(p));        say(&quot;RegularFile&quot;, Files.isRegularFile(p));        say(&quot;Writable&quot;, Files.isWritable(p));        say(&quot;notExists&quot;, Files.notExists(p));        say(&quot;Hidden&quot;, Files.isHidden(p));        say(&quot;size&quot;, Files.size(p));        say(&quot;FileStore&quot;, Files.getFileStore(p));        say(&quot;LastModified: &quot;, Files.getLastModifiedTime(p));        say(&quot;Owner&quot;, Files.getOwner(p));        say(&quot;ContentType&quot;, Files.probeContentType(p));        say(&quot;SymbolicLink&quot;, Files.isSymbolicLink(p));        if(Files.isSymbolicLink(p))            say(&quot;SymbolicLink&quot;, Files.readSymbolicLink(p));        if(FileSystems.getDefault().supportedFileAttributeViews().contains(&quot;posix&quot;))            say(&quot;PosixFilePermissions&quot;,        Files.getPosixFilePermissions(p));    }}</code></pre><p><strong>Paths的增减修改</strong></p><p>我们必须能通过对 <strong>Path</strong> 对象增加或者删除一部分来构造一个新的 <strong>Path</strong> 对象。我们使用 <strong>relativize()</strong> 移除 <strong>Path</strong> 的根路径，使用 <strong>resolve()</strong> 添加 <strong>Path</strong> 的尾路径(不一定是“可发现”的名称)</p><h3 id="4-目录"><a href="#4-目录" class="headerlink" title="4.目录"></a>4.目录</h3><p> <strong>createDirectory()</strong> 创建单极路径。</p><p><strong>createTempFile()</strong> 生成一个临时文件。</p><h3 id="5-文件系统"><a href="#5-文件系统" class="headerlink" title="5.文件系统"></a>5.文件系统</h3><p>为了完整起见，我们需要一种方法查找文件系统相关的其他信息。在这里，我们使用静态的 <strong>FileSystems</strong> 工具类获取”默认”的文件系统，但你同样也可以在 <strong>Path</strong> 对象上调用 <strong>getFileSystem()</strong> 以获取创建该 <strong>Path</strong> 的文件系统。你可以获得给定 <em>URI</em> 的文件系统，还可以构建新的文件系统(对于支持它的操作系统)。</p><pre><code class="lang-java">// files/FileSystemDemo.javaimport java.nio.file.*;public class FileSystemDemo {    static void show(String id, Object o) {        System.out.println(id + &quot;: &quot; + o);    }    public static void main(String[] args) {        System.out.println(System.getProperty(&quot;os.name&quot;));        FileSystem fsys = FileSystems.getDefault();        for(FileStore fs : fsys.getFileStores())            show(&quot;File Store&quot;, fs);        for(Path rd : fsys.getRootDirectories())            show(&quot;Root Directory&quot;, rd);        show(&quot;Separator&quot;, fsys.getSeparator());        show(&quot;UserPrincipalLookupService&quot;,            fsys.getUserPrincipalLookupService());        show(&quot;isOpen&quot;, fsys.isOpen());        show(&quot;isReadOnly&quot;, fsys.isReadOnly());        show(&quot;FileSystemProvider&quot;, fsys.provider());        show(&quot;File Attribute Views&quot;,        fsys.supportedFileAttributeViews());    }}/* 输出:Windows 10File Store: SSD (C:)Root Directory: C:\Root Directory: D:\Separator: \UserPrincipalLookupService:sun.nio.fs.WindowsFileSystem$LookupService$1@15db9742isOpen: trueisReadOnly: falseFileSystemProvider:sun.nio.fs.WindowsFileSystemProvider@6d06d69cFile Attribute Views: [owner, dos, acl, basic, user]*/</code></pre><p>一个 <strong>FileSystem</strong> 对象也能生成 <strong>WatchService</strong> 和 <strong>PathMatcher</strong> 对象。</p><h3 id="6-路径监听"><a href="#6-路径监听" class="headerlink" title="6.路径监听"></a>6.路径监听</h3><p>通过 <strong>WatchService</strong> 可以设置一个进程对目录中的更改做出响应。在这个例子中，<strong>delTxtFiles()</strong> 作为一个单独的任务执行，该任务将遍历整个目录并删除以 <strong>.txt</strong> 结尾的所有文件，<strong>WatchService</strong> 会对文件删除操作做出反应：</p><pre><code class="lang-java">// files/PathWatcher.java// {ExcludeFromGradle}import java.io.IOException;import java.nio.file.*;import static java.nio.file.StandardWatchEventKinds.*;import java.util.concurrent.*;public class PathWatcher {    static Path test = Paths.get(&quot;test&quot;);    static void delTxtFiles() {        try {            Files.walk(test)            .filter(f -&gt;                f.toString()                .endsWith(&quot;.txt&quot;))                .forEach(f -&gt; {                try {                    System.out.println(&quot;deleting &quot; + f);                    Files.delete(f);                } catch(IOException e) {                    throw new RuntimeException(e);                }            });        } catch(IOException e) {            throw new RuntimeException(e);        }    }    public static void main(String[] args) throws Exception {        Directories.refreshTestDir();        Directories.populateTestDir();        Files.createFile(test.resolve(&quot;Hello.txt&quot;));        WatchService watcher = FileSystems.getDefault().newWatchService();        test.register(watcher, ENTRY_DELETE);        Executors.newSingleThreadScheduledExecutor().schedule(PathWatcher::delTxtFiles,        250, TimeUnit.MILLISECONDS);        WatchKey key = watcher.take();        for(WatchEvent evt : key.pollEvents()) {            System.out.println(&quot;evt.context(): &quot; + evt.context() +            &quot;\nevt.count(): &quot; + evt.count() +            &quot;\nevt.kind(): &quot; + evt.kind());            System.exit(0);        }    }}/* Output:deleting test\bag\foo\bar\baz\File.txtdeleting test\bar\baz\bag\foo\File.txtdeleting test\baz\bag\foo\bar\File.txtdeleting test\foo\bar\baz\bag\File.txtdeleting test\Hello.txtevt.context(): Hello.txtevt.count(): 1evt.kind(): ENTRY_DELETE*/</code></pre><p>一旦我们从 <strong>FileSystem</strong> 中得到了 <strong>WatchService</strong> 对象，我们将其注册到 <strong>test</strong> 路径以及我们感兴趣的项目的变量参数列表中，可以选择 <strong>ENTRY_CREATE</strong>，<strong>ENTRY_DELETE</strong> 或 <strong>ENTRY_MODIFY</strong>(其中创建和删除不属于修改)。</p><h3 id="7-文件查找"><a href="#7-文件查找" class="headerlink" title="7.文件查找"></a>7.文件查找</h3><p>通过在 <code>FileSystem</code> 对象上调用 <code>getPathMatcher()</code> 获得一个 <code>PathMatcher</code>，然后传入您感兴趣的模式。模式有两个选项：<code>glob</code> 和 <code>regex</code>。<code>glob</code> 比较简单，实际上功能非常强大，因此您可以使用 <code>glob</code> 解决许多问题。如果您的问题更复杂，可以使用 <code>regex</code>，这将在接下来的 <code>Strings</code> 一章中解释。</p><p>在这里，我们使用 <code>glob</code> 查找以 <code>.tmp</code> 或 <code>.txt</code> 结尾的所有 <code>Path</code>：</p><pre><code class="lang-java">// files/Find.java// {ExcludeFromGradle}import java.nio.file.*;public class Find {    public static void main(String[] args) throws Exception {        Path test = Paths.get(&quot;test&quot;);        Directories.refreshTestDir();        Directories.populateTestDir();        // Creating a *directory*, not a file:        Files.createDirectory(test.resolve(&quot;dir.tmp&quot;));        PathMatcher matcher = FileSystems.getDefault()          .getPathMatcher(&quot;glob:**/*.{tmp,txt}&quot;);        Files.walk(test)          .filter(matcher::matches)          .forEach(System.out::println);        System.out.println(&quot;***************&quot;);        PathMatcher matcher2 = FileSystems.getDefault()          .getPathMatcher(&quot;glob:*.tmp&quot;);        Files.walk(test)          .map(Path::getFileName)          .filter(matcher2::matches)          .forEach(System.out::println);        System.out.println(&quot;***************&quot;);        Files.walk(test) // Only look for files          .filter(Files::isRegularFile)          .map(Path::getFileName)          .filter(matcher2::matches)          .forEach(System.out::println);    }}</code></pre><p>在 <code>matcher</code> 中，<code>glob</code> 表达式开头的 <code>**/</code> 表示“当前目录及所有子目录”，这在当你不仅仅要匹配当前目录下特定结尾的 <code>Path</code> 时非常有用。单 <code>*</code> 表示“任何东西”，然后是一个点，然后大括号表示一系列的可能性—-我们正在寻找以 <code>.tmp</code> 或 <code>.txt</code> 结尾的东西。您可以在 <code>getPathMatcher()</code> 文档中找到更多详细信息。</p><p><code>matcher2</code> 只使用 <code>*.tmp</code>，通常不匹配任何内容，但是添加 <code>map()</code> 操作会将完整路径减少到末尾的名称。</p><p>注意，在这两种情况下，输出中都会出现 <code>dir.tmp</code>，即使它是一个目录而不是一个文件。要只查找文件，必须像在最后 <code>files.walk()</code> 中那样对其进行筛选。</p><h3 id="8-文件读写"><a href="#8-文件读写" class="headerlink" title="8.文件读写"></a>8.文件读写</h3><p><code>Files.readAllLines()</code> 一次读取整个文件（因此，“小”文件很有必要），产生一个<code>List&lt;String&gt;</code>。 对于示例文件，我们将重用<code>streams/Cheese.dat</code>：</p><pre><code class="lang-java">// files/ListOfLines.javaimport java.util.*;import java.nio.file.*;public class ListOfLines {    public static void main(String[] args) throws Exception {        Files.readAllLines(        Paths.get(&quot;../streams/Cheese.dat&quot;))        .stream()        .filter(line -&gt; !line.startsWith(&quot;//&quot;))        .map(line -&gt;            line.substring(0, line.length()/2))        .forEach(System.out::println);    }}/* Output:Not much of a cheeseFinest in theAnd what leads youWell, it&#39;sIt&#39;s certainly uncon*/</code></pre><p>跳过注释行，其余的内容每行只打印一半。 这实现起来很简单：你只需将 <code>Path</code> 传递给 <code>readAllLines()</code> （以前的 java 实现这个功能很复杂）。<code>readAllLines()</code> 有一个重载版本，包含一个 <code>Charset</code> 参数来存储文件的 Unicode 编码。</p><p><code>Files.write()</code> 被重载以写入 <code>byte</code> 数组或任何 <code>Iterable</code> 对象（它也有 <code>Charset</code> 选项）：</p><pre><code class="lang-java">// files/Writing.javaimport java.util.*;import java.nio.file.*;public class Writing {    static Random rand = new Random(47);    static final int SIZE = 1000;    public static void main(String[] args) throws Exception {        // Write bytes to a file:        byte[] bytes = new byte[SIZE];        rand.nextBytes(bytes);        Files.write(Paths.get(&quot;bytes.dat&quot;), bytes);        System.out.println(&quot;bytes.dat: &quot; + Files.size(Paths.get(&quot;bytes.dat&quot;)));        // Write an iterable to a file:        List&lt;String&gt; lines = Files.readAllLines(Paths.get(&quot;../streams/Cheese.dat&quot;));        Files.write(Paths.get(&quot;Cheese.txt&quot;), lines);        System.out.println(&quot;Cheese.txt: &quot; + Files.size(Paths.get(&quot;Cheese.txt&quot;)));    }}/* Output:bytes.dat: 1000Cheese.txt: 199*/</code></pre><p>一个 <code>List</code> 被写入文件，任何 <code>Iterable</code> 对象也可以这么做。</p><p>如果文件大小有问题怎么办？ 比如说：</p><ol><li>文件太大，如果你一次性读完整个文件，你可能会耗尽内存。</li><li>您只需要在文件的中途工作以获得所需的结果，因此读取整个文件会浪费时间。</li></ol><p><code>Files.lines()</code> 方便地将文件转换为行的 <code>Stream</code>：</p><pre><code class="lang-java">// files/ReadLineStream.javaimport java.nio.file.*;public class ReadLineStream {    public static void main(String[] args) throws Exception {        Files.lines(Paths.get(&quot;PathInfo.java&quot;))          .skip(13)          .findFirst()          .ifPresent(System.out::println);    }}/* Output:    show(&quot;RegularFile&quot;, Files.isRegularFile(p));*</code></pre><p><code>Files.lines()</code> 对于把文件处理行的传入流时非常有用，但是如果你想在 <code>Stream</code> 中读取，处理或写入怎么办？这就需要稍微复杂的代码：</p><pre><code class="lang-java">// files/StreamInAndOut.javaimport java.io.*;import java.nio.file.*;import java.util.stream.*;public class StreamInAndOut {    public static void main(String[] args) {        try(          Stream&lt;String&gt; input = Files.lines(Paths.get(&quot;StreamInAndOut.java&quot;));          PrintWriter output =  new PrintWriter(&quot;StreamInAndOut.txt&quot;)        ) {            input.map(String::toUpperCase)              .forEachOrdered(output::println);        } catch(Exception e) {            throw new RuntimeException(e);        }    }}</code></pre><p>因为我们在同一个块中执行所有操作，所以这两个文件都可以在相同的 try-with-resources 语句中打开。<code>PrintWriter</code> 是一个旧式的 <code>java.io</code> 类，允许你“打印”到一个文件，所以它是这个应用的理想选择。如果你看一下 <code>StreamInAndOut.txt</code>，你会发现它里面的内容确实是大写的。</p><h2 id="18-字符串"><a href="#18-字符串" class="headerlink" title="18.字符串"></a>18.字符串</h2><p><code>String</code> 对象是不可变的。查看 JDK 文档你就会发现，<code>String</code> 类中每一个看起来会修改 <code>String</code> 值的方法，实际上都是创建了一个全新的 <code>String</code> 对象，以包含修改后的字符串内容。而最初的 <code>String</code> 对象则丝毫未动，将一个字符串复制给一个新的字符串时，是浅复制。</p><p>Java中对String对象进行的操作实际上是一个不断创建新的对象并且将旧的对象回收的一个过程，所以执行速度很慢。而StringBuilder和StringBuffer的对象是变量，对变量进行操作就是直接对该对象进行更改，而不进行创建和回收的操作，所以速度要比String快很多。</p><h3 id="1-String、StringBuilder和StringBuffer"><a href="#1-String、StringBuilder和StringBuffer" class="headerlink" title="1.String、StringBuilder和StringBuffer"></a>1.String、StringBuilder和StringBuffer</h3><p>三者共同之处:都是final类,不允许被继承，主要是从性能和安全性上考虑的，因为这几个类都是经常被使用着，且考虑到防止其中的参数被参数修改影响到其他的应用。</p><ul><li>StringBuffer是<strong>线程安全</strong>，可以不需要额外的同步用于多线程中;</li><li>StringBuilder是非同步,运行于多线程中就需要使用着单独同步处理，但是速度就比StringBuffer快多了;</li><li>StringBuffer与StringBuilder两者共同之处:可以通过append、indert进行字符串的操作。</li></ul><p>运行速度: <strong>StringBuilder &gt; StringBuffer &gt; String</strong></p><p><strong>在线程安全上，StringBuilder是线程不安全的，而StringBuffer是线程安全的</strong>,所以如果要进行的操作是多线程的，那么就要使用StringBuffer，但是在单线程的情况下，还是建议使用速度比较快的StringBuilder。</p><h3 id="2-字符串操作"><a href="#2-字符串操作" class="headerlink" title="2.字符串操作"></a>2.字符串操作</h3><p>以下是 <code>String</code> 对象具备的一些基本方法。重载的方法归纳在同一行中：</p><div class="table-container"><table><thead><tr><th>方法</th><th>参数，重载版本</th><th>作用</th></tr></thead><tbody><tr><td>构造方法</td><td>默认版本，<code>String</code>，<code>StringBuilder</code>，<code>StringBuffer</code>，<code>char</code>数组，<code>byte</code>数组</td><td>创建<code>String</code>对象</td></tr><tr><td><code>length()</code></td><td></td><td><code>String</code>中字符的个数</td></tr><tr><td><code>charAt()</code></td><td><code>int</code>索引</td><td>获取<code>String</code>中索引位置上的<code>char</code></td></tr><tr><td><code>getChars()</code>，<code>getBytes()</code></td><td>待复制部分的开始和结束索引，复制的目标数组，目标数组的开始索引</td><td>复制<code>char</code>或<code>byte</code>到一个目标数组中</td></tr><tr><td><code>toCharArray()</code></td><td></td><td>生成一个<code>char[]</code>，包含<code>String</code>中的所有字符</td></tr><tr><td><code>equals()</code>，<code>equalsIgnoreCase()</code></td><td>与之进行比较的<code>String</code></td><td>比较两个<code>String</code>的内容是否相同。如果相同，结果为<code>true</code></td></tr><tr><td><code>compareTo()</code>，<code>compareToIgnoreCase()</code></td><td>与之进行比较的<code>String</code></td><td>按词典顺序比较<code>String</code>的内容，比较结果为负数、零或正数。注意，大小写不等价</td></tr><tr><td><code>contains()</code></td><td>要搜索的<code>CharSequence</code></td><td>如果该<code>String</code>对象包含参数的内容，则返回<code>true</code></td></tr><tr><td><code>contentEquals()</code></td><td>与之进行比较的<code>CharSequence</code>或<code>StringBuffer</code></td><td>如果该<code>String</code>对象与参数的内容完全一致，则返回<code>true</code></td></tr><tr><td><code>isEmpty()</code></td><td></td><td>返回<code>boolean</code>结果，以表明<code>String</code>对象的长度是否为0</td></tr><tr><td><code>regionMatches()</code></td><td>该<code>String</code>的索引偏移量，另一个<code>String</code>及其索引偏移量，要比较的长度。重载版本增加了“忽略大小写”功能</td><td>返回<code>boolean</code>结果，以表明所比较区域是否相等</td></tr><tr><td><code>startsWith()</code></td><td>可能的起始<code>String</code>。重载版本在参数中增加了偏移量</td><td>返回<code>boolean</code>结果，以表明该<code>String</code>是否以传入参数开始</td></tr><tr><td><code>endsWith()</code></td><td>该<code>String</code>可能的后缀<code>String</code></td><td>返回<code>boolean</code>结果，以表明此参数是否是该字符串的后缀</td></tr><tr><td><code>indexOf()</code>，<code>lastIndexOf()</code></td><td>重载版本包括：<code>char</code>，<code>char</code>与起始索引，<code>String</code>，<code>String</code>与起始索引</td><td>如果该<code>String</code>并不包含此参数，就返回-1；否则返回此参数在<code>String</code>中的起始索引。<code>lastIndexOf</code>()是从后往前搜索</td></tr><tr><td><code>matches()</code></td><td>一个正则表达式</td><td>返回<code>boolean</code>结果，以表明该<code>String</code>和给出的正则表达式是否匹配</td></tr><tr><td><code>split()</code></td><td>一个正则表达式。可选参数为需要拆分的最大数量</td><td>按照正则表达式拆分<code>String</code>，返回一个结果数组</td></tr><tr><td><code>join()</code>（Java8引入的）</td><td>分隔符，待拼字符序列。用分隔符将字符序列拼接成一个新的<code>String</code></td><td>用分隔符拼接字符片段，产生一个新的<code>String</code></td></tr><tr><td><code>substring()</code>（即<code>subSequence()</code>）</td><td>重载版本：起始索引；起始索引+终止索引</td><td>返回一个新的<code>String</code>对象，以包含参数指定的子串</td></tr><tr><td><code>concat()</code></td><td>要连接的<code>String</code></td><td>返回一个新的<code>String</code>对象，内容为原始<code>String</code>连接上参数<code>String</code></td></tr><tr><td><code>replace()</code></td><td>要替换的字符，用来进行替换的新字符。也可以用一个<code>CharSequence</code>替换另一个<code>CharSequence</code></td><td>返回替换字符后的新<code>String</code>对象。如果没有替换发生，则返回原始的<code>String</code>对象</td></tr><tr><td><code>replaceFirst()</code></td><td>要替换的正则表达式，用来进行替换的<code>String</code></td><td>返回替换首个目标字符串后的<code>String</code>对象</td></tr><tr><td><code>replaceAll()</code></td><td>要替换的正则表达式，用来进行替换的<code>String</code></td><td>返回替换所有目标字符串后的<code>String</code>对象</td></tr><tr><td><code>toLowerCase()</code>，<code>toUpperCase()</code></td><td></td><td>将字符的大小写改变后，返回一个新的<code>String</code>对象。如果没有任何改变，则返回原始的<code>String</code>对象</td></tr><tr><td><code>trim()</code></td><td></td><td>将<code>String</code>两端的空白符删除后，返回一个新的<code>String</code>对象。如果没有任何改变，则返回原始的<code>String</code>对象</td></tr><tr><td><code>valueOf()</code>（<code>static</code>）</td><td>重载版本：<code>Object</code>；<code>char[]</code>；<code>char[]</code>，偏移量，与字符个数；<code>boolean</code>；<code>char</code>；<code>int</code>；<code>long</code>；<code>float</code>；<code>double</code></td><td>返回一个表示参数内容的<code>String</code></td></tr><tr><td><code>intern()</code></td><td></td><td>为每个唯一的字符序列生成一个且仅生成一个<code>String</code>引用</td></tr><tr><td><code>format()</code></td><td>要格式化的字符串，要替换到格式化字符串的参数</td><td>返回格式化结果<code>String</code></td></tr></tbody></table></div><h3 id="3-格式化输出"><a href="#3-格式化输出" class="headerlink" title="3.格式化输出"></a>3.格式化输出</h3><p><strong>printf()</strong></p><pre><code class="lang-java">System.out.printf(&quot;Row 1: [%d %f]%n&quot;, x, y);</code></pre><p><strong>System.out.format()</strong></p><p>Java SE5 引入了 <code>format()</code> 方法，可用于 <code>PrintStream</code> 或者 <code>PrintWriter</code> 对象,其中也包括 <code>System.out</code> 对象。<code>format()</code> 方法模仿了 C 语言的 <code>printf()</code>。</p><pre><code class="lang-java">// strings/SimpleFormat.java public class SimpleFormat {       public static void main(String[] args) {             int x = 5;             double y = 5.332542;             // The old way:         System.out.println(&quot;Row 1: [&quot; + x + &quot; &quot; + y + &quot;]&quot;);             // The new way:             System.out.format(&quot;Row 1: [%d %f]%n&quot;, x, y);             // or             System.out.printf(&quot;Row 1: [%d %f]%n&quot;, x, y);       } } /* Output: Row 1: [5 5.332542] Row 1: [5 5.332542] Row 1: [5 5.332542] */</code></pre><p>可以看到，<code>format()</code> 和 <code>printf()</code> 是等价的，它们只需要一个简单的格式化字符串，加上一串参数即可，每个参数对应一个格式修饰符。</p><p><strong>Formatter</strong>类</p><p>在 Java 中，所有的格式化功能都是由 <code>java.util.Formatter</code> 类处理的。可以将 <code>Formatter</code> 看做一个翻译器，它将你的格式化字符串与数据翻译成需要的结果。当你创建一个 <code>Formatter</code> 对象时，需要向其构造器传递一些信息，告诉它最终的结果将向哪里输出：</p><p>格式化修饰符 <code>%s</code> 表明这里需要 <code>String</code> 参数。</p><pre><code class="lang-java">// strings/Turtle.java import java.io.*;import java.util.*;public class Turtle {       private String name;       private Formatter f;      public Turtle(String name, Formatter f) {        this.name = name;             this.f = f;       }       public void move(int x, int y) {             f.format(&quot;%s The Turtle is at (%d,%d)%n&quot;, name, x, y);       }    public static void main(String[] args) {            PrintStream outAlias = System.out;             Turtle tommy = new Turtle(&quot;Tommy&quot;, new Formatter(System.out));             Turtle terry = new Turtle(&quot;Terry&quot;, new Formatter(outAlias));             tommy.move(0,0);             terry.move(4,8);             tommy.move(3,4);             terry.move(2,5);             tommy.move(3,3);             terry.move(3,3);       } } /* Output: Tommy The Turtle is at (0,0) Terry The Turtle is at (4,8) Tommy The Turtle is at (3,4) Terry The Turtle is at (2,5) Tommy The Turtle is at (3,3) Terry The Turtle is at (3,3) */</code></pre><p><strong>格式化修饰符</strong></p><p>在插入数据时，如果想要优化空格与对齐，你需要更精细复杂的格式修饰符。以下是其通用语法：</p><pre><code>%[argument_index$][flags][width][.precision]conversion</code></pre><p>最常见的应用是控制一个字段的最小长度，这可以通过指定 <em>width</em> 来实现。<code>Formatter</code>对象通过在必要时添加空格，来确保一个字段至少达到设定长度。默认情况下，数据是右对齐的，不过可以通过使用 <code>-</code> 标志来改变对齐方向。</p><p>与 <em>width</em> 相对的是 <em>precision</em>，用于指定最大长度。<em>width</em> 可以应用于各种类型的数据转换，并且其行为方式都一样。<em>precision</em> 则不然，当应用于不同类型的数据转换时，<em>precision</em> 的意义也不同。在将 <em>precision</em> 应用于 <code>String</code> 时，它表示打印 <code>string</code> 时输出字符的最大数量。而在将 <em>precision</em> 应用于浮点数时，它表示小数部分要显示出来的位数（默认是 6 位小数），如果小数位数过多则舍入，太少则在尾部补零。由于整数没有小数部分，所以 <em>precision</em> 无法应用于整数，如果你对整数应用 <em>precision</em>，则会触发异常。</p><pre><code class="lang-java">// strings/ReceiptBuilder.java import java.util.*; public class ReceiptBuilder {       private double total = 0;       private Formatter f =             new Formatter(new StringBuilder());       public ReceiptBuilder() {             f.format(                 &quot;%-15s %5s %10s%n&quot;, &quot;Item&quot;, &quot;Qty&quot;, &quot;Price&quot;);             f.format(                 &quot;%-15s %5s %10s%n&quot;, &quot;----&quot;, &quot;---&quot;, &quot;-----&quot;);           }       public void add(String name, int qty, double price) {             f.format(&quot;%-15.15s %5d %10.2f%n&quot;, name, qty, price);             total += price * qty;       }      public String build() {             f.format(&quot;%-15s %5s %10.2f%n&quot;, &quot;Tax&quot;, &quot;&quot;,                 total * 0.06);             f.format(&quot;%-15s %5s %10s%n&quot;, &quot;&quot;, &quot;&quot;, &quot;-----&quot;);             f.format(&quot;%-15s %5s %10.2f%n&quot;, &quot;Total&quot;, &quot;&quot;,                 total * 1.06);             return f.toString();       }       public static void main(String[] args) {             ReceiptBuilder receiptBuilder =                 new ReceiptBuilder();             receiptBuilder.add(&quot;Jack&#39;s Magic Beans&quot;, 4, 4.25);             receiptBuilder.add(&quot;Princess Peas&quot;, 3, 5.1);             receiptBuilder.add(                 &quot;Three Bears Porridge&quot;, 1, 14.29);             System.out.println(receiptBuilder.build());       } } /* Output: Item              Qty      Price ----              ---      ----- Jack&#39;s Magic Be     4       4.25 Princess Peas       3       5.10 Three Bears Por     1      14.29 Tax                         2.80                            ----- Total                      49.39 */</code></pre><p><strong>String.format()</strong></p><p>Java SE5 也参考了 C 中的 <code>sprintf()</code> 方法，以生成格式化的 <code>String</code> 对象。<code>String.format()</code> 是一个 <code>static</code> 方法，它接受与 <code>Formatter.format()</code> 方法一样的参数，但返回一个 <code>String</code> 对象。当你只需使用一次 <code>format()</code> 方法的时候，<code>String.format()</code> 用起来很方便。例如：</p><pre><code class="lang-java">// strings/DatabaseException.java public class DatabaseException extends Exception {       public DatabaseException(int transactionID,           int queryID, String message) {           super(String.format(&quot;(t%d, q%d) %s&quot;, transactionID,                 queryID, message));       }       public static void main(String[] args) {           try {               throw new DatabaseException(3, 7, &quot;Write failed&quot;);           } catch(Exception e) {               System.out.println(e);           }       } } /* Output: DatabaseException: (t3, q7) Write failed */</code></pre><h3 id="4-正则表达式"><a href="#4-正则表达式" class="headerlink" title="4.正则表达式"></a>4.正则表达式</h3>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础2</title>
    <link href="/EruLv.github.io/2020/08/18/java%E5%9F%BA%E7%A1%802/"/>
    <url>/EruLv.github.io/2020/08/18/java%E5%9F%BA%E7%A1%802/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础2"><a href="#Java基础2" class="headerlink" title="Java基础2"></a>Java基础2</h1><h2 id="8-接口"><a href="#8-接口" class="headerlink" title="8.接口"></a>8.接口</h2><h3 id="1-抽象方法和抽象类"><a href="#1-抽象方法和抽象类" class="headerlink" title="1.抽象方法和抽象类"></a>1.抽象方法和抽象类</h3><p>仅有声明而没有方法体。</p><pre><code class="lang-java">abstract class Instrument {    //抽象类  private int i; // Storage allocated for each  public abstract void play(Note n);    //抽象方法  public String what() { return &quot;Instrument&quot;; }  public abstract void adjust();}</code></pre><p>包含抽象方法的类叫做抽象类。<strong>如果一个类包含一个或多个抽象方法，则该类必须是抽象的。</strong></p><p><strong>如果从一个抽象类继承，必须为基类中的所有抽象方法提供定义，否则该类也会被强制认为是抽象类。</strong></p><h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h3><p>更纯粹的抽象方法，<strong>接口内不能有方法体。</strong></p><p>用<code>interface</code>关键字代替<code>class</code></p><p>要想某个类遵循特定的接口，需要用<code>implements</code>关键字（类似于<code>extents</code>，必须实现接口的全部方法。</p><p>接口类中的方法必须被定义为<code>public</code>（默认<code>public</code>）。</p><pre><code class="lang-java">interface Instrument {  int VALUE = 5;   void play(Note n); // Automatically public  void adjust();}class Wind implements Instrument {  public void play(Note n) {    print(this + &quot;.play() &quot; + n);  }  public String toString() { return &quot;Wind&quot;; }  public void adjust() { print(this + &quot;.adjust()&quot;); }}</code></pre><h3 id="3-多重继承"><a href="#3-多重继承" class="headerlink" title="3.多重继承"></a>3.多重继承</h3><p>在<code>implements</code>可以添加多个接口，用逗号隔开。</p><p>当同时有继承操作时，需要把<code>extends</code>放在前面。</p><pre><code class="lang-java">interface CanFight {  void fight();}interface CanSwim {  void swim();}interface CanFly {  void fly();}class ActionCharacter {  public void fight() {}}  //继承+接口class Hero extends ActionCharacter    implements CanFight, CanSwim, CanFly {  public void swim() {}  public void fly() {}}</code></pre><h3 id="4-通过继承拓展接口"><a href="#4-通过继承拓展接口" class="headerlink" title="4.通过继承拓展接口"></a>4.通过继承拓展接口</h3><p>接口与类一样也可以继承。</p><pre><code class="lang-java">interface Monster {  void menace();}interface DangerousMonster extends Monster {  void destroy();}interface Lethal {  void kill();}class DragonZilla implements DangerousMonster {  public void menace() {}  public void destroy() {}}  interface Vampire extends DangerousMonster, Lethal {  void drinkBlood();}class VeryBadVampire implements Vampire {  public void menace() {}  public void destroy() {}  public void kill() {}  public void drinkBlood() {}}</code></pre><h3 id="5-接口中的域"><a href="#5-接口中的域" class="headerlink" title="5.接口中的域"></a>5.接口中的域</h3><p>接口中的域默认时<code>static</code>和<code>final</code>的，即全局常量。</p><pre><code class="lang-java">public interface RandVals {  Random RAND = new Random(47);  int RANDOM_INT = RAND.nextInt(10);  long RANDOM_LONG = RAND.nextLong() * 10;  float RANDOM_FLOAT = RAND.nextLong() * 10;  double RANDOM_DOUBLE = RAND.nextDouble() * 10;} public class TestRandVals {  public static void main(String[] args) {    print(RandVals.RANDOM_INT);    print(RandVals.RANDOM_LONG);    print(RandVals.RANDOM_FLOAT);    print(RandVals.RANDOM_DOUBLE);  }} /* Output:8-32032247016559954-8.5939291E185.779976127815049*///:~</code></pre><h3 id="6-嵌套接口"><a href="#6-嵌套接口" class="headerlink" title="6.嵌套接口"></a>6.嵌套接口</h3><p>在类中声明接口，接口是<code>static</code>的，其他类可以通过类名访问接口。类内的接口可以设置为<code>默认</code>,<code>public</code>，<code>private</code>。</p><pre><code class="lang-java">class A {  interface B {    void f();  }  public class BImp implements B {    public void f() {}  }  private class BImp2 implements B {    public void f() {}  }  public interface C {    void f();  }  class CImp implements C {    public void f() {}  }      private class CImp2 implements C {    public void f() {}  }  private interface D {    void f();  }  private class DImp implements D {    public void f() {}  }  public class DImp2 implements D {    public void f() {}  }  public D getD() { return new DImp2(); }  private D dRef;  public void receiveD(D d) {    dRef = d;    dRef.f();  }}</code></pre><h2 id="9-内部类"><a href="#9-内部类" class="headerlink" title="9.内部类"></a>9.内部类</h2><h3 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h3><p>当生成一个内部类的对象时，此对象与制造它的外部对象（enclosing object）之间就有了一种联系，所以它能访问其外部对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外部类的所有元素的访问权。</p><pre><code class="lang-java">interface Selector {  boolean end();  Object current();  void next();}  public class Sequence {  private Object[] items;  private int next = 0;  public Sequence(int size) { items = new Object[size]; }  public void add(Object x) {    if(next &lt; items.length)      items[next++] = x;  }  private class SequenceSelector implements Selector {    private int i = 0;    public boolean end() { return i == items.length; }    public Object current() { return items[i]; }    public void next() { if(i &lt; items.length) i++; }  }  public Selector selector() {    return new SequenceSelector();  }      public static void main(String[] args) {    Sequence sequence = new Sequence(10);    for(int i = 0; i &lt; 10; i++)      sequence.add(Integer.toString(i));    Selector selector = sequence.selector();    while(!selector.end()) {      System.out.print(selector.current() + &quot; &quot;);      selector.next();    }  }} /* Output:0 1 2 3 4 5 6 7 8 9*///:~</code></pre><h3 id="2-this和-new方法"><a href="#2-this和-new方法" class="headerlink" title="2.this和.new方法"></a>2<code>.this</code>和<code>.new</code>方法</h3><pre><code class="lang-java">// innerclasses/DotThis.java// Accessing the outer-class objectpublic class DotThis {    void f() { System.out.println(&quot;DotThis.f()&quot;); }    public class Inner {        public DotThis outer() {            return DotThis.this;            // A plain &quot;this&quot; would be Inner&#39;s &quot;this&quot;        }    }    public Inner inner() { return new Inner(); }    public static void main(String[] args) {        DotThis dt = new DotThis();        DotThis.Inner dti = dt.inner();        dti.outer().f();    }}</code></pre><p>必须使用外部类.new来直接创建内部类</p><pre><code class="lang-java">// innerclasses/DotNew.java// Creating an inner class directly using .new syntaxpublic class DotNew {    public class Inner {}    public static void main(String[] args) {        DotNew dn = new DotNew();        DotNew.Inner dni = dn.new Inner();        //    DotNew.Inner dni = new Inner();    wrong    }}</code></pre><p>不能使用.new来直接访问<code>private</code>的内部类，但可以使用创建函数来新建内部类。</p><pre><code class="lang-java">class Parcel4 {  private class PContents implements Contents {    private int i = 11;    public int value() { return i; }  }  protected class PDestination implements Destination {    private String label;    private PDestination(String whereTo) {      label = whereTo;    }    public String readLabel() { return label; }  }  public Destination destination(String s) {    return new PDestination(s);  }  public Contents contents() {    return new PContents();  }}public class TestParcel {  public static void main(String[] args) {    Parcel4 p = new Parcel4();    Contents c = p.contents();    Destination d = p.destination(&quot;Tasmania&quot;);    // Illegal -- can&#39;t access private class:    //! Parcel4.PContents pc = p.new PContents();  }} ///:~</code></pre><h3 id="3-内部类和作用域"><a href="#3-内部类和作用域" class="headerlink" title="3.内部类和作用域"></a>3.内部类和作用域</h3><p>你可以在任意一个作用域内定义内部类。</p><p>在方法中定义内部类:</p><pre><code class="lang-java">// innerclasses/Parcel5.java// Nesting a class within a methodpublic class Parcel5 {    public Destination destination(String s) {        final class PDestination implements Destination {            private String label;            private PDestination(String whereTo) {                label = whereTo;            }            @Override            public String readLabel() { return label; }        }        return new PDestination(s);    }    public static void main(String[] args) {        Parcel5 p = new Parcel5();        Destination d = p.destination(&quot;Tasmania&quot;);    }}</code></pre><p><strong>PDestination</strong> 类是 <code>destination()</code> 方法的一部分，而不是 <strong>Parcel5</strong> 的一部分。所以，在 <code>destination()</code> 之外不能访问 在 <code>destination()</code> 中定义了内部类 <strong>PDestination</strong>，但并不意味着一旦 <code>destination()</code> 方法执行完毕，<strong>PDestination</strong> 就不可用了,它其实与别的类一起编译过了。</p><p><strong>匿名内部类</strong></p><p>创建一个继承自 <strong>Contents</strong> 的匿名类的对象。通过 <strong>new</strong> 表达式返回的引用被自动向上转型为对 <strong>Contents</strong> 的引用。</p><pre><code class="lang-java">public interface Contents {  int value();} public class Parcel7 {  public Contents contents() {    return new Contents() { // Insert a class definition      private int i = 11;      public int value() { return i; }    }; // Semicolon required in this case  }  public static void main(String[] args) {    Parcel7 p = new Parcel7();    Contents c = p.contents();  }} ///:~</code></pre><p>等价于:</p><pre><code class="lang-java">public class Parcel7b {  class MyContents implements Contents {    private int i = 11;    public int value() { return i; }  }  public Contents contents() { return new MyContents(); }  public static void main(String[] args) {    Parcel7b p = new Parcel7b();    Contents c = p.contents();  }} ///:~</code></pre><p>内部匿名类传参要求是Final的。这里省略掉 <strong>final</strong> 也没问题，但是通常最好加上 <strong>final</strong> 作为一种暗示。</p><pre><code class="lang-java">public class Parcel9 {  // Argument must be final to use inside  // anonymous inner class:  public Destination destination(final String dest) {    return new Destination() {      private String label = dest;      public String readLabel() { return label; }    };  }  public static void main(String[] args) {    Parcel9 p = new Parcel9();    Destination d = p.destination(&quot;Tasmania&quot;);  }} ///:~</code></pre><p>匿名类没有构造器，但是可以在它的抽象类中定义构造器。在此例中，不要求变量一定是 <strong>final</strong> 的。因为被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。</p><pre><code class="lang-java">abstract class Base {  public Base(int i) {    print(&quot;Base constructor, i = &quot; + i);  }  public abstract void f();}  public class AnonymousConstructor {  public static Base getBase(int i) {    return new Base(i) {      { print(&quot;Inside instance initializer&quot;); }      public void f() {        print(&quot;In anonymous f()&quot;);      }    };  }  public static void main(String[] args) {    Base base = getBase(47);    base.f();  }} /* Output:Base constructor, i = 47Inside instance initializerIn anonymous f()*///:~</code></pre><h3 id="4-嵌套类"><a href="#4-嵌套类" class="headerlink" title="4.嵌套类"></a>4.嵌套类</h3><p>当内部类声明为<code>static</code>时，叫做嵌套类。</p><p>想要理解 <strong>static</strong> 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外部类对象。然而，当内部类是 <strong>static</strong> 的时，就不是这样了。嵌套类意味着：</p><ol><li>要创建嵌套类的对象，并不需要其外部类的对象。</li><li>不能从嵌套类的对象中访问非静态的外部类对象。</li></ol><h3 id="5-接口内部类"><a href="#5-接口内部类" class="headerlink" title="5.接口内部类"></a>5.接口内部类</h3><p>内部类可以写在接口里。</p><pre><code class="lang-java">public interface ClassInInterface {    void howdy();    class Test implements ClassInInterface {        @Override        public void howdy() {            System.out.println(&quot;Howdy!&quot;);        }        public static void main(String[] args) {            new Test().howdy();        }    }}</code></pre><h3 id="6-多层嵌套类"><a href="#6-多层嵌套类" class="headerlink" title="6.多层嵌套类"></a>6.多层嵌套类</h3><p>内部类可以访问外部类成员。</p><pre><code class="lang-java">class MNA {    private void f() {}    class A {        private void g() {}        public class B {            void h() {                g();                f();            }        }    }}public class MultiNestingAccess {    public static void main(String[] args) {        MNA mna = new MNA();        MNA.A mnaa = mna.new A();        MNA.A.B mnaab = mnaa.new B();        mnaab.h();    }}</code></pre><h3 id="7-为什么要用内部类"><a href="#7-为什么要用内部类" class="headerlink" title="7.为什么要用内部类"></a>7.为什么要用内部类</h3><p>部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类，抽象类不能多重继承）。</p><pre><code class="lang-java">class D {}abstract class E {}class Z extends D {    E makeE() {      return new E() {};      }}public class MultiImplementation {    static void takesD(D d) {}    static void takesE(E e) {}    public static void main(String[] args) {        Z z = new Z();        takesD(z);        takesE(z.makeE());    }}</code></pre><h3 id="8-内部类的继承"><a href="#8-内部类的继承" class="headerlink" title="8.内部类的继承"></a>8.内部类的继承</h3><p>必须使用外部类.内部类方法继承。</p><pre><code class="lang-java">class WithInner {    class Inner {}}public class InheritInner extends WithInner.Inner {    //- InheritInner() {} // Won&#39;t compile    InheritInner(WithInner wi) {        wi.super();    }    public static void main(String[] args) {        WithInner wi = new WithInner();        InheritInner ii = new InheritInner(wi);    }}</code></pre><p>另外，内部类覆盖是没用的。</p><pre><code class="lang-java">class Egg {  private Yolk y;  protected class Yolk {    public Yolk() { print(&quot;Egg.Yolk()&quot;); }  }  public Egg() {    print(&quot;New Egg()&quot;);    y = new Yolk();  }}  public class BigEgg extends Egg {  public class Yolk {    //无效    public Yolk() { print(&quot;BigEgg.Yolk()&quot;); }  }  public static void main(String[] args) {    new BigEgg();  }} /* Output:New Egg()Egg.Yolk()*///:~</code></pre><h2 id="10-集合"><a href="#10-集合" class="headerlink" title="10.集合"></a>10.集合</h2><p>Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口：</p><ol><li><strong>集合（Collection）</strong> ：一个独立元素的序列，这些元素都服从一条或多条规则。<strong>List</strong> 必须以插入的顺序保存元素， <strong>Set</strong> 不能包含重复元素， <strong>Queue</strong> 按照<em>排队规则</em>来确定对象产生的顺序（通常与它们被插入的顺序相同）。</li><li><strong>映射（Map）</strong> ： 一组成对的“键值对”对象，允许使用键来查找值。 <strong>ArrayList</strong> 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 <strong>map</strong> 允许我们使用一个对象来查找另一个对象，它也被称作<em>关联数组</em>（associative array），因为它将对象和其它对象关联在一起；或者称作<em>字典</em>（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 <strong>Map</strong> 是强大的编程工具。</li></ol><h3 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1.Collection"></a>1.Collection</h3><p><code>collection.addAll()</code>方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中。</p><p><code>Arrays.asList()</code>方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。</p><p><code>Arrays.toString()</code>打印集合。</p><h3 id="2-列表List"><a href="#2-列表List" class="headerlink" title="2.列表List"></a>2.列表List</h3><p><strong>List</strong>承诺将元素保存在特定的序列中。 <strong>List</strong> 接口在 <strong>Collection</strong> 的基础上添加了许多方法，允许在 <strong>List</strong> 的中间插入和删除元素。</p><p>有两种类型的 <strong>List</strong> ：</p><ul><li>基本的 <strong>ArrayList</strong> ，擅长随机访问元素，但在 <strong>List</strong> 中间插入和删除元素时速度较慢。</li><li><strong>LinkedList</strong> ，它通过代价较低的在 <strong>List</strong> 中间进行的插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong> 对于随机访问来说相对较慢，但它具有比 <strong>ArrayList</strong> 更大的特征集</li></ul><p>方法:</p><p><code>List.add()</code>:在后面添加元素。</p><p><code>List.remove(ele)</code>:移除元素ele.</p><p><code>List.get(index)</code>:根据下标返回元素。</p><p><code>List.indexOf(ele)</code>:返回下标。</p><p><code>List.subList(st,ed)</code>:左闭右开</p><p><code>Collections.sort(List):</code>排序，无返回</p><p><code>Collections.shuffle(List, rand_int)</code>,根据随机种子打乱。</p><p>根据已有的List新建List.</p><pre><code class="lang-java">List&lt;Pet&gt; copy = new ArrayList&lt;&gt;(pets);</code></pre><p><code>List.retainAll(List)</code>两个集合求交集</p><p><code>List.removeAll(List),</code>根据List内容移除</p><p><code>List.set(index, object)</code>在index位置替换元素。</p><p><code>List.addAll(index, List)</code>,在中间位置添加列表。</p><p><code>List.clear()</code>清除。</p><h3 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3.迭代器"></a>3.迭代器</h3><p>迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为<em>轻量级对象</em>（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 <strong>Iterator</strong> 只能单向移动。这个 <strong>Iterator</strong> 只能用来：</p><ol><li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li><li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li><li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li><li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li></ol><pre><code class="lang-java">public class CrossCollectionIteration2 {  public static void display(Iterable&lt;Pet&gt; ip) {    Iterator&lt;Pet&gt; it = ip.iterator();    while(it.hasNext()) {      Pet p = it.next();      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);    }    System.out.println();  }  public static void main(String[] args) {    List&lt;Pet&gt; pets = Pets.list(8);    LinkedList&lt;Pet&gt; petsLL = new LinkedList&lt;&gt;(pets);    HashSet&lt;Pet&gt; petsHS = new HashSet&lt;&gt;(pets);    TreeSet&lt;Pet&gt; petsTS = new TreeSet&lt;&gt;(pets);    display(pets);    display(petsLL);    display(petsHS);    display(petsTS);  }}</code></pre><p><strong>ListIterator</strong> 是一个更强大的 <strong>Iterator</strong> 子类型，它只能由各种 <strong>List</strong> 类生成。 <strong>Iterator</strong> 只能向前移动，而 <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。</p><pre><code class="lang-java">// collections/ListIteration.javaimport typeinfo.pets.*;import java.util.*;public class ListIteration {  public static void main(String[] args) {    List&lt;Pet&gt; pets = Pets.list(8);    ListIterator&lt;Pet&gt; it = pets.listIterator();    while(it.hasNext())      System.out.print(it.next() +        &quot;, &quot; + it.nextIndex() +        &quot;, &quot; + it.previousIndex() + &quot;; &quot;);    System.out.println();    // Backwards:    while(it.hasPrevious())      System.out.print(it.previous().id() + &quot; &quot;);    System.out.println();    System.out.println(pets);    it = pets.listIterator(3);    while(it.hasNext()) {      it.next();      it.set(Pets.get());    }    System.out.println(pets);  }}/* Output:Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug,5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;7 6 5 4 3 2 1 0[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx][Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster,EgyptianMau]*/</code></pre><p><strong>LinkedList</strong> 也像 <strong>ArrayList</strong> 一样实现了基本的 <strong>List</strong> 接口，但它在 <strong>List</strong> 中间执行插入和删除操作时比 <strong>ArrayList</strong> 更高效。然而,它在随机访问操作效率方面却要逊色一些。</p><p><strong>LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）</strong> 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 <strong>Queue</strong> 中）。例如：</p><ul><li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li><li><code>addFirst()</code> 在列表的开头插入一个元素。</li><li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li><li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li></ul><p>自定义Collection迭代器。</p><p>要实现 <strong>Collection</strong> ，就必须实现该接口中的所有方法AbstractCollection。</p><pre><code class="lang-java">public class CollectionSequence extends AbstractCollection&lt;Pet&gt; {  private Pet[] pets = Pets.array(8);  @Override  public int size() { return pets.length; }  @Override  public Iterator&lt;Pet&gt; iterator() {    return new Iterator&lt;Pet&gt;() { // [1]      private int index = 0;      @Override      public boolean hasNext() {        return index &lt; pets.length;      }      @Override      public Pet next() { return pets[index++]; }      @Override      public void remove() { // Not implemented        throw new UnsupportedOperationException();      }    };  }  public static void main(String[] args) {    CollectionSequence c = new CollectionSequence();    InterfaceVsIterator.display(c);    InterfaceVsIterator.display(c.iterator());  }}</code></pre><p>实现<code>for-in</code></p><p><code>for-in</code>要求<strong>Iterable</strong> 的接口，该接口包含一个能够生成 <strong>Iterator</strong> 的 <code>iterator()</code> 方法。</p><pre><code class="lang-java">// collections/IterableClass.java// Anything Iterable works with for-inimport java.util.*;public class IterableClass implements Iterable&lt;String&gt; {  protected String[] words = (&quot;And that is how &quot; +    &quot;we know the Earth to be banana-shaped.&quot;    ).split(&quot; &quot;);  @Override  public Iterator&lt;String&gt; iterator() {    return new Iterator&lt;String&gt;() {      private int index = 0;      @Override      public boolean hasNext() {        return index &lt; words.length;      }      @Override      public String next() { return words[index++]; }      @Override      public void remove() { // Not implemented        throw new UnsupportedOperationException();      }    };  }  public static void main(String[] args) {    for(String s : new IterableClass())      System.out.print(s + &quot; &quot;);  }}/* Output:And that is how we know the Earth to be banana-shaped.*/</code></pre><h3 id="4-堆栈Stack"><a href="#4-堆栈Stack" class="headerlink" title="4.堆栈Stack"></a>4.堆栈Stack</h3><pre><code class="lang-java">// collections/StackTest.javaimport java.util.*;public class StackTest {  public static void main(String[] args) {    Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();    for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;))      stack.push(s);    while(!stack.isEmpty())      System.out.print(stack.pop() + &quot; &quot;);  }}/* Output:fleas has dog My*/</code></pre><h3 id="5-集合Set"><a href="#5-集合Set" class="headerlink" title="5.集合Set"></a>5.集合Set</h3><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。 <strong>Set</strong> 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 <strong>Set</strong> 中。因此，查找通常是 <strong>Set</strong> 最重要的操作，因此通常会选择 <strong>HashSet</strong> 实现，该实现针对快速查找进行了优化。</p><pre><code class="lang-java">// collections/SetOfInteger.javaimport java.util.*;public class SetOfInteger {  public static void main(String[] args) {    Random rand = new Random(47);    Set&lt;Integer&gt; intset = new HashSet&lt;&gt;();    for(int i = 0; i &lt; 10000; i++)      intset.add(rand.nextInt(30));    System.out.println(intset);  }}/* Output:[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]*/</code></pre><h3 id="6-映射Map"><a href="#6-映射Map" class="headerlink" title="6.映射Map"></a>6.映射Map</h3><pre><code class="lang-java">import java.util.*;public class Statistics {  public static void main(String[] args) {    Random rand = new Random(47);    Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;();    for(int i = 0; i &lt; 10000; i++) {      // Produce a number between 0 and 20:      int r = rand.nextInt(20);      Integer freq = m.get(r); // [1]      m.put(r, freq == null ? 1 : freq + 1);    }    System.out.println(m);  }}/* Output:{0=481, 1=502, 2=489, 3=508, 4=481, 5=503, 6=519,7=471, 8=468, 9=549, 10=513, 11=531, 12=521, 13=506,14=477, 15=497, 16=533, 17=509, 18=478, 19=464}*/</code></pre><h3 id="7-队列Queue"><a href="#7-队列Queue" class="headerlink" title="7.队列Queue"></a>7.队列Queue</h3><pre><code class="lang-java">import java.util.*;public class QueueDemo {  public static void printQ(Queue queue) {    while(queue.peek() != null)      System.out.print(queue.remove() + &quot; &quot;);    System.out.println();  }  public static void main(String[] args) {    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();    Random rand = new Random(47);    for(int i = 0; i &lt; 10; i++)      queue.offer(rand.nextInt(i + 10));    printQ(queue);    Queue&lt;Character&gt; qc = new LinkedList&lt;&gt;();    for(char c : &quot;Brontosaurus&quot;.toCharArray())      qc.offer(c);    printQ(qc);  }}/* Output:8 1 1 1 5 14 3 1 0 1B r o n t o s a u r u s*/</code></pre><p><code>offer()</code> 是与 <strong>Queue</strong> 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。 </p><p><code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。</p><p> <code>poll()</code> 和 <code>remove()</code><em> 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <em>*NoSuchElementException</em></em> 。</p><p><strong>优先级队列PriorityQueue</strong></p><p>当在 <strong>PriorityQueue</strong> 上调用 <code>offer()</code> 方法来插入一个对象时，该对象会在队列中被排序。<sup><a href="#fn_5" id="reffn_5">5</a></sup>默认的排序使用队列中对象的<em>自然顺序</em>（natural order），但是可以通过提供自己的 <strong>Comparator</strong> 来修改这个顺序。 <strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素。</p><h2 id="11-函数式编程"><a href="#11-函数式编程" class="headerlink" title="11.函数式编程"></a>11.函数式编程</h2><p>OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。</p><h3 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h3><p>​    Lambda 表达式是使用<strong>最小可能</strong>语法编写的函数定义：</p><ol><li>Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。</li><li>Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。</li></ol><p>任何 Lambda 表达式的基本语法是：</p><ol><li>参数。</li><li>接着 <code>-&gt;</code>，可视为“产出”。</li><li><code>-&gt;</code> 之后的内容都是方法体。</li></ol><pre><code class="lang-java">// functional/LambdaExpressions.javainterface Description {  String brief();}interface Body {  String detailed(String head);}interface Multi {  String twoArg(String head, Double d);}public class LambdaExpressions {  static Body bod = h -&gt; h + &quot; No Parens!&quot;; // 当只用一个参数，可以不需要括号 ()。  static Body bod2 = (h) -&gt; h + &quot; More details&quot;; // 正常情况使用括号 () 包裹参数。 为了保持一致性，也可以使用括号 () 包裹单个参数，虽然这种情况并不常见。  static Description desc = () -&gt; &quot;Short info&quot;; //  如果没有参数，则必须使用括号 () 表示空参数列表。  static Multi mult = (h, n) -&gt; h + n; // 对于多个参数，将参数列表放在括号 () 中。  static Description moreLines = () -&gt; { // 如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 return。    System.out.println(&quot;moreLines()&quot;);    return &quot;from moreLines()&quot;;  };  public static void main(String[] args) {    System.out.println(bod.detailed(&quot;Oh!&quot;));    System.out.println(bod2.detailed(&quot;Hi!&quot;));    System.out.println(desc.brief());    System.out.println(mult.twoArg(&quot;Pi! &quot;, 3.14159));    System.out.println(moreLines.brief());  }}</code></pre><p>输出:</p><pre><code>Oh! No Parens!Hi! More detailsShort infoPi! 3.14159moreLines()from moreLines()</code></pre><h3 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2.方法引用"></a>2.方法引用</h3><p>方法引用组成：类名或对象名，后面跟 <code>::</code> ，然后跟方法名称。</p><pre><code class="lang-java">// functional/MethodReferences.javaimport java.util.*;interface Callable { // [1]  void call(String s);}class Describe {  void show(String msg) { // [2]    System.out.println(msg);  }}public class MethodReferences {  static void hello(String name) { // [3]    System.out.println(&quot;Hello, &quot; + name);  }  static class Description {    String about;    Description(String desc) { about = desc; }    void help(String msg) { // [4]      System.out.println(about + &quot; &quot; + msg);    }  }  static class Helper {    static void assist(String msg) { // [5]      System.out.println(msg);    }  }  public static void main(String[] args) {    Describe d = new Describe();    Callable c = d::show; // [6]    c.call(&quot;call()&quot;); // [7]    c = MethodReferences::hello; // static方法直接引用    c.call(&quot;Bob&quot;);    c = new Description(&quot;valuable&quot;)::help; // 非静态方法需要实例化class    c.call(&quot;information&quot;);    c = Helper::assist; // 静态类和静态方法    c.call(&quot;Help!&quot;);  }}</code></pre><p><strong>Runable接口</strong></p><p>我们可以使用 Lambda 表达式和方法引用作为 <strong>Runnable</strong></p><pre><code class="lang-java">// functional/RunnableMethodReference.java// 方法引用与 Runnable 接口的结合使用class Go {  static void go() {    System.out.println(&quot;Go::go()&quot;);  }}public class RunnableMethodReference {  public static void main(String[] args) {    new Thread(new Runnable() {      public void run() {        System.out.println(&quot;Anonymous&quot;);      }    }).start();    new Thread(      () -&gt; System.out.println(&quot;lambda&quot;)    ).start();    new Thread(Go::go).start();  }}</code></pre><p><strong>未绑定方法引用</strong></p><pre><code class="lang-java">class X {  String f() { return &quot;X::f()&quot;; }}interface MakeString {  String make();}interface TransformX {  String transform(X x);}public class UnboundMethodReference {  public static void main(String[] args) {//     MakeString ms = X::f; // [1] should be :MakeString ms = new X()::f    TransformX sp = X::f;    X x = new X();    System.out.println(sp.transform(x)); // [2]    System.out.println(x.f()); // Same effect  }}/* Output:X::f()X::f()*/</code></pre><p>[1]会报错，因为方法不是静态的，而且方法签名对不上。可以先不实例化类，把方法引用传递给给包含该类的接口方法上。</p><p><strong>构造函数的引用</strong></p><p>使用class::new来获得构造函数引用。</p><pre><code class="lang-java">class Dog {  String name;  int age = -1; // For &quot;unknown&quot;  Dog() { name = &quot;stray&quot;; }  Dog(String nm) { name = nm; }  Dog(String nm, int yrs) { name = nm; age = yrs; }}interface MakeNoArgs {  Dog make();}interface Make1Arg {  Dog make(String nm);}interface Make2Args {  Dog make(String nm, int age);}public class CtorReference {  public static void main(String[] args) {    MakeNoArgs mna = Dog::new; // [1]    Make1Arg m1a = Dog::new;   // [2]    Make2Args m2a = Dog::new;  // [3]    Dog dn = mna.make();    Dog d1 = m1a.make(&quot;Comet&quot;);    Dog d2 = m2a.make(&quot;Ralph&quot;, 4);  }}</code></pre><h3 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3.函数式接口"></a>3.函数式接口</h3><h2 id="12-流式编程"><a href="#12-流式编程" class="headerlink" title="12.流式编程"></a>12.流式编程</h2><p>流编程风格:</p><p>首先，我们给 <strong>Random</strong> 对象一个种子（以便程序再次运行时产生相同的输出）。<code>ints()</code> 方法产生一个流并且 <code>ints()</code> 方法有多种方式的重载 — 两个参数限定了产生的数值的边界。这将生成一个随机整数流。我们用中间流操作（intermediate stream operation） <code>distinct()</code> 使流中的整数不重复，然后使用 <code>limit()</code> 方法获取前 7 个元素。接下来使用 <code>sorted()</code> 方法排序。最终使用 <code>forEach()</code> 方法遍历输出，它根据传递给它的函数对流中的每个对象执行操作。在这里，我们传递了一个可以在控制台显示每个元素的方法引用：<code>System.out::println</code> 。</p><pre><code class="lang-java">// streams/Randoms.javaimport java.util.*;public class Randoms {    public static void main(String[] args) {        new Random(47)            .ints(5, 20)            .distinct()            .limit(7)            .sorted()            .forEach(System.out::println);    }}//[7, 8, 9, 11, 13, 15, 18]</code></pre><h3 id="1-流创建"><a href="#1-流创建" class="headerlink" title="1.流创建"></a>1.流创建</h3><p>你可以通过 <code>Stream.of()</code> 很容易地将一组元素转化成为流。</p><pre><code class="lang-java">import java.util.stream.*;public class StreamOf {  public static void main(String[] args) {    Stream.of(      new Bubble(1), new Bubble(2), new Bubble(3))      .forEach(System.out::println);    Stream.of(&quot;It&#39;s &quot;, &quot;a &quot;, &quot;wonderful &quot;,      &quot;day &quot;, &quot;for &quot;, &quot;pie!&quot;)      .forEach(System.out::print);    System.out.println();    Stream.of(3.14159, 2.718, 1.618)      .forEach(System.out::println);  }}/* Output:Bubble(1)Bubble(2)Bubble(3)It&#39;s a wonderful day for pie!3.141592.7181.618*/</code></pre><p>除此之外，每个集合都可以通过调用 <code>stream()</code> 方法来产生一个流。代码示例：</p><pre><code class="lang-java">// streams/CollectionToStream.javaimport java.util.*;import java.util.stream.*;public class CollectionToStream {    public static void main(String[] args) {        List&lt;Bubble&gt; bubbles = Arrays.asList(new Bubble(1), new Bubble(2), new Bubble(3));        System.out.println(bubbles.stream()            .mapToInt(b -&gt; b.i)            .sum());        Set&lt;String&gt; w = new HashSet&lt;&gt;(Arrays.asList(&quot;It&#39;s a wonderful day for pie!&quot;.split(&quot; &quot;)));        w.stream()         .map(x -&gt; x + &quot; &quot;)         .forEach(System.out::print);        System.out.println();        Map&lt;String, Double&gt; m = new HashMap&lt;&gt;();        m.put(&quot;pi&quot;, 3.14159);        m.put(&quot;e&quot;, 2.718);        m.put(&quot;phi&quot;, 1.618);        m.entrySet().stream()                    .map(e -&gt; e.getKey() + &quot;: &quot; + e.getValue())                    .forEach(System.out::println);    }}</code></pre><p><strong>生成Stream.generate</strong></p><p>需要实现supplier<T>，或者直接传一个lambda函数。</T></p><pre><code class="lang-java">import java.util.*;import java.util.function.*;import java.util.stream.*;public class Generator implements Supplier&lt;String&gt; {  Random rand = new Random(47);  char[] letters =    &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();  public String get() {        return &quot;&quot; + letters[rand.nextInt(letters.length)];  }  public static void main(String[] args) {    String word = Stream.generate(new Generator())      .limit(30)      .collect(Collectors.joining());    System.out.println(word);  }}</code></pre><pre><code class="lang-java">// streams/Duplicator.javaimport java.util.stream.*;public class Duplicator {    public static void main(String[] args) {        Stream.generate(() -&gt; &quot;duplicate&quot;)              .limit(3)              .forEach(System.out::println);    }}</code></pre><p><strong>迭代iterate</strong></p><p><code>Stream.iterate()</code> 产生的流的第一个元素是种子（iterate方法的第一个参数），然后将种子传递给方法（iterate方法的第二个参数）。<strong>方法运行的结果被添加到流（作为流的第二个元素），并存储起来作为下次调用 <code>iterate()</code>时的第一个参数</strong>，以此类推。</p><pre><code class="lang-java">import java.util.stream.*;public class Fibonacci {  int x = 1;  Stream&lt;Integer&gt; numbers() {    return Stream.iterate(0, i -&gt; {    //第一次i = 0, 后来i = 1,2...      int result = x + i;      x = i;      return result;    });  }  public static void main(String[] args) {    new Fibonacci().numbers()      .limit(10) // Then take 10 of them      .forEach(System.out::println);  }}</code></pre><p><strong>builder</strong></p><p>在建造者模式（Builder design pattern）中，首先创建一个 <code>builder</code> 对象，然后将创建流所需的多个信息传递给它，最后<code>builder</code> 对象执行”创建“流的操作。</p><pre><code class="lang-java">import java.io.*;import java.nio.file.*;import java.util.stream.*;public class FileToWordsBuilder {    Stream.Builder&lt;String&gt; builder = Stream.builder();    public FileToWordsBuilder(String filePath) throws Exception {        Files.lines(Paths.get(filePath))             .skip(1) // 略过开头的注释行             .forEach(line -&gt; {                  for (String w : line.split(&quot;[ .?,]+&quot;))                      builder.add(w);              });    }    Stream&lt;String&gt; stream() {        return builder.build();    }    public static void main(String[] args) throws Exception {        new FileToWordsBuilder(&quot;Cheese.dat&quot;)            .stream()            .limit(7)            .map(w -&gt; w + &quot; &quot;)            .forEach(System.out::print);    }}</code></pre><p><code>Arrays</code> 类中含有一个名为 <code>stream()</code> 的静态方法用于把数组转换成为流。</p><pre><code class="lang-java">import java.util.*;import java.util.stream.*;public class ArrayStreams {    public static void main(String[] args) {        Arrays.stream(new double[] { 3.14159, 2.718, 1.618 })            .forEach(n -&gt; System.out.format(&quot;%f &quot;, n));        System.out.println();        Arrays.stream(new int[] { 1, 3, 5 })            .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));        System.out.println();        Arrays.stream(new long[] { 11, 22, 44, 66 })            .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));        System.out.println();        // 选择一个区间:        Arrays.stream(new int[] { 1, 3, 5, 7, 15, 28, 37 }, 3, 6)    //start, end            .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));    }}/*3.141590 2.718000 1.6180001 3 511 22 44 667 15 28*/</code></pre><h3 id="2-中间操作"><a href="#2-中间操作" class="headerlink" title="2.中间操作"></a>2.中间操作</h3><p>中间操作用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作。</p><p><strong><code>peek</code>测试</strong></p><p>它允许你无修改地查看流中的元素。代码示例：</p><pre><code class="lang-java">class Peeking {    public static void main(String[] args) throws Exception {        FileToWords.stream(&quot;Cheese.dat&quot;)        .skip(21)        .limit(4)        .map(w -&gt; w + &quot; &quot;)        .peek(System.out::print)        .map(String::toUpperCase)        .peek(System.out::print)        .map(String::toLowerCase)        .forEach(System.out::print);    }}</code></pre><p><strong>排序</strong></p><p>在 <code>Randoms.java</code> 中，我们熟识了 <code>sorted()</code> 的默认比较器实现。其实它还有另一种形式的实现：传入一个 <strong>Comparator</strong> 参数。代码示例：</p><pre><code class="lang-java">// streams/SortedComparator.javaimport java.util.*;public class SortedComparator {    public static void main(String[] args) throws Exception {        FileToWords.stream(&quot;Cheese.dat&quot;)        .skip(10)        .limit(10)        .sorted(Comparator.reverseOrder())        .map(w -&gt; w + &quot; &quot;)        .forEach(System.out::print);    }}</code></pre><p><strong>移除元素</strong></p><ul><li><code>distinct()</code>：在 <code>Randoms.java</code> 类中的 <code>distinct()</code> 可用于消除流中的重复元素。相比创建一个 <strong>Set</strong> 集合，该方法的工作量要少得多。</li><li><code>filter(Predicate)</code>：若元素传递给过滤函数产生的结果为<code>true</code> ，则过滤操作保留这些元素。</li></ul><p><code>rangeClosed()</code> 定义一个区间，遍历区间中的数，如果不能整除，即余数不等于 0，则 <code>noneMatch()</code> 操作返回 <code>true</code>，如果出现任何等于 0 的结果则返回 <code>false</code>。 <code>noneMatch()</code> 操作一旦有失败就会退出。</p><pre><code class="lang-java">import java.util.stream.*;import static java.util.stream.LongStream.*;public class Prime {  public static boolean isPrime(long n) {    return rangeClosed(2, (long)Math.sqrt(n))      .noneMatch(i -&gt; n % i == 0);  }  public LongStream numbers() {    return iterate(2, i -&gt; i + 1)      .filter(Prime::isPrime);  }  public static void main(String[] args) {    new Prime().numbers()      .limit(10)      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));    System.out.println();    new Prime().numbers()      .skip(90)      .limit(10)      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));  }}/* Output:2 3 5 7 11 13 17 19 23 29467 479 487 491 499 503 509 521 523 541*/</code></pre><p><strong><code>map</code>应用函数到元素</strong></p><ul><li><code>map(Function)</code>：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。</li><li><code>mapToInt(ToIntFunction)</code>：操作同上，但结果是 <strong>IntStream</strong>。</li><li><code>mapToLong(ToLongFunction)</code>：操作同上，但结果是 <strong>LongStream</strong>。</li><li><code>mapToDouble(ToDoubleFunction)</code>：操作同上，但结果是 <strong>DoubleStream</strong>。</li></ul><p><strong><code>flatMap()</code>组合流</strong></p><p><code>flatMap()</code> 做了两件事：将产生流的函数应用在每个元素上（与 <code>map()</code> 所做的相同），然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。相当于双重循环。</p><pre><code class="lang-java">// streams/FlatMap.javaimport java.util.stream.*;public class FlatMap {    public static void main(String[] args) {        Stream.of(1, 2, 3)        .flatMap(i -&gt; Stream.of(&quot;Gonzo&quot;, &quot;Fozzie&quot;, &quot;Beaker&quot;))        .forEach(System.out::println);    }}</code></pre><pre><code class="lang-java">import java.util.*;import java.util.stream.*;public class StreamOfRandoms {  static Random rand = new Random(47);  public static void main(String[] args) {    Stream.of(1, 2, 3, 4, 5)      .flatMapToInt(i -&gt; IntStream.concat(        rand.ints(0, 100).limit(i), IntStream.of(-1)))      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));  }}/* Output:58 -1 55 93 -1 61 61 29 -1 68 0 22 7 -1 88 28 51 89 9-1*/</code></pre><p>在这里我们引入了 <code>concat()</code>，它以参数顺序组合两个流。 如此，我们在每个随机 <code>Integer</code> 流的末尾添加一个 -1 作为标记。你可以看到最终流确实是从一组扁平流中创建的。</p><p>现有一个任务：去除字符串数组中出现多次的字母。</p><pre><code class="lang-java">import java.util.*;import java.util.stream.*;public class Test {    public static void main(String[] args) {        String[] words = new String[]{&quot;Hello&quot;, &quot;World&quot;};        Arrays.stream(words)                .map(word -&gt; word.split(&quot;&quot;))    //[1]                .distinct()                .forEach(System.out::print);    }}//[Ljava.lang.String;@30c7da1e[Ljava.lang.String;@5b464ce8</code></pre><p>该方法在第一步将每个元素分成了String数组，得到的类型是Stream(String[]),比较两个流元素之间的差异，发现它们不同(两个数组比较)</p><p><img src="/EruLv.github.io/2020/08/18/java%E5%9F%BA%E7%A1%802/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20201002162307882.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20201002162307882"></p><p>正确的做法应该是</p><pre><code class="lang-java">import java.util.*;import java.util.stream.*;public class Test {    public static void main(String[] args) {        String[] words = new String[]{&quot;Hello&quot;, &quot;World&quot;};        Arrays.stream(words)                .map(word -&gt; word.split(&quot;&quot;))                .flatMap(Arrays::stream)                .distinct()                .forEach(System.out::print);    }}//HeloWrd</code></pre><p>flatMap将两个流合并，即把二维数组降成一维。</p><p><img src="/EruLv.github.io/2020/08/18/java%E5%9F%BA%E7%A1%802/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20201002162630124.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20201002162630124"></p><h3 id="3-Optional类"><a href="#3-Optional类" class="headerlink" title="3.Optional类"></a>3.Optional类</h3><p>Optional类解决流为空的问题。</p><ul><li><code>findFirst()</code> 返回一个包含第一个元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li><li><code>findAny()</code> 返回包含任意元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li><li><code>max()</code> 和 <code>min()</code> 返回一个包含最大值或者最小值的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li></ul><p>空流可以通过 <code>Stream.&lt;String&gt;empty()</code> 创建。</p><pre><code class="lang-java">// streams/OptionalBasics.javaimport java.util.*;import java.util.stream.*;class OptionalBasics {    static void test(Optional&lt;String&gt; optString) {        if(optString.isPresent())            System.out.println(optString.get());         else            System.out.println(&quot;Nothing inside!&quot;);    }    public static void main(String[] args) {        test(Stream.of(&quot;Epithets&quot;).findFirst());        test(Stream.&lt;String&gt;empty().findFirst());    }}//Epithets//Nothing inside!</code></pre><p>当你接收到 <strong>Optional</strong> 对象时，应首先调用 <code>isPresent()</code> 检查其中是否包含元素。如果存在，可使用 <code>get()</code> 获取。</p><p><strong>便利函数</strong></p><p>有许多便利函数可以解包 <strong>Optional</strong> ，这简化了上述“对所包含的对象的检查和执行操作”的过程：</p><ul><li><code>ifPresent(Consumer)</code>：当值存在时调用 <strong>Consumer</strong>，否则什么也不做。</li><li><code>orElse(otherObject)</code>：如果值存在则直接返回，否则生成 <strong>otherObject</strong>。</li><li><code>orElseGet(Supplier)</code>：如果值存在则直接返回，否则使用 <strong>Supplier</strong> 函数生成一个可替代对象。</li><li><code>orElseThrow(Supplier)</code>：如果值存在直接返回，否则使用 <strong>Supplier</strong> 函数生成一个异常。</li></ul><pre><code class="lang-java">package streams;// streams/Optionals.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.import java.util.*;import java.util.stream.*;import java.util.function.*;public class Optionals {  static void basics(Optional&lt;String&gt; optString) {    if(optString.isPresent())      System.out.println(optString.get());    else      System.out.println(&quot;Nothing inside!&quot;);  }  static void ifPresent(Optional&lt;String&gt; optString) {    optString.ifPresent(System.out::println);  }  static void orElse(Optional&lt;String&gt; optString) {    System.out.println(optString.orElse(&quot;Nada&quot;));  }  static void orElseGet(Optional&lt;String&gt; optString) {    System.out.println(      optString.orElseGet(() -&gt; &quot;Generated&quot;));  }  static void orElseThrow(Optional&lt;String&gt; optString) {    try {      System.out.println(optString.orElseThrow(        () -&gt; new Exception(&quot;Supplied&quot;)));    } catch(Exception e) {      System.out.println(&quot;Caught &quot; + e);    }  }  static void test(String testName,    Consumer&lt;Optional&lt;String&gt;&gt; cos) {    System.out.println(&quot; === &quot; + testName + &quot; === &quot;);    cos.accept(Stream.of(&quot;Epithets&quot;).findFirst());    cos.accept(Stream.&lt;String&gt;empty().findFirst());  }  public static void main(String[] args) {    test(&quot;basics&quot;, Optionals::basics);    test(&quot;ifPresent&quot;, Optionals::ifPresent);    test(&quot;orElse&quot;, Optionals::orElse);    test(&quot;orElseGet&quot;, Optionals::orElseGet);    test(&quot;orElseThrow&quot;, Optionals::orElseThrow);  }}/* Output: === basics ===EpithetsNothing inside! === ifPresent ===Epithets === orElse ===EpithetsNada === orElseGet ===EpithetsGenerated === orElseThrow ===EpithetsCaught java.lang.Exception: Supplied*/</code></pre><p><strong>创建Optional</strong></p><p>当我们在自己的代码中加入 <strong>Optional</strong> 时，可以使用下面 3 个静态方法：</p><ul><li><code>empty()</code>：生成一个空 <strong>Optional</strong>。</li><li><code>of(value)</code>：将一个非空值包装到 <strong>Optional</strong> 里。</li><li><code>ofNullable(value)</code>：针对一个可能为空的值，为空时自动生成 <strong>Optional.empty</strong>，否则将值包装在 <strong>Optional</strong> 中。</li></ul><pre><code class="lang-java">package streams;// streams/CreatingOptionals.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.import java.util.*;import java.util.stream.*;import java.util.function.*;class CreatingOptionals {  static void test(String testName, Optional&lt;String&gt; opt) {    System.out.println(&quot; === &quot; + testName + &quot; === &quot;);    System.out.println(opt.orElse(&quot;Null&quot;));  }  public static void main(String[] args) {    test(&quot;empty&quot;, Optional.empty());    test(&quot;of&quot;, Optional.of(&quot;Howdy&quot;));    try {      test(&quot;of&quot;, Optional.of(null));    } catch(Exception e) {      System.out.println(e);    }    test(&quot;ofNullable&quot;, Optional.ofNullable(&quot;Hi&quot;));    test(&quot;ofNullable&quot;, Optional.ofNullable(null));  }}/* Output: === empty ===Null === of ===Howdyjava.lang.NullPointerException === ofNullable ===Hi === ofNullable ===Null*/</code></pre><p><strong>Optional对象操作</strong></p><p>当我们的流管道生成了 <strong>Optional</strong> 对象，下面 3 个方法可使得 <strong>Optional</strong> 的后续能做更多的操作：</p><ul><li><code>filter(Predicate)</code>：对 <strong>Optional</strong> 中的内容应用<strong>Predicate</strong> 并将结果返回。如果 <strong>Optional</strong> 不满足 <strong>Predicate</strong>(false) ，将 <strong>Optional</strong> 转化为空 <strong>Optional</strong> 。如果 <strong>Optional</strong> 已经为空，则直接返回空<strong>Optional</strong> 。</li><li><code>map(Function)</code>：如果 <strong>Optional</strong> 不为空，应用 <strong>Function</strong> 于 <strong>Optional</strong> 中的内容，并返回结果。否则直接返回 <strong>Optional.empty</strong>。</li><li><code>flatMap(Function)</code>：同 <code>map()</code>，但是提供的映射函数将结果包装在 <strong>Optional</strong> 对象中，因此 <code>flatMap()</code> 不会在最后进行任何包装。</li></ul><p>以上方法都不适用于数值型 <strong>Optional</strong>。一般来说，流的 <code>filter()</code> 会在 <strong>Predicate</strong> 返回 <code>false</code> 时移除流元素。而 <code>Optional.filter()</code> 在失败时不会删除 <strong>Optional</strong>，而是将其保留下来，并转化为空。</p><pre><code class="lang-java">package streams;// streams/OptionalFilter.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.import java.util.*;import java.util.stream.*;import java.util.function.*;class OptionalFilter {  static String[] elements = {    &quot;Foo&quot;, &quot;&quot;, &quot;Bar&quot;, &quot;Baz&quot;, &quot;Bingo&quot;  };  static Stream&lt;String&gt; testStream() {    return Arrays.stream(elements);  }  static void  test(String descr, Predicate&lt;String&gt; pred) {    System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);    for(int i = 0; i &lt;= elements.length; i++) {      System.out.println(        testStream()          .skip(i)          .findFirst()          .filter(pred));    }  }  public static void main(String[] args) {    test(&quot;true&quot;, str -&gt; true);    test(&quot;false&quot;, str -&gt; false);    test(&quot;str != \&quot;\&quot;&quot;, str -&gt; str != &quot;&quot;);    test(&quot;str.length() == 3&quot;, str -&gt; str.length() == 3);    test(&quot;startsWith(\&quot;B\&quot;)&quot;,         str -&gt; str.startsWith(&quot;B&quot;));  }}/* Output: ---( true )---Optional[Foo]Optional[]Optional[Bar]Optional[Baz]Optional[Bingo]Optional.empty ---( false )---Optional.emptyOptional.emptyOptional.emptyOptional.emptyOptional.emptyOptional.empty ---( str != &quot;&quot; )---Optional[Foo]Optional.emptyOptional[Bar]Optional[Baz]Optional[Bingo]Optional.empty ---( str.length() == 3 )---Optional[Foo]Optional.emptyOptional[Bar]Optional[Baz]Optional.emptyOptional.empty ---( startsWith(&quot;B&quot;) )---Optional.emptyOptional.emptyOptional[Bar]Optional[Baz]Optional[Bingo]Optional.empty*/</code></pre><h3 id="4-终端操作"><a href="#4-终端操作" class="headerlink" title="4.终端操作"></a>4.终端操作</h3><p>获取流的最终结果。</p><p><strong>数组</strong></p><ul><li><code>toArray()</code>：将流转换成适当类型的数组。</li><li><code>toArray(generator)</code>：在特殊情况下，生成自定义类型的数组</li></ul><pre><code class="lang-java">// streams/RandInts.javapackage streams;import java.util.*;import java.util.stream.*;public class RandInts {    private static int[] rints = new Random(47).ints(0, 1000).limit(100).toArray();    public static IntStream rands() {        return Arrays.stream(rints);    }}</code></pre><p><strong>循环</strong></p><ul><li><code>forEach(Consumer)</code>常见如 <code>System.out::println</code> 作为 <strong>Consumer</strong> 函数。</li><li><code>forEachOrdered(Consumer)</code>： 保证 <code>forEach</code> 按照原始流顺序操作。</li></ul><p>第一种形式是无序操作，在引入并行流时会和<code>forEachOrdered(Consumer)</code>有区别。<code>parallel()</code>：可实现多处理器并行操作。实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。因为我们采用的是内部迭代，而不是外部迭代，所以这是可能实现的。</p><p><strong>集合</strong></p><ul><li><code>collect(Collector)</code>：使用 <strong>Collector</strong> 收集流元素到结果集合中。</li><li><code>collect(Supplier, BiConsumer, BiConsumer)</code>：同上，第一个参数 <strong>Supplier</strong> 创建了一个新的结果集合，第二个参数 <strong>BiConsumer</strong> 将下一个元素收集到结果集合中，第三个参数 <strong>BiConsumer</strong> 用于将两个结果集合合并起来</li></ul><pre><code class="lang-java">package streams;// streams/TreeSetOfWords.java// (c)2017 MindView LLC: see Copyright.txt// We make no guarantees that this code is fit for any purpose.// Visit http://OnJava8.com for more book information.import java.util.*;import java.nio.file.*;import java.util.stream.*;public class TreeSetOfWords {  public static void  main(String[] args) throws Exception {    Set&lt;String&gt; words2 =      Files.lines(Paths.get(&quot;src/streams/TreeSetOfWords.java&quot;))        .peek(System.out::println)        .flatMap(s -&gt; Arrays.stream(s.split(&quot;\\W+&quot;)))        .filter(s -&gt; !s.matches(&quot;\\d+&quot;)) // No numbers        .map(String::trim)        .filter(s -&gt; s.length() &gt; 2)        .limit(100)        .collect(Collectors.toCollection(TreeSet::new));    System.out.println(words2);  }}/* Output:[Arrays, Collectors, Exception, Files, Output, Paths,Set, String, System, TreeSet, TreeSetOfWords, args,class, collect, file, filter, flatMap, get, import,java, length, limit, lines, main, map, matches, new,nio, numbers, out, println, public, split, static,stream, streams, throws, toCollection, trim, util,void, words2]*/</code></pre><p><strong>Files.</strong><code>lines()</code> 打开 <strong>Path</strong> 并将其转换成为由行组成的流。下一行代码以一个或多个非单词字符（<code>\\W+</code>）为分界，对每一行进行分割，结果是产生一个数组，然后使用 <strong>Arrays.</strong><code>stream()</code> 将数组转化成为流，最后<code>flatMap()</code>将各行形成的多个单词流，扁平映射为一个单词流。使用 <code>matches(\\d+)</code> 查找并移除全部是数字的字符串（注意,<code>words2</code> 是通过的）。然后用 <strong>String.</strong><code>trim()</code> 去除单词两边的空白，<code>filter()</code> 过滤所有长度小于3的单词，并只获取前100个单词，最后将其保存到 <strong>TreeSet</strong> 中。</p><p><strong>组合</strong></p><ul><li><code>reduce(BinaryOperator)</code>：使用 <strong>BinaryOperator</strong> 来组合所有流中的元素。因为流可能为空，其返回值为 <strong>Optional</strong>。</li><li><code>reduce(identity, BinaryOperator)</code>：功能同上，但是使用 <strong>identity</strong> 作为其组合的初始值。因此如果流为空，<strong>identity</strong> 就是结果。</li><li><code>reduce(identity, BiFunction, BinaryOperator)</code>：更复杂的使用形式（暂不介绍），这里把它包含在内，因为它可以提高效率。通常，我们可以显式地组合 <code>map()</code> 和 <code>reduce()</code> 来更简单的表达它。</li></ul><p>Lambda 表达式中的第一个参数 <code>fr0</code> 是 <code>reduce()</code> 中上一次调用的结果。而第二个参数 <code>fr1</code> 是从流传递过来的值。</p><pre><code class="lang-java">class Frobnitz {  int size;  Frobnitz(int sz) { size = sz; }  @Override  public String toString() {    return &quot;Frobnitz(&quot; + size + &quot;)&quot;;  }  // Generator:  static Random rand = new Random(47);  static final int BOUND = 100;  static Frobnitz supply() {    return new Frobnitz(rand.nextInt(BOUND));  }}public class Reduce {  public static void main(String[] args) {    Stream.generate(Frobnitz::supply)      .limit(10)      .peek(System.out::println)      .reduce((fr0, fr1) -&gt; fr0.size &lt; 50 ? fr0 : fr1)      .ifPresent(System.out::println);  }}</code></pre><p><code>reduce()</code> 中的 Lambda 表达式使用了三元表达式来获取结果，当 <code>fr0</code> 的 <code>size</code> 值小于 50 的时候，将 <code>fr0</code> 作为结果，否则将序列中的下一个元素即 <code>fr1</code>作为结果。当取得第一个 <code>size</code> 值小于 50 的 <code>Frobnitz</code>，只要得到这个结果就会忽略流中其他元素。这是个非常奇怪的限制， 但也确实让我们对 <code>reduce()</code> 有了更多的了解。</p><p><strong>匹配</strong></p><ul><li><code>allMatch(Predicate)</code> ：如果流的每个元素提供给 <strong>Predicate</strong> 都返回 true ，结果返回为 true。在第一个 false 时，则停止执行计算。</li><li><code>anyMatch(Predicate)</code>：如果流的任意一个元素提供给 <strong>Predicate</strong> 返回 true ，结果返回为 true。在第一个 true 是停止执行计算。</li><li><p><code>noneMatch(Predicate)</code>：如果流的每个元素提供给 <strong>Predicate</strong> 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。</p><p><strong>查找</strong></p></li><li><p><code>findFirst()</code>：返回第一个流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</p></li><li><code>findAny(</code>：返回含有任意流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li></ul><p><strong>信息</strong></p><ul><li><code>count()</code>：流中的元素个数。</li><li><code>max(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最大”元素。</li><li><code>min(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最小”元素。</li></ul><p><strong>数字流信息</strong></p><ul><li><code>average()</code> ：求取流元素平均值。</li><li><code>max()</code> 和 <code>min()</code>：数值流操作无需 <strong>Comparator</strong>。</li><li><p><code>sum()</code>：对所有流元素进行求和。</p></li><li><p><code>summaryStatistics()</code>：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。</p></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>计算机图形学复习</title>
    <link href="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
    <url>/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="计算机图形学复习"><a href="#计算机图形学复习" class="headerlink" title="计算机图形学复习"></a>计算机图形学复习</h1><h2 id="1-CG基础"><a href="#1-CG基础" class="headerlink" title="1.CG基础"></a>1.CG基础</h2><h3 id="1-1概念"><a href="#1-1概念" class="headerlink" title="1.1概念:"></a>1.1概念:</h3><p><strong>几何学(geometry)</strong>:几何学是研究在n维空间中物体之间关系的一门学科。</p><p><strong>几何学原语/图元(primitives)</strong>:构建复杂的物体需要的最基础的元素。</p><p><strong>三个基本元素:</strong>标量(Scalars),向量(Vectors),点(Points)</p><p><strong>标量</strong>:标量是服从一组规则的对象，标量可以定义为集合的成员，可以通过两个操作（加法和乘法）结合一些基本公理（关联性，可交换性，逆函数）进行组合.标量没有几何属性。</p><p><strong>向量</strong>:向量由幅度(Magnitude)和方向(Direction)两个属性组成。</p><h3 id="1-2-Coordinate-Free-Geometry-无坐标几何"><a href="#1-2-Coordinate-Free-Geometry-无坐标几何" class="headerlink" title="1.2 Coordinate-Free Geometry(无坐标几何)"></a>1.2 Coordinate-Free Geometry(无坐标几何)</h3><p><strong>笛卡尔坐标系Cartesian Coordinate</strong>:直角坐标系和斜坐标系的统称。</p><p>物理上，点的存在与坐标系无关，如，如果两个三角形两条边及其夹角相等，则他们相同(全等)。</p><h3 id="1-3-向量空间"><a href="#1-3-向量空间" class="headerlink" title="1.3 向量空间"></a>1.3 向量空间</h3><p>1.向量空间中，向量的起点不同，但方向和长度相同的向量为同一向量。</p><p>欧几里得空间:是向量空间的扩展，增加了对大小或者距离的度量。</p><p>2.仿射空间(Affine Spaces): 点的集合+向量空间。</p><p>操作:</p><ul><li>Vector-vector addition -&gt; vector</li><li>Scalar-vector multiplication -&gt;vector</li><li>Point-vector addition -&gt; point</li><li>Scalar-scalar operations -&gt;scalar</li><li>scalar – 以上运算均与坐标系无关</li></ul><p>3.点的参数形式</p><p>参数坐标 : $P(\alpha) = P_0 + \alpha d $</p><p>点的线性运算:$P1 + P_2 = P_1 + (P2 - 0)$,得到的还是一个坐标</p><p>4.凸面体</p><p>如果该物体内部任意两个点之间组成的线段上的所有点均在该物体内部，则称该物体为凸的(convex).</p><p>5.点的仿射和(Affine Sum)</p><p>$P = a_1P_1 + a_2P_2 + …+a_nP_n$</p><p>当且仅当$a1+a2 + …a_n = 1$,则称这是点$P_1,…P_n$的仿射和(Affine Sum)。如果$a_i ≥ 0$则我们得到$P_i$的一个凸包(convex hull)，即可用这样的和为1的$\alpha$表示凸多边形内部任意一点。</p><p>6.向量乘</p><p>点乘，叉乘(右手准则)</p><p>7.曲线和面</p><p>如何定义曲线和面</p><p>曲线:形式$为P（x）$的一个参数实体，其中函数是非线性的。</p><p>面:曲线由两个函数组成的参数定义$P(a,b)$</p><p>8.平面(Plane)</p><p>可以由一个点+两个向量或者三个点表示。</p><p>9.法向量</p><p>每个平面都有法向量，平面上的向量点乘法向量结果均为0.</p><p>10.线性无关</p><p>一系列向量$v_1,v_2,…,v_n$成为线性无关的如果:</p><script type="math/tex; mode=display">\alpha_1v_1 + \alpha_2v_2 + \alpha_3v_3 +... = 0 \\iff \alpha_1 = \alpha_2 = ... = 0</script><p>11.维度</p><p>向量空间中，线性无关向量的最大数量称为线性空间的维度。</p><p>12.坐标系中坐标的表示</p><p>设$v_1，v2,…v_n$是向量空间的一组基，一个向量可以表示为$v = \alpha_1v_1 + \alpha_2v_2 +… + \alpha_nv_n$</p><p>其中$\alpha_i$为标量</p><p>13.框架Frames</p><p>因为坐标系只能表示向量而不能表示点，所以加上原点。即</p><p>原点+坐标系构成框架Frame,可以表示向量空间中的点。一个三维Frame的形式:$(P_0,v_1,v2,v3)$</p><p>每个点可以记作:</p><script type="math/tex; mode=display">P = P_0 + \beta_1 v_1 + \beta_2 v_2 + ... + \beta_n v_n</script><p>14.三维空间的四维表示</p><script type="math/tex; mode=display">v = \alpha_1 v_1 + \alpha_2 v_2 + \alpha_3 v_3 = [\alpha_1\alpha_2 \alpha_3 1][v_1 v_2 v_3 P_0]^T</script><script type="math/tex; mode=display">P = P_0 + \beta_1 v_1 + \beta_2 v_2 + \beta_3 v_3 = [\beta_1 \beta_2  \beta_3  0][v_1 v_2 v_3 P_0]^T</script><p>所以向量可以表示为:</p><script type="math/tex; mode=display">v = [\alpha_1 \alpha_2 \alpha_3 0]^T\\\p = [\beta_1 \beta_2 \beta_3 1]^T</script><p>15.齐次坐标系</p><p>三维空间用四维坐标系表示[x,y,z,w]</p><p>vector: w=  0;</p><p>point: w !=0, x = x/w, y = y/w, z = z/w;</p><h2 id="2-建模和渲染的Pipeline-amp-计算机观察"><a href="#2-建模和渲染的Pipeline-amp-计算机观察" class="headerlink" title="2. 建模和渲染的Pipeline&amp;计算机观察"></a>2. 建模和渲染的Pipeline&amp;计算机观察</h2><h3 id="2-1-坐标变换Pipeline"><a href="#2-1-坐标变换Pipeline" class="headerlink" title="2.1 坐标变换Pipeline:"></a>2.1 坐标变换Pipeline:</h3><ol><li>几何建模</li><li>将建模的物体放入世界坐标系。</li><li>选择摄像机的位置和方向</li><li>将物体从世界坐标系变换到视角坐标系并且投影到图像平面。</li></ol><p><strong>输入:</strong></p><p>几何模型(顶点，法向量，贴图坐标)</p><p>光照/材质模型（着色器，包括光源位置、光的颜色、光照强度、纹理映射、漫反射贴图等）</p><p>视点(ViewPoint)+投影平面(Projection Plane)</p><p><strong>输出:</strong></p><p>渲染好的彩色(深度)图片。</p><p>将模型从Object坐标系变换到Image坐标系。</p><h3 id="2-2图形学渲染管线-Modern-Graphics-Pipeline"><a href="#2-2图形学渲染管线-Modern-Graphics-Pipeline" class="headerlink" title="2.2图形学渲染管线(Modern Graphics Pipeline)"></a>2.2图形学渲染管线(Modern Graphics Pipeline)</h3><p><strong>1.现代图形学渲染管线Modern Graphics Pipeline</strong></p><ol><li>把顶点投影到2D平面</li><li>栅格化处理，找到每个像素对应的位置。</li><li>计算每个像素的颜色。</li><li>测试可见性(z-buffer),更新帧缓冲区(frame buffer)颜色。</li></ol><p><strong>2.经典图形学渲染管线</strong></p><p>(几何绘制流水线)</p><p>顶点-&gt;<code>顶点处理模块</code>-&gt;<code>裁剪和图元组装模块</code>-&gt;<code>光栅化模块</code>-&gt;<code>片元处理模块</code>-&gt;像素</p><p><strong>Vertex Processor</strong>:</p><p>负责顶点的坐标变换，把顶点从一个坐标系转换到另一个坐标系(涉及两个重要矩阵:model-view矩阵和projection矩阵)。另外还负责计算每个顶点的颜色。</p><p><code>物体坐标系</code>-&gt;<code>世界坐标系</code>-&gt;<code>视角坐标系</code>-&gt;<code>图像坐标系</code></p><p><strong>Clipper and Primitive Assembler</strong>:</p><p>成像系统不可能一次对整个场景成像，所以需要将摄像机视角外的顶点裁剪掉。裁剪必须针对逐个图元进行，而不是针对逐个顶点，所以在裁剪之前必须把顶点组装成线段、多边形这样的对象，这一过程叫做图元组装。</p><p><strong>Rasterize</strong></p><p>裁剪后的图元仍是用顶点表示的，为了生成frame buffer中的像素还必须进一步处理。如果物体没有被裁剪出去，则必须为frame buffer中的像素分配合适的颜色。光栅化为每个图元生成一组片元(fragments)，片元是携带相关信息的潜在像素。每个片段都在frame buffer中有位置，并且有颜色、深度等属性。</p><p><strong>Fragment Processor</strong></p><p>利用光栅化模块生成的片元（Fragments）来更新Frame buffer中的元素(计算Frame buffer中的颜色)。</p><p>片元确定帧缓冲区中相应像素的颜色，颜色可以通过纹理映射或顶点颜色的插值来确定，片元可能被更靠近相机的其他片段挡住。</p><p>3.可编程流水线:</p><p>顶点处理模块和片元处理模块对于应用程序来说是可编程的，程序员只需要编写<strong>顶点着色器</strong>和<strong>片元着色器</strong>。</p><h3 id="2-3-变换"><a href="#2-3-变换" class="headerlink" title="2.3 变换"></a>2.3 变换</h3><p>1.简单变换</p><ul><li>平移Translation</li><li>旋转Rotation</li><li>等比例(各向同性)缩放Isotropic scaling</li></ul><p>简单变换是可逆的。</p><p>2.欧几里得变换/刚体变换</p><p>变换后角度不变，距离不变</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\rigidbody.png" srcset="/EruLv.github.io/img/loading.gif" alt="rigidbody"></p><p>3.相似度变换Similarity Transforms</p><p>保持角度不变，形状相同，只是比例，方向和位置不同.</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\similarity.png" srcset="/EruLv.github.io/img/loading.gif" alt="similarity"></p><p>4.线性变换</p><p>包括旋转，缩放，反射，</p><p>错切(shear)，直观理解就是把物体一边固定，然后拉另外一边,二维坐标系中，y坐标保持不变，x坐标平移。</p><p>线性变换定义如下:</p><script type="math/tex; mode=display">L(p + q) = L(p) + L(q)\\L(ap) = aL(p)</script><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Linear.png" srcset="/EruLv.github.io/img/loading.gif" alt="Linear"></p><p><strong>注意，平移变换不是线性变换，因此3D平移变换不能用三维矩阵实现</strong></p><script type="math/tex; mode=display">f(p) = p + t\\f(ap) = ap + t ≠ a(p + t) = af(p)\\f(p+q) = p + q + t ≠(p+t) + (q +t) = f(p) + f(q)</script><p>5.仿射变换Affine Transformations</p><p>变换之前平行的边，变换后依旧平行</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\affine.png" srcset="/EruLv.github.io/img/loading.gif" alt="affine"></p><p>6.投影变换Projective Transformations</p><p>线依旧是线</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\projective.png" srcset="/EruLv.github.io/img/loading.gif" alt="projective"></p><p>7.Transforms are groups</p><p>你可以用一个变换来代替一连串变换。</p><p>比如， object-to-world transformation, world-to-view transformation,view-to-image transformation能够用 object-to image transformation一个变换表示。</p><h3 id="2-4观察投影"><a href="#2-4观察投影" class="headerlink" title="2.4观察投影"></a>2.4观察投影</h3><p>二维的线性变换可以用二维矩阵来表示，但是二维的仿射变换需要用一个额外的坐标系来表示平移。</p><p>其次坐标系就是在原来的向量空间中添加一个额外的维度，比如用三维坐标系就可以表示二维空间的仿射变换。</p><p><strong>1.投影中的相等</strong>:</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\1.png" srcset="/EruLv.github.io/img/loading.gif" alt="1"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\2.png" srcset="/EruLv.github.io/img/loading.gif" alt="2"></p><p>w的值(不为0)归一化后不影响最终成像的位置(对应像素还是一样的)。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\why.png" srcset="/EruLv.github.io/img/loading.gif" alt="why"></p><p>从相机的角度来看，线上的所有3D点都位于图像中相同的2D坐标上。从这个意义上讲，所有这些3D点都是“相同的”。</p><p>警告⚠:当我们把w归一化后，由于我们将场景展平到z = 1平面上，因此我们丢失了有关到相机距离的所有信息。(Z-buffer来解决这个问题)</p><p><strong>2.使用齐次坐标系的好处</strong></p><p>以上所有的投影变换在其次坐标系中都是线性的。</p><p><strong>3.投影 Orthographic vs. Perspective</strong></p><p>投影包括两个基本操作:<strong>模-视变换(model-view matirx)</strong>和<strong>投影变换(projection matrix)</strong></p><p><strong>模-视变换</strong>:将模型从对象坐标系变换到世界坐标系(模型变换)，最后变换到相机坐标系(视角变换)。</p><p><strong>投影变换</strong>:把指定的投影应用于顶点，并把位于指定视见体内部的对象变换到位于裁剪坐标系中的裁剪立方体的内部。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\view.png" srcset="/EruLv.github.io/img/loading.gif" alt="view"></p><p><strong>4.两个主要投影</strong></p><p><strong>(1)正交投影Orthographic :</strong>其视景体为长方体，投影物体的大小不会随视点与远平面之间的距离而变.沿着z轴将所有点投影到z = 0的平面上。特点:变换矩阵中z所在行全为0.视见体为正六边形(边长为2的正方体)，正投影只“看到”了视见体内的对象。距离和形状都没有失真，适合在工程中使用。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\orthographic.png" srcset="/EruLv.github.io/img/loading.gif" alt="orthographic"></p><p><strong>(2)透视投影Perspective:</strong> 将沿z轴的所有点投影到z = d的平面上，并在原点上放置视点。特点:投影后距离观察者越远，成像越小。</p><p>【变换矩阵推导】</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\prespective.png" srcset="/EruLv.github.io/img/loading.gif" alt="prespective"></p><script type="math/tex; mode=display">相似三角形\frac{x}{z} = \frac{x'}{d}\\投影到z = d平面上的坐标x' = \frac{x}{z/d}</script><p>投影到z = 0上。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\pers.png" srcset="/EruLv.github.io/img/loading.gif" alt="pers"></p><p>消失点(vanishing point)</p><p>透视投影中，物体上的平行线（不平行于投影平面）会聚在投影中的单个点上，这个点就是消失点。</p><p>透视投影的优缺点:</p><ul><li>物体离观察者越远成像越小，与人的现实感受相符。</li><li>不均匀缩放:沿线的相等距离投影后距离不一定相等。</li><li>只有与投影平面平行的平面上的角投影后角度不变。</li><li>用手构造比平行投影更困难（但用计算机难度更大）。</li></ul><p><strong>5.计算机视图Computer Viewing</strong></p><p>计算机中用到了3中视图处理:</p><p>摄像机定位，设置model-view 矩阵</p><p>选择镜头，设置投影方式</p><p>裁剪，设置投影的参数，选择视景范围。</p><h3 id="2-5-OpenGL-Camera"><a href="#2-5-OpenGL-Camera" class="headerlink" title="2.5 OpenGL Camera"></a>2.5 OpenGL Camera</h3><p><strong>1.基础</strong></p><p>OpenGL中，相机初始化在原点，指向z轴负方向，默认的投影方式是正交的。</p><p>如果我们想要显示一个在原点的物体，包括它的z轴正坐标和负坐标部分，我们需要使摄像机远离物体。可以采取的措施是:</p><ul><li>将摄像机朝z轴正方向平移。</li><li>或将物体朝z轴负方向平移。</li></ul><p>用代码表示是:</p><p>即使物体朝着z轴负方向移动。</p><pre><code class="lang-c++">glTranslatef(0.0,0.0,-d);     //物体向z轴正方向or相机朝z轴正方向平移//d &gt; 0</code></pre><p>旋转相机</p><pre><code class="lang-c++">glRotatef(-90.0, 0.0, 1.0, 0.0);     //旋转角度，选装轴，绕y轴顺时针旋转90°</code></pre><p>注意，OpenGL中，写在后面的变换会被先执行</p><pre><code class="lang-c++">glMatrixMode(GL_MODELVIEW)glLoadIdentity();glTranslatef(0.0, 0.0, -d);    //P1glRotatef(-90.0, 0.0, 1.0, 0.0); //P2</code></pre><p>上述代码表示先绕y轴顺时针旋转90°，再朝着z轴负方向平移距离d。$P_1P_2X = Y$</p><p><strong>2.LookAt</strong></p><p><code>gluLookAt(ex, ey, ez, cx, cy, cz, qx, qy, qz)</code>用于确定相机的位置和姿态。</p><p>分别表示<strong>相机位置、相机朝向、朝上向量(up vector)</strong></p><p><code>glLookAt</code>将世界坐标系转换为视角坐标系tuv。</p><p>已知世界坐标系x-y-z，求t-u-v</p><pre><code class="lang-c++">v = (ex-cx,ey-cy,ez-cz)t = q×vu = v×t//最后需要Normalize t, u and v</code></pre><p>变换矩阵,先将相机移动到原点，然后将x-y-z变换为t-u-v</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\lookAt.png" srcset="/EruLv.github.io/img/loading.gif" alt="lookAt"></p><p><code>gluLookAt(ex, ey, ez, cx, cy, cz, qx, qy, qz)</code>等价于上述两个矩阵的乘机。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\eg1.png" srcset="/EruLv.github.io/img/loading.gif" alt="eg1"></p><p>model-view变换是最后执行的，所以从渲染的角度，代码应该写在最前面。</p><p><strong>3.正投影Orthogonal Projection</strong></p><pre><code class="lang-c++">void glOrtho(GLdouble left, GLdouble right,GLdouble bottom, GLdouble top, GLdouble near, GLdouble far);</code></pre><p>设置一个矩形</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Ortho.png" srcset="/EruLv.github.io/img/loading.gif" alt="Ortho"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Ortho2.png" srcset="/EruLv.github.io/img/loading.gif" alt="Ortho2"></p><p><strong>4.透视投影Perspective Projection</strong></p><p><strong>Frustum视锥</strong></p><p><code>glFrustum(GLdouble left,GLdouble Right,GLdouble bottom,GLdouble top,GLdouble near,GLdouble far)</code></p><p>左右下上近远</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\frus.png" srcset="/EruLv.github.io/img/loading.gif" alt="frus"></p><p>不过不太常用，因为很难得到想要的视角，所以要用到另一个函数:</p><pre><code class="lang-c++">void gluPerspective (GLdouble fovy, GLdouble aspect,GLdouble zNear, GLdouble zFar)</code></pre><p>fovy:视角，度数,裁剪体的底面和顶面之间的夹角</p><p>asp:x和y的比例(w/h)</p><p>znear:相机到最近裁剪面的距离</p><p>zfar:相机到最远裁剪面的距离</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\per.png" srcset="/EruLv.github.io/img/loading.gif" alt="per"></p><p>透视投影的流水线:</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\proj.png" srcset="/EruLv.github.io/img/loading.gif" alt="proj"></p><h3 id="2-6-重点，两种投影-函数-的原理"><a href="#2-6-重点，两种投影-函数-的原理" class="headerlink" title="2.6 重点，两种投影(函数)的原理"></a>2.6 重点，两种投影(函数)的原理</h3><p><strong>Ortho:</strong></p><p>$P = MST$,</p><p>T：将矩形中心移动到原点</p><p>S:缩放，使得$x = ±1，y=±1，z =±1 $</p><p>M:将z分量为0.</p><p><strong>Projective</strong>:</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200903204800536.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200903204800536"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200903205034574.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200903205034574"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200903210518052.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200903210518052"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200903210917747.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200903210917747"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200903210840701.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200903210840701"></p><p><a href="https://blog.csdn.net/popy007/article/details/1797121" target="_blank" rel="noopener">https://blog.csdn.net/popy007/article/details/1797121</a></p><h3 id="2-7-Z-Buffer原理"><a href="#2-7-Z-Buffer原理" class="headerlink" title="2.7 Z-Buffer原理"></a>2.7 Z-Buffer原理</h3><p>z-buffer 作用:消除不可见面</p><h2 id="3-裁剪、光栅化和隐藏面消除"><a href="#3-裁剪、光栅化和隐藏面消除" class="headerlink" title="3.裁剪、光栅化和隐藏面消除"></a>3.裁剪、光栅化和隐藏面消除</h2><p>裁剪就是把位于视见体之外的对象删除，从而在最终显示的图像上这些对象是不可见的。</p><p>光栅化是从裁剪后的对象生成片元的过程。</p><p>隐藏面的消除就是确定可见对象的片元，即位于视见体之内且没有被阻挡的对象。</p><h3 id="3-1图形绘制的四个主要任务"><a href="#3-1图形绘制的四个主要任务" class="headerlink" title="3.1图形绘制的四个主要任务"></a>3.1图形绘制的四个主要任务</h3><p><strong>建模</strong>，寻找一组用来定义几何对象的顶点数据，除生成几何对象外，建模还能完成一切其他任务，如裁剪。</p><p><strong>几何处理</strong>， 几何处理包括四个处理过程:投影、图元装配、裁剪和明暗处理。</p><p><strong>光栅化</strong>，</p><p><strong>片元处理</strong></p><h3 id="3-2裁剪"><a href="#3-2裁剪" class="headerlink" title="3.2裁剪"></a>3.2裁剪</h3><p><strong>规范化设备坐标系(Canonical View Volume)</strong>: 经过投影变换后，所有图元潜在可见部分都位于一个变长为2中心位于原点的立方体的内部，这个坐标系称为规范化设备坐标系。</p><h4 id="3-2-1-线段的裁剪"><a href="#3-2-1-线段的裁剪" class="headerlink" title="3.2.1 线段的裁剪"></a>3.2.1 线段的裁剪</h4><p><strong>1.Cohen-Sutherland Algorithm</strong></p><p>思想:排除尽可能多的不需要计算交点的线段，使用浮点数减法和位操作代替大量高开销的浮点数乘法和除法。</p><p>步骤:</p><p>(1)首先把裁剪窗口的4条边延长到无限远，把整个二维空间分割成9个区域。</p><p>(2)给每个区域根据二进制编码。$y<em>{max}y</em>{min}x<em>{max}x</em>{min}$</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\code.png" srcset="/EruLv.github.io/img/loading.gif" alt="code"></p><p>(3)根据一条线段的两个端点的编码值进行讨论:</p><ul><li>case 1: o1 = o2 = 0,线段的两个端点都位于裁剪窗口内部，需要把该线段送入光栅化模块进行光栅化处理。</li><li>case 2: 一个为0，一个不为0，线段的一个端点位于裁剪窗口内，另一个位于裁剪窗口之外，必须进行裁剪处理，非0的端点编码说明了线段与裁剪窗口的哪条边或者哪两条边相交，必须计算一个或两个交点(交点可能在延长线上)，需要注意的是，当计算完一个交点后，要计算该交点的编码，从而确定是否需要另一个求交运算。</li><li>case 3: $o_1 \&amp; o_2 ≠ 0$， 线段两个端点按位与操作，可以确定这两个端点是否位于裁剪窗口某条裁剪边的同一侧。如果满足，则可以丢弃该条线段。</li><li>case 4: $o_1 \&amp; o_2 = 0$,线段两个端点都为与裁剪窗口之外，但它们分别位于裁剪窗口的两条不同裁剪边的外侧，不能判断是否完全在窗口外，计算线段与裁剪窗口某边的交点，并根据新的交点编码重新进行上述判断。</li></ul><p>(4)根据上述判断该线段是接收还是裁剪，如果需要部分裁剪，找到位于窗口外的端点，然后寻找与线段相交的窗口边并且求出交点。</p><p>(5)把位于窗口外的顶点替换成交点从而实现裁剪。</p><p>推广到3维: 27个区域，6位编码。</p><p><strong>优点</strong>:</p><p>编码判断只需要进行布尔运算，大大减少了需要求交点的运算，当要处理的线段非常多而实际显示的线段非常少时，该算法很有效。可以有效地拓展到三维。</p><p><strong>缺点</strong>:</p><p>对某些线段，必须进行多次裁剪处理。在线段缩短过程中需要多次重复执行。</p><p><strong>2.Cyrus-Berk算法</strong></p><p>可以处理任意凸多面体对线段的裁剪。</p><p>思路:</p><ul><li>用向量形式表示线段$P(t) = P_0 + t(P_1-P_0)$,</li><li>将多边形的边延长为直线，求线段与凸多边形各个边的延长线的交点。</li><li>判断交点是inside还是outside的，假设所有边的法向量都指向多边形内部，N是其中一条边的法向量，A是边上一点，则如果$N·(P_1- P_0)<0$,则是leaving points, $n·(p_1 - p_0)>0$,则是entering point. 如果$N·(P_1 - P_0) =0$,需要判断该线段是否跟多边形有交点，设A是边i上的任意一点，$N_i·(P_0 - A_i) &lt;0$,则线段和多边形没有交点，else,跳到多边形的下一条边计算计算交点。</0$,则是leaving></li><li>当交点处于射入多边形位置时，取$t<em>{s} = max{0,max{t_i|N_i·(P_1-P_0)&gt;0}}$,$t</em>{e} = min{1,min{t_i|N_i·(P_1-P_0)&lt;0}}$,</li></ul><p>求交点:</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200903214014183.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200903214014183"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200903215633186.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200903215633186"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200903215839482.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200903215839482"></p><p><strong>3.Liang-Barsky裁剪算法</strong></p><p>讲的不错:</p><p><a href="https://www.cnblogs.com/cnblog-wuran/p/9813841.html" target="_blank" rel="noopener">https://www.cnblogs.com/cnblog-wuran/p/9813841.html</a></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200903221641125.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200903221641125"></p><p>入射点求最大的t，出射点求最小的t。</p><p>优点:</p><p>不需要对线段进行多次裁剪处理，因此效率比Cohen-Sutherland算法效率高。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\cmp.png" srcset="/EruLv.github.io/img/loading.gif" alt="cmp"></p><h4 id="3-2-2-多边形裁剪"><a href="#3-2-2-多边形裁剪" class="headerlink" title="3.2.2 多边形裁剪"></a>3.2.2 多边形裁剪</h4><p>一般裁剪的对象时凸多边形，要么禁止使用凹多边形，要么将凹多边形剖分为一组凸多边形。</p><p><strong>1.Surtherland-Hodgeman算法</strong></p><p>思想:</p><p>分别考虑左上右下四条边所在的直线，依次裁剪掉位多边形于它们不可见一侧的部分,当做完所有边之后，多边形裁剪就完成了。</p><p><a href="https://blog.csdn.net/damotiansheng/article/details/43274183" target="_blank" rel="noopener">https://blog.csdn.net/damotiansheng/article/details/43274183</a></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\sutherland.png" srcset="/EruLv.github.io/img/loading.gif" alt="sutherland"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\sth.png" srcset="/EruLv.github.io/img/loading.gif" alt="sth"></p><p>保持顺序，输出的始终是终点。</p><p>使用bounding box提高速度。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\bbox.png" srcset="/EruLv.github.io/img/loading.gif" alt="bbox"></p><h3 id="3-3-光栅化"><a href="#3-3-光栅化" class="headerlink" title="3.3 光栅化"></a>3.3 光栅化</h3><p>Fragment片元是潜在的像素，每个片元都具有一个颜色属性以及在屏幕坐标中的位置属性，还包括用于隐藏面消除的深度信息。</p><p>OpenGL中，像素的中心位于半整数值的位置。</p><h4 id="3-3-1线段光栅化"><a href="#3-3-1线段光栅化" class="headerlink" title="3.3.1线段光栅化"></a>3.3.1线段光栅化</h4><p><strong>1.DDA算法</strong></p><p>思想:</p><p>两个端点(x1,y1), (x2,y2)四舍五入后取整。</p><p>根据两个端点求斜率$\delta$。</p><p>$dy = \delta dx$</p><p>假设$0&lt;=\delta &lt;=1$</p><p>从其中一个端点x1开始$dx = 1$,$dy = \delta$</p><p>如果斜率大于1，由于两个像素之间间隔很大，生成的线段可能连续性不好，所以可以交换x和y，再进行上面步骤。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200904153756128.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200904153756128"></p><p><strong>2.Bresenham 算法</strong></p><p>相比DDA,没有浮点数加法运算。</p><p>类似于DDA,斜率满足$0≤m≤1$，x += 1时，y要么是y，要么是y+1.</p><p>假设a表示y方向上直线距离上方像素(y+1)的位置,b表示距离下方像素(y)的位置。</p><p>$d = (x_2 - x_1)(a - b)$为判定向量，</p><p>d&gt;0,选y，d&lt;0,选y+1.</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200904154554146.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200904154554146"></p><p>d的取值是有规律的，可以发现当值增加1时，a要么增加m，要么减少m-1,b要么减少-m,要么增加1-m.可以通过迭代方法获得下一个位置的d值:</p><pre><code>if d_k &gt; 0:    q = 2*dy;else:    q = 2(dy-dx);</code></pre><script type="math/tex; mode=display">d_{k+1} = d_k - q</script><p>每个连续的像素计算只需要一个加法运算和一个符号判断，所以该算法效率非常高。</p><h4 id="3-3-2多边形光栅化"><a href="#3-3-2多边形光栅化" class="headerlink" title="3.3.2多边形光栅化"></a>3.3.2多边形光栅化</h4><p><strong>1.（xxx算法）</strong></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Raster.png" srcset="/EruLv.github.io/img/loading.gif" alt="Raster"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\edge.png" srcset="/EruLv.github.io/img/loading.gif" alt="edge"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\smarter.png" srcset="/EruLv.github.io/img/loading.gif" alt="smarter"></p><p><strong>2.Oldskool Rasterization</strong></p><p>思想:</p><p>使用线栅格化方法计算边界，然后从边界左边像素开始，从左向右填充内部像素，直到遇到右边边界像素。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\oldskool.png" srcset="/EruLv.github.io/img/loading.gif" alt="oldskool"></p><p><strong>3.Homogeneous Rasterization</strong></p><p>思想: 在3D空间种执行栅格化来避免投影。用3D中的平面来代替2D中的线，平面要通过平面上的线和viewpoint.</p><p>跟第一个算法有啥区别？</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\hr.png" srcset="/EruLv.github.io/img/loading.gif" alt="hr"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\hjrr.png" srcset="/EruLv.github.io/img/loading.gif" alt="hjrr"></p><h3 id="3-4隐藏面消除"><a href="#3-4隐藏面消除" class="headerlink" title="3.4隐藏面消除"></a>3.4隐藏面消除</h3><p><strong>Z-buffer算法</strong></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\zbuffer.png" srcset="/EruLv.github.io/img/loading.gif" alt="zbuffer"></p><p>算法描述:</p><p>对多边形逐个进行光栅化处理，对某个多边形上的每个片元，进行光栅化处理，对片元内的每个像素，使用插值法计算深度值，在同一位置(x,y),如果z(x,y) &lt; zbuffer(x,y)，则更新zbuffer内的值。最后更新frame buffer内的值。</p><p><strong>插值</strong></p><p>注意,在三维世界坐标系中的线性插值与投影后在屏幕坐标系中的线性插值不是等价的。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\interpolation.png" srcset="/EruLv.github.io/img/loading.gif" alt="interpolation"></p><p>插值方法:<strong>重力坐标插值(Barycentric Interpolation)</strong></p><p>算法流程:</p><p>计算重心$P = \alpha a + \beta b + \gamma c$,其中，a,b,c为点坐标，前面的为系数，我们求这三个系数，然后根据系数分配插值。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\b.png" srcset="/EruLv.github.io/img/loading.gif" alt="b"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\bary.png" srcset="/EruLv.github.io/img/loading.gif" alt="bary"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\zbf.png" srcset="/EruLv.github.io/img/loading.gif" alt="zbf"></p><h3 id="3-5走样Aliasing"><a href="#3-5走样Aliasing" class="headerlink" title="3.5走样Aliasing"></a>3.5走样Aliasing</h3><p><strong>走样</strong>:连续值转换为离散值导致图像出现视觉上可见的误差。</p><p><a href="https://blog.csdn.net/qq_38065509/article/details/105598277" target="_blank" rel="noopener">https://blog.csdn.net/qq_38065509/article/details/105598277</a></p><p><strong>0.MIPSampling</strong></p><p><strong>1.超采样反走样(Super Sampling AA，SSAA)</strong></p><p>思想:</p><p>将每个像素点细分成多个采样点，使用更多的采样点采样，分别计算每个采样点的颜色，求每个像素点对应采样点的颜色的平均值，作为像素点的颜色。</p><p>先上采样，后降采样。</p><p><strong>2.多重采样MSAA</strong></p><p>Multi-sampling或者说Multi-sample Anti-Alias (简称MSAA)是一种抗锯齿的技术，它通过在一个像素上进行多次采样多次计算并最终汇总(Resolve to single-sample)，可使绘制的图像边缘更加平滑。通过这种方式绘制出来的图片质量更高，显得更真实。但同时，它对绘制的性能也会产生负面影响。所以，是否使用这项技术，需要开发者在图片质量(Quality)和性能(Performance)之间进行权衡。</p><p>MSAA其实是对SSAA的一个改进，显然SSAA的计算量是非常大的，每个像素点分成4个采样点，我们就要进行4次的shading来计算颜色，额外多了4倍的计算量。</p><p>MSAA的思路:</p><p>同样一个像素分为多个采样点，每个采样点判断是否被三角形覆盖，如果被覆盖，直接把三角形的颜色赋值给采样点而不需要去单独计算每个采样点的颜色，最后求平均值作为像素点颜色。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\muti.png" srcset="/EruLv.github.io/img/loading.gif" alt="muti"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\mass.png" srcset="/EruLv.github.io/img/loading.gif" alt="mass"></p><h2 id="4-光线投射Ray-Casting和光照模型"><a href="#4-光线投射Ray-Casting和光照模型" class="headerlink" title="4.光线投射Ray Casting和光照模型"></a>4.光线投射Ray Casting和光照模型</h2><p>光线投射和光栅化的关系？</p><p><strong>渲染Rendering</strong>:由三维场景计算每个像素的颜色并最终得到二维图像的过程。</p><p>每个像素都对应一个射线Ray。</p><h3 id="3-1-Ray-Casting算法"><a href="#3-1-Ray-Casting算法" class="headerlink" title="3.1 Ray Casting算法"></a>3.1 Ray Casting算法</h3><p>1.主要作用:寻找交点和法向量。</p><p>流程:</p><pre><code>对每个像素:    构造一个从观察点射出的射线；    对场景中的每个物体:        求出它们与射线的交点；        如果是最近的就保留；        基于光照和法向量着色；</code></pre><p><strong>2.Ray Casting vs. Ray Tracing</strong></p><p>光线投射只有摄像机(or eye)发出光线，光线追踪还包括其他光线(阳光，灯光，反射光等)。 </p><p><strong>3.Ray射线的表示</strong></p><p>$起点+t*方向向量$</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\ratt.png" srcset="/EruLv.github.io/img/loading.gif" alt="ratt"></p><p>确定D：利用条件$-1&lt;x&lt;1$和$\alpha$</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\ray.png" srcset="/EruLv.github.io/img/loading.gif" alt="ray"></p><p>给定平面上的一点，确定从相机射出的射线的方向向量r.</p><p>最终得到的结果:</p><p>$r = (x<em>u, asp</em>y<em>v,D</em>w)$</p><p><strong>4.正投影</strong></p><p>原点随着像素位置改变，方向是常数。</p><p>$Origin = e + x<em>size</em>u + y<em>size</em>v$</p><p>Direction is constant: w</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200904162649380.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200904162649380" style="zoom:80%;"></p><p><strong>5.射线与平面的交点</strong></p><p> Ray Representation:$P(t) = R_o + t * R_d$</p><p>(无限的)3D平面表示:隐式表示，点+法向量</p><p>P0 = (x0 , y0 , z0 )，n = (A,B,C)</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\3D.png" srcset="/EruLv.github.io/img/loading.gif" alt="3D"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\3DD.png" srcset="/EruLv.github.io/img/loading.gif" alt="3D"></p><p>射线和平面的交点意味着点既在射线上，又在平面上。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\3DDD.png" srcset="/EruLv.github.io/img/loading.gif" alt="3D"></p><p><strong>6.球体的表示</strong></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\sphere.png" srcset="/EruLv.github.io/img/loading.gif" alt="sphere"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\sph.png" srcset="/EruLv.github.io/img/loading.gif" alt="sph"></p><p>求得最后的t，取正实数。</p><p>球体表面的法向量反向延长线经过球心。</p><p><strong>7.Ray-Triangle Intersection</strong></p><p>三角形表示:barycentric定义</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\alpha.png" srcset="/EruLv.github.io/img/loading.gif" alt></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\triii.png" srcset="/EruLv.github.io/img/loading.gif" alt="triii"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\t.png" srcset="/EruLv.github.io/img/loading.gif" alt="t"></p><p>重心坐标系插值法优点:</p><ul><li>高效</li><li>不需要额外存储平面的表达式，可以通过三个点直接计算t</li><li>很方便地与插值结合，对于颜色、深度插值，纹理映射很有用</li></ul><p>8.光线变换</p><p>从世界坐标系变换到物体坐标系</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\raytrans.png" srcset="/EruLv.github.io/img/loading.gif" alt="raytrans"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\tt.png" srcset="/EruLv.github.io/img/loading.gif" alt="tt"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200904165535339.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200904165535339" style="zoom:80%;"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200904165543109.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200904165543109" style="zoom:80%;"></p><h3 id="3-2-光照"><a href="#3-2-光照" class="headerlink" title="3.2 光照"></a>3.2 光照</h3><p>3.2.1.光源性质</p><p>当光照照射到一个物体表面时，光照一部分被吸收，一部分被反射，反射的那部分决定物体的颜色和亮度。</p><p>光照强度衰减，一般不使用反比例函数，因为靠近光源光照强度会变得无穷大。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\light.png" srcset="/EruLv.github.io/img/loading.gif" alt="asd"></p><p>入射角越小（越接近法向量），表面接收到的能量越多。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\angle.png" srcset="/EruLv.github.io/img/loading.gif" alt></p><p><strong>全局光照和局部光照</strong></p><ul><li>局部光照(local illumination) 简单说就是只考虑光源到模型表面的照射效果。</li><li>全局光照(Global illumination) 简单的说就是考虑到环境中所有表面和光源相互作用的照射效果 。</li></ul><p><strong>光照的分类:</strong></p><p>点光源(Point Lights)，</p><p>平行光(Directional Lights), 无穷远的点光源</p><p>聚光灯(Spolt Lights)，圆锥体，关于中心对称，角度衰减。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Pl.png" srcset="/EruLv.github.io/img/loading.gif" alt="Pl"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\image-20200827134810339.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200827134810339"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200827134832079.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200827134832079"></p><p> <strong>材质表面的性质</strong></p><p>1.表面越光滑，反射越集中；粗糙的表面反射后的光线是四面八方的。</p><p><strong>各向同性（isotropic ） vs.各向异性(Anisotropic)</strong></p><p>各向同性:如果保持光源和观察视角的位置不变，如果以法向量为中心旋转表面，并不改变反射结果，则称该材料为各向同性的。</p><p>各向异性:具有强烈的微几何元素的表面是各向异性的。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\iso.png" srcset="/EruLv.github.io/img/loading.gif" alt="iso"></p><p>3.2.2光照模型</p><p>1.BRDF(Bidirectional Reflectance Distribution Function,双向反射分布函数)，phong model就是其中一种。</p><p>BRDF的形式:</p><p>$I<em>{out} = I</em>{in}(l)f_r(v,l)$</p><p>$I_{in}$表面某点的接收的光照强度。</p><p>$fr(v,l)$,观察者和光源的相对位置(角度)对最最终看到的光照的影响。</p><p><strong>理想漫反射</strong></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\diffuse.png" srcset="/EruLv.github.io/img/loading.gif" alt="diffuse"></p><p><strong>非理想镜面反射</strong></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Specular.png" srcset="/EruLv.github.io/img/loading.gif" alt="Specular"></p><p> <strong>术语:Specular Lobe</strong>:大多数高光BRDF，都是在半角向量接近宏表面法线时反射亮度最大。图象像叶片，故称为lobe。</p><p><strong>Ambient环境光</strong></p><p>在场景中的物体至少会接收一些微量的光，可以理解为没有光源情况下物体本身就有的光。</p><p><strong>1.Phong Model</strong></p><p>材质的属性:</p><ul><li>漫反射光Diffuse,漫反射光对物体的着色产生显著影响，光照方向和物体表面越倾向与垂直，物体就越能获取到更大的亮度。</li><li>环境光Ambient,光线来自四面八方，光源通常也是有多个，物体之间也有光线的反射。环境光可以描述环境中的全局照明效果，它和入射角度没有关系。</li><li>镜面光Specular.当我们看物体时，看的方向是物体对光源反射光方向时，会有一个高光。物体对光源的反射光方向与看的方向夹角越小，看到的点镜面光亮度越高。</li></ul><p>用到四个向量：</p><ul><li>指向光源的向量</li><li>指向观察者的向量</li><li>法向量</li><li>完美反射的向量</li></ul><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\phong.png" srcset="/EruLv.github.io/img/loading.gif" alt="phong"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200827173010211.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200827173010211"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\ph.png" srcset="/EruLv.github.io/img/loading.gif" alt="ph"></p><script type="math/tex; mode=display">L_o = [k_a + k_d（n·l）+(v·r)^q]\frac{L_i}{R^2}</script><p>$k_a$:Ambient coefficient</p><p>$k_d$:diffuse reflection coefficient</p><p>$k_s$:specular reflection coefficient</p><p>$q$:specular reflection  exponent</p><p>$L$:光源的光照强度</p><p>$n$:normal vector</p><p>$l$:指向光源的向量</p><p>$v$:指向摄像机的向量</p><p>$r$:理想反射向量</p><p>后面哪个r是光源到物体表面的距离</p><p><strong>Blinn-Phong</strong>（phong模型的改进）:</p><p>把$vr$换成了$vh$,因为理想反射向量计算比较麻烦。</p><script type="math/tex; mode=display">L_o = [k_a + k_d（n·l）+(v·h)^q]\frac{L_i}{R^2}\\h = \frac{l+v}{||l+v||}</script><p>避免了计算ideal reflection vector.</p><p>h是光源向量和相机向量的中间的向量</p><h3 id="3-3-法向量"><a href="#3-3-法向量" class="headerlink" title="3.3 法向量"></a>3.3 法向量</h3><p>1.三个点组成的平面</p><script type="math/tex; mode=display">n = (p_2-p_0)×(p_1 - p_0)</script><p>2.球体</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\phere.png" srcset="/EruLv.github.io/img/loading.gif" alt="phere"></p><h3 id="3-4-OpenGL-Shade"><a href="#3-4-OpenGL-Shade" class="headerlink" title="3.4 OpenGL Shade"></a>3.4 OpenGL Shade</h3><p>OpenGL着色的步骤</p><ul><li>启用着色并选择模型</li><li>确定法向量</li><li>确定材质属性</li><li>确定光照</li></ul><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Gou.png" srcset="/EruLv.github.io/img/loading.gif" alt="Gou"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\cmpx.png" srcset="/EruLv.github.io/img/loading.gif" alt="j"></p><p>Phong Shading 和Gouraud Shading算法比较:</p><p>相同点:</p><ul><li>都是明暗处理技术。</li><li>用要先应用多边形法线计算出顶点的法线。</li><li>都应用Phong局部反射模型计算多边形顶点处的光强</li></ul><p>不同点:</p><ul><li>Gouraud明暗处理只在多边形顶点处采用Phong局部反射模型计算光强，而在多边形内的其他点采用双向线性插值，这样做的优点是高效，但是无法很好的处理镜面高光问题，依赖于其所在多面形的相对位置；</li><li>而Phong明暗处理，通过差值计算每个顶点的法向量（3次差值，在x，y，z三个方向分别进行差值计算），然后计算每个点上的光强值，这样效果好，但计算复杂，需要付出比Gouraud 4-5 倍的时间。</li></ul><p>给每个顶点赋予不同的法向量，可以通过周围平面法向量的和来确定方向，然后通过插值确定内部的法向量，达到平滑的效果。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200904171609440.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200904171609440"></p><h2 id="5-纹理映射"><a href="#5-纹理映射" class="headerlink" title="5.纹理映射"></a>5.纹理映射</h2><p>1.UV 坐标系</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\uv.png" srcset="/EruLv.github.io/img/loading.gif" alt="uv">包含纹理映射的Ray Casting的伪代码</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\pseudocode.png" srcset="/EruLv.github.io/img/loading.gif" alt="pseudocode"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\uvv.png" srcset="/EruLv.github.io/img/loading.gif" alt="uvv"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\tm.png" srcset="/EruLv.github.io/img/loading.gif" alt="tm"></p><p>可以把获得的颜色用于光照模型的一些常量参数，如$k_d,k_s,q$等，通过normal mapping可以获得更精细的法向量。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\nm.png" srcset="/EruLv.github.io/img/loading.gif" alt="nm"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\NormalMapping.png" srcset="/EruLv.github.io/img/loading.gif" alt="NormalMapping"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\GeneratingNM.png" srcset="/EruLv.github.io/img/loading.gif" alt="GeneratingNM"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\opgl.png" srcset="/EruLv.github.io/img/loading.gif" alt="opgl"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Magnification.png" srcset="/EruLv.github.io/img/loading.gif" alt="Magnification"></p><p>走样Aliasing: 纹理映射后，在栅格化过程中，因为透视投影，距离eye越远成像越小，采样率不够，所以有可能一个像素对应多个颜色值，当像素的颜色近似取值时导致视觉上的偏差叫做走样。</p><p>解决Aliasing的方法有:</p><p>Mip-mapping, super-sampling(SSAA), multi-sampling(MSAA).</p><p>Mipmapped:</p><p>通过pre-filtering将原来的texture图像进行低通滤波(卷积)操作，得到一系列不同尺寸的图像金字塔(1/2,1/4,1/8…)</p><p>计算每个片元的投影后的缩小比例，在Rasterization时，根据缩小比例选择不同尺寸的贴图，其中有nearest和tri-linear等方法。    </p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\mip.png" srcset="/EruLv.github.io/img/loading.gif" alt="mip"></p><h2 id="5-曲线和表面"><a href="#5-曲线和表面" class="headerlink" title="5.曲线和表面"></a>5.曲线和表面</h2><h3 id="5-1-曲线和曲面的参数形式"><a href="#5-1-曲线和曲面的参数形式" class="headerlink" title="5.1 曲线和曲面的参数形式"></a>5.1 曲线和曲面的参数形式</h3><p>曲线的参数形式</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\curve.png" srcset="/EruLv.github.io/img/loading.gif" alt="curve"></p><p>曲面的参数形式，有两个参数</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\surface.png" srcset="/EruLv.github.io/img/loading.gif" alt="surface"></p><p>参数多项式曲线</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\curefun.png" srcset="/EruLv.github.io/img/loading.gif" alt="curefun"></p><p>参数多项式曲面</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\parasuface.png" srcset="/EruLv.github.io/img/loading.gif" alt="parasuface"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\sur.png" srcset="/EruLv.github.io/img/loading.gif" alt="sur"></p><p>表示面的方法:</p><ul><li>三角形网格。(工业界喜欢用四边形网格)。</li><li>样条曲线构成样条曲面(CAD，计算机辅助造型，工业制造领域)。</li><li>曲面细分。</li><li>公式隐式表示。(医疗图像处理)</li><li>过程化表示(2D线通过旋转生成3D图像，Swept Surfaces)。</li><li>volume data.</li></ul><p>切线Tangent:一阶导</p><p>曲率Curvature:二阶导，圆的曲率1/r;</p><h3 id="5-2-三次参数多项式曲线"><a href="#5-2-三次参数多项式曲线" class="headerlink" title="5.2 三次参数多项式曲线"></a>5.2 三次参数多项式曲线</h3><p>次数太高，需要的方程多，计算开销大，光滑性也会变差。</p><p>次数太低，不构灵活，没有足够的参数进行设计。</p><p>所以三次比较合适。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\cubic.png" srcset="/EruLv.github.io/img/loading.gif" alt="cubic"></p><h3 id="5-3-Hermite几何"><a href="#5-3-Hermite几何" class="headerlink" title="5.3 Hermite几何"></a>5.3 Hermite几何</h3><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\heimite.png" srcset="/EruLv.github.io/img/loading.gif" alt="heimite"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\hermite2.png" srcset="/EruLv.github.io/img/loading.gif" alt="hermite2"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\hermite3.png" srcset="/EruLv.github.io/img/loading.gif" alt="hermite3"></p><h3 id="5-4-几何与参数连续性"><a href="#5-4-几何与参数连续性" class="headerlink" title="5.4 几何与参数连续性"></a>5.4 几何与参数连续性</h3><p>$C^0 $参数连续性：continuous, 连接处的值相等。</p><p>$C^1$参数连续性: 在连接点参数方程值和一阶导数都对应相等(切线相同)。</p><p>$C^2$参数连续: 参数方程连接点一阶导、二阶导都对应相等。</p><p>$G^1$几何连续性:两个曲线连接处切线向量成比例，方向相同，但是模不同。</p><h3 id="5-5-三次贝塞尔曲线Cubic-Bezier"><a href="#5-5-三次贝塞尔曲线Cubic-Bezier" class="headerlink" title="5.5 三次贝塞尔曲线Cubic Bezier"></a>5.5 三次贝塞尔曲线Cubic Bezier</h3><p>贝塞尔曲线只有$C^0$连续性，没有C1连续性。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\bezier.png" srcset="/EruLv.github.io/img/loading.gif" alt="bezier"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\bezier2.png" srcset="/EruLv.github.io/img/loading.gif" alt="bezier2"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\bezier3.png" srcset="/EruLv.github.io/img/loading.gif" alt="bezier3"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\bezier4.png" srcset="/EruLv.github.io/img/loading.gif" alt="bezier4"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\general.png" srcset="/EruLv.github.io/img/loading.gif" alt="general"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\trans.png" srcset="/EruLv.github.io/img/loading.gif" alt="trans"></p><p>对曲线进行变换相当于对控制点进行相应的变换。</p><p>一条三次贝塞尔曲线可以被从中间细分为两条三次贝塞尔曲线的连接。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\De.png" srcset="/EruLv.github.io/img/loading.gif" alt="De"></p><h3 id="5-6-三次B样条Cubic-B-Splines"><a href="#5-6-三次B样条Cubic-B-Splines" class="headerlink" title="5.6 三次B样条Cubic B-Splines"></a>5.6 三次B样条Cubic B-Splines</h3><p>不要求多项式插值任何点，采用曲线逼近的方式，可以在连接点获得更高的平滑性。具有C2连续性。</p><p>思想:$p<em>{i-1},p_i.p</em>{i+1},p<em>{i+2}$定义$P_i,P</em>{i+1}$之间的一段曲线，</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\spline0.png" srcset="/EruLv.github.io/img/loading.gif" alt="spline0"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\spline.png" srcset="/EruLv.github.io/img/loading.gif" alt="spline"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Bspline.png" srcset="/EruLv.github.io/img/loading.gif" alt="Bspline"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\convert.png" srcset="/EruLv.github.io/img/loading.gif" alt="convert"></p><h3 id="5-7-NURBS（Non-Uniform-Rational-B-Spline）"><a href="#5-7-NURBS（Non-Uniform-Rational-B-Spline）" class="headerlink" title="5.7 NURBS（Non-Uniform Rational B-Spline）"></a>5.7 NURBS（Non-Uniform Rational B-Spline）</h3><p>非均匀分布，（每段路径可以长度不等）</p><p>增加了一个参数w,决定每个点的影响度(齐次坐标)。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\NURBS.png" srcset="/EruLv.github.io/img/loading.gif" alt="NURBS"></p><h3 id="5-8-表面"><a href="#5-8-表面" class="headerlink" title="5.8 表面"></a>5.8 表面</h3><p>1.多边形网格</p><p>多边形叠加在一起组成表面。如三角形网格。</p><p>不够平滑。</p><p>2.向量乘积</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\tensor.png" srcset="/EruLv.github.io/img/loading.gif" alt="tensor"></p><p>二维的贝塞尔曲线u和v，相对独立，如上图，一共16个控制点。这个面称为Bézier Patches。只有最外面的四个顶点插值，其他接近。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\bicubic.png" srcset="/EruLv.github.io/img/loading.gif" alt="bicubic"></p><p>法向量:是两个方向的偏导的叉乘。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\tangent.png" srcset="/EruLv.github.io/img/loading.gif" alt="tangent"></p><p>矩阵形式</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\matirx.png" srcset="/EruLv.github.io/img/loading.gif" alt="matirx"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\matrix2.png" srcset="/EruLv.github.io/img/loading.gif" alt="matrix2"></p><p>优点:</p><ul><li>平滑</li><li>只需要16个点就可以定义。</li></ul><p>缺点:</p><ul><li>不方便渲染。</li><li>在边界的连续性处理棘手。</li></ul><p><strong>Displacement（扰动） Mapping</strong></p><p>加一些扰动，使表面不光滑，更加真实。</p><h3 id="5-9-Surface-Subdivision"><a href="#5-9-Surface-Subdivision" class="headerlink" title="5.9 Surface Subdivision"></a>5.9 Surface Subdivision</h3><p>Face split:一个多边形生成多个多边形。</p><p>Vertex split: 一个点生成多个顶点。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\subdivison.png" srcset="/EruLv.github.io/img/loading.gif" alt="subdivison"></p><p><strong>1.Doo-Sabin Subdivision</strong></p><p>vertex split</p><p>每个面加一个face vertex;</p><p>该面上的顶点分别和face vertex取中点作为新加入的点，把新加的点连接。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\subd.png" srcset="/EruLv.github.io/img/loading.gif" alt="subd"></p><p><strong>2.Loop Subdivision</strong></p><p>Face Subdivision针对三角形Mesh.</p><p>分两步：</p><p>添加新点: (每条边上加一个点)</p><p>​    内部边(有两个相邻三角形)；</p><p>​    边缘边（只有一个相邻三角形）。</p><p>调整旧点；(主要依据自己和相邻的顶点)</p><p>​    边缘；相邻两个点，相邻边是边缘</p><p>​    内部；</p><p>一个面变成4个面。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200829172024730.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200829172024730"></p><p><strong>3.Modified Butterfly Subdivision</strong></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\butterfly.png" srcset="/EruLv.github.io/img/loading.gif" alt="butterfly"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\butterfly2.png" srcset="/EruLv.github.io/img/loading.gif" alt="butterfly2"></p><p><strong>4.Catmull-Clark Subdivision</strong></p><p>处理四边形网格quad-meshes，每个面分成4个小四边形。</p><p>加新点，调整旧点。</p><p>k:相邻的点数。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\ca.png" srcset="/EruLv.github.io/img/loading.gif" alt="ca"></p><p>拓展到任意多边形。</p><p>新加点:与相邻两个顶点和新加的面点有关。</p><p>调整旧点: 与自己的位置和相邻点的位置和新家面点有关。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\cat.png" srcset="/EruLv.github.io/img/loading.gif" alt="cat"></p><h3 id="5-10-数据结构"><a href="#5-10-数据结构" class="headerlink" title="5.10 数据结构"></a>5.10 数据结构</h3><h3 id="5-11-其他"><a href="#5-11-其他" class="headerlink" title="5.11 其他"></a>5.11 其他</h3><p>1.Swept Surfaces求法向量:两组切线叉乘。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Swept.png" srcset="/EruLv.github.io/img/loading.gif" alt="Swept"></p><p>2.隐式曲面Implicit Surfaces</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Implicit.png" srcset="/EruLv.github.io/img/loading.gif" alt="Implicit"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200829182345211.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200829182345211"></p><p>3.水平集方法Level Set</p><p>面对Evolving interfaces（不断变化的面）</p><p>添加一个新的维度(时间)</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\levelset.png" srcset="/EruLv.github.io/img/loading.gif" alt="levelset"></p><p>4.Marching Cubes</p><p>建模的一种方法</p><h2 id="6-Meshes"><a href="#6-Meshes" class="headerlink" title="6.Meshes"></a>6.Meshes</h2><h3 id="1-名词解释"><a href="#1-名词解释" class="headerlink" title="1.名词解释"></a>1.名词解释</h3><p><strong>Manifold</strong>:流形，是一般的几何对象的总称。surfaces where the neighborhood of each point is topologically equivalent to a disk; edges are always shared by two faces？</p><p><strong>nonintersecting simple closed curves</strong>:不相交闭合曲线</p><p><strong>genus</strong>:亏格，图形表面孔洞个数。</p><p><strong>Orientable</strong>:可定向的，物体表面的法向量始终朝外或者朝内，在表面移动时不会改变方向。</p><p><strong>Euler’s Formula</strong>:欧拉公式$v-e+f = 2 - 2g$, <em>v</em> / <em>e</em> / <em>f</em> : number of vertices / edges / facets ,–<em>g</em> : genus</p><p><strong>Dihedral Angle</strong>:二面角，两个三角形面的平面之间的角度。</p><p><strong>Valence(a.k.a. degree)</strong>:顶点所连边数。</p><p><strong>adjacency</strong>：邻接</p><p><strong>connectivity</strong>：连通性</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\unk.png" srcset="/EruLv.github.io/img/loading.gif" alt="unk"></p><h3 id="2-Mehes的数据结构"><a href="#2-Mehes的数据结构" class="headerlink" title="2.Mehes的数据结构"></a>2.Mehes的数据结构</h3><p>1.Simple Adjacency</p><p>每个元素(顶点、边、面)都有一系列指向所有与它邻接的元素的指针。</p><p>点的指针:指向边，面；</p><p>边的指针:指向顶点、面。</p><p>面的指针:指向点、边。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Adjacency.png" srcset="/EruLv.github.io/img/loading.gif" alt="Adjacency" style="zoom:80%;"></p><p>缺点:数据结构大小不固定，查询慢，存储空间大，很难维护。</p><p>2.Winged Edge </p><p>每个边存储指向4条临界边、两个面、两个顶点的指针，每个顶点和面都存储<strong>一个</strong>邻接面的指针。</p><p>数据结构大小是固定的，但是因为指针没有固定的顺序，所以访问周围元素是很困难。</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Winged.png" srcset="/EruLv.github.io/img/loading.gif" alt="Winged" style="zoom:80%;"></p><p>3.half edge</p><p>每条边用两个不同方向的半边结构表示。</p><p>每个半边存储:</p><ul><li>有向边终点位置的顶点。</li><li>另一个相对(<strong>symmetric</strong>)的半边。</li><li>位于半边左边的面。</li><li>位于沿着半边左边的面的逆时针方向(counter-clockwise)的下一条半边。</li></ul><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\Loop.png" srcset="/EruLv.github.io/img/loading.gif" alt="Loop" style="zoom:80%;"></p><p>数据结构大小:固定</p><p>时间复杂与与目标信息量呈线性。</p><p>优点:</p><ul><li>大多数的邻接查询都能在$O(1)$时间内完成。</li><li>Local Operating 通常是$O(1)$的。</li></ul><p>缺点:</p><ul><li>只适用于流形网格。</li></ul><p>4.SplitEdge</p><p>SplitEdge和HalfEdge是对偶(dual)的。</p><p>每个边分为两个相反方向的半边。</p><p>每个半边存储:</p><ul><li>有向边终点位置的顶点。</li><li>另一个相对(<strong>symmetric</strong>)的半边。</li><li>位于半边左边的面。</li><li><strong>沿着顺时针指向相同顶点的半边。</strong></li></ul><pre><code class="lang-c++">SplitEdgeMesh::FaceLoop() = HalfEdgeMesh::VertexLoop();SplitEdgeMesh::VertexLoop() = HalfEdgeMesh::FaceLoop();</code></pre><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200831204203497.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200831204203497"></p><p>5.Corner Data Structure</p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\corner.png" srcset="/EruLv.github.io/img/loading.gif" alt="corner"></p><ol><li><p>QuadEdge</p><p><a href="https://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/quadedge.html" target="_blank" rel="noopener">https://www.cs.cmu.edu/afs/andrew/scs/cs/15-463/2001/pub/src/a2/quadedge.html</a></p><p>Org:边的起点。</p><p>Dest:边的终点。</p><p>Left:左边的面。</p><p>Right:右边的面。</p><p>Rnext:右边面ccw(逆时针方向)的下一条边。</p><p>Lnext:左边面ccw(逆时针方向)的下一条边。</p><p>Onext:围绕起点的ccw(逆时针方向)的下一条边。</p><p>Dnext:围绕终点的ccw(逆时针方向)的下一条边。</p><p>X(R/L/O/D)prev:顺时针方向的下一条边。</p><p>Rot:逆时针旋转90°。</p><p>Sym:旋转180°.</p><p>Flip:上下翻转？</p></li></ol><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/blog\source\_posts\计算机图形学复习\quad.png" srcset="/EruLv.github.io/img/loading.gif" alt="quad"></p><h2 id="7-代码"><a href="#7-代码" class="headerlink" title="7.代码"></a>7.代码</h2><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200904210304587.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200904210304587"></p><p><img src="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20200904210518210.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200904210518210"></p>]]></content>
    
    
    
    <tags>
      
      <tag>图形学</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java基础</title>
    <link href="/EruLv.github.io/2020/08/01/java%E5%9F%BA%E7%A1%80/"/>
    <url>/EruLv.github.io/2020/08/01/java%E5%9F%BA%E7%A1%80/</url>
    
    <content type="html"><![CDATA[<h1 id="Java基础笔记-《Java编程思想》阅读笔记"><a href="#Java基础笔记-《Java编程思想》阅读笔记" class="headerlink" title="Java基础笔记-《Java编程思想》阅读笔记"></a>Java基础笔记-《Java编程思想》阅读笔记</h1><h6 id="距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java"><a href="#距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java" class="headerlink" title="距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java."></a>距离上次使用java已经过去2年多了，趁大三夏令营结束的这段时间复习一下java.</h6><h2 id="1-一切皆是对象"><a href="#1-一切皆是对象" class="headerlink" title="1.一切皆是对象"></a>1.一切皆是对象</h2><ol><li><p>java是一种更纯粹的面向对象的编程语言。</p></li><li><p>Java使用<code>new</code>关键字创建对象，对象的存储位置在<strong>堆</strong>内。对于一些基本类型，<code>new</code>对堆的操作开销较大，因此对于这些类型，java采取与c,c++相同的方法，即，不用<code>new</code>来创建这些变量，而直接创建一个并非是引用的变量，这个变量直接存储值，并置于堆栈中，音因此更加高效。</p></li><li><p>Java变量的<strong>基本类型</strong>:</p></li></ol><div class="table-container"><table><thead><tr><th>基本类型</th><th>大小</th><th>最小值</th><th>最大值</th><th>包装器类型</th></tr></thead><tbody><tr><td>boolean</td><td>—</td><td>—</td><td>—</td><td>Boolean</td></tr><tr><td>char</td><td>16 bits</td><td>Unicode 0</td><td>Unicode $2^{16} -1$</td><td>Character</td></tr><tr><td>byte</td><td>8 bits</td><td>-128</td><td>127</td><td>Byte</td></tr><tr><td>short</td><td>16 bits</td><td>-$2^{15}$</td><td>$2^{15}-1$</td><td>Short</td></tr><tr><td>int</td><td>32 bits</td><td>-$2^{31}$</td><td>$2^{31} - 1$</td><td>Integer</td></tr><tr><td>long</td><td>64 bits</td><td>-$2^{63}$</td><td>$2^{63} - 1$</td><td>Long</td></tr><tr><td>float</td><td>32 bits</td><td>IEEE 754</td><td>IEEE 754</td><td>Float</td></tr><tr><td>double</td><td>64 bits</td><td>IEEE 754</td><td>IEEE 754</td><td>Double</td></tr><tr><td>void</td><td>—</td><td>—</td><td>—</td><td>Void</td></tr></tbody></table></div><p>所有数值类型变量均有符号。</p><pre><code class="lang-java">//创建一个基本类型变量int a = 13;//使用包装器创建一个非基本对象Integer a = new Integer(13);//java自动将基本类型转换为包装器类型Integer a = 13;</code></pre><p>4.高精度</p><ul><li><p>高精度整数:<code>BigInteger</code>，支持任何精度的整数。</p></li><li><p>高精度浮点数:<code>BigDecimal</code>，支持任何精度的浮点数。</p></li></ul><p>只能通过<code>new</code>创建.</p><p>对象的作用域</p><p>由<code>new</code>创建的对象，只要你需要，就会一直保存下去，即超出作用域是不会被立即销毁。</p><p>6.类的要素:</p><ul><li><p>字段</p></li><li><p>方法</p></li></ul><p>7.当java的变量作为类的成员时，若该变量时基本类型并且未被赋值，则java会给它一个默认值(类似c++)。</p><p>8.导入类</p><pre><code class="lang-java">import java.utils.ArrayList;import java.utils.*;    //导入utils下所有类。</code></pre><p>9.static</p><p>当一个事物声明是static时，意味着这个域或方法不会与包含它的那个对象关联在一起。即无论创建多少个包含它的对象，系统只给它分配一个存储空间。</p><pre><code class="lang-java">class test{    static int a = 1;}class Main {    public static void main(String args[]){        test t = new test();        t.a ++;        test tt = new test();        tt.a ++;        test.a ++;    //可以直接通过类名调用静态方法        System.out.println(t.a);        System.out.println(tt.a);    }}结果:44</code></pre><p>同理，静态方法也可通过类名直接调用或通过对象调用。</p><p>10.</p><p>java.lang是默认导入到每个Java文件中的，不需要额外import.</p><p>11.编译</p><p>生成.class类</p><pre><code>javac xxx.java</code></pre><p>假设生成了A.class和B.class, 现在运行代码:</p><pre><code>java A</code></pre><p>12.注释</p><pre><code class="lang-java">class Main {    /** 类的作用是啥巴拉巴拉     * @author 作者名称     * @param args 参数解释     * @return xxx     * @version 1.0     */    public static void main(String args[]){        System.getProperties().list(System.out);    }}</code></pre><h2 id="2-操作符"><a href="#2-操作符" class="headerlink" title="2.操作符"></a>2.操作符</h2><p>1.赋值</p><p><strong>基本类型的赋值</strong>: </p><p>直接把内容赋值给左边，如a = b, 当改变b的值时，a的内容不变。</p><p><strong>对象赋值</strong>:</p><p>把指向对象的引用复制给左边，如c = d,那么c和d都指向同一存储位置。</p><p>2.random</p><pre><code class="lang-java">import java.util.*;class Main {    public static void main(String args[]){        Random random = new Random(66);    //随机数对象，种子:66        int a = random.nextInt(100) + 1;    //设置Int范围1-100        float b = random.nextFloat()*10;    //设置float范围0-10        System.out.println(a);        System.out.println(b);    }}</code></pre><p>3.科学计数法</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        float a = 1e32f;        System.out.println(a);    }}</code></pre><p>4.按位操作</p><p><code>&amp;</code>:与</p><p><code>|</code>:或</p><p><code>~</code>:非</p><p><code>^</code>:异或</p><p><code>&lt;&lt;</code>:左移</p><p><code>&gt;&gt;</code>:右移</p><p>5.if-else操作</p><pre><code class="lang-java">boolean-exp ? a:b;</code></pre><p>6.类型转换</p><p><strong>窄化转换</strong>可能面临信息丢失的危险，所以必须显示转换。</p><p><strong>拓展转换</strong>不需要显示转换。</p><p>例如: long转int会报错，必须显示转换。</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        long a = 1000000;        int b = a;    }}</code></pre><p>7.截尾和舍入</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        double a = 9.7;        int b = (int)a;    //截尾        int c = (int)Math.round(a);    //四舍五入        System.out.println(b);        System.out.println(c);    }}</code></pre><p>8.其他</p><ul><li>比int小的类型(char,byte,short)在运算时会自动转换为int类型。</li><li>通常，表达式中最大数据类型决定了表达式最终结果的数据类型。</li></ul><h2 id="3-执行控制流程"><a href="#3-执行控制流程" class="headerlink" title="3.执行控制流程"></a>3.执行控制流程</h2><p>1.if else,while, for, switch</p><p>pass</p><p>2.Foreach</p><p>(c++11中也支持该语句)</p><p>Foreach可用于任何数组和Iterable对象。</p><pre><code class="lang-java">        Random r = new Random(6);        int a[] = new int[10];        for(int i = 0;i &lt; a.length; i++){            a[i] = r.nextInt(100);        }        for(int x:a){            System.out.println(x);        }</code></pre><pre><code class="lang-java">    public static void main(String args[]){        for(int x: range(5,10)){    //rang前提: import static net.mindview.util.Range.*;            print(x);        }    }</code></pre><p>3.goto</p><p>goto是java的一个保留字，但是java并不能使用goto语句。</p><p>4.标签</p><p><code>break label</code>: 跳出标签所指循环。</p><p><code>continue label</code>:跳过标签所指循环的这一步。</p><pre><code class="lang-java">class Main {    public static void main(String args[]){        int i = 0;        outer:        for(;;){            inner:            for(;i &lt; 10; i++){                print(&quot;i = &quot;+i);                if(i == 5) break outer;    //直接跳出外部循环            }        }    }}</code></pre><h2 id="4-初始化与请理"><a href="#4-初始化与请理" class="headerlink" title="4.初始化与请理"></a>4.初始化与请理</h2><p>1.构造器</p><p>与类名相同的函数。</p><p>2.重载</p><p>方法名相同，形参不同。</p><p><strong>函数名和形参相同，返回值不同，不是重载，编译器会报错。</strong></p><p>3.this</p><p>在类内使用，表示该类的引用。可用于区分形参和类内参数。</p><p>一般的方法，如:</p><pre><code class="lang-java">class Person {    public void eat(Apple apple) {        print(&quot;Yummy&quot;);    }}//实际上隐含的代码是(实际不能把this写上，否则编译器报错):class Person {    public void eat(this, Apple apple) {        print(&quot;Yummy&quot;);    }}</code></pre><p>4.再看static</p><p>static方法是没有<code>this</code>的方法，在所以在static方法内部不能直接调用非静态方法，单反过来是可以的。</p><p>static很像全局方法，给java提供了一种访问全局变量和方法的思路。</p><p>5.finalize</p><p>类似于c++中的析构函数。但不建议使用。java9以上的版本该方法被<strong>Deprecated</strong> 并且<strong>will be removed</strong>.</p><p>6.构造器初始化</p><p>变量一定会在构造函数之前初始化(即使变量可能定义在构造函数后面)，变量之间的初始化顺序由定义的顺序决定。</p><p>7.静态数据初始化</p><p><code>static</code> 不能作用与局部数据，静态数据也会自动初始化(基本类型，对象类型)。</p><pre><code class="lang-java">import java.util.*;import static net.mindview.util.Print.*;import static net.mindview.util.Range.*;class Bowl{    Bowl(int marker){        print(&quot;Bowl(&quot;+marker+&quot;)&quot;);    }    void f1(int marker){        print(&quot;f1(&quot;+marker+&quot;)&quot;);    }}class Table{    static Bowl bowl1 = new Bowl(1);    Table(){        print(&quot;Table()&quot;);        bowl2.f1(1);    }    void f2(int marker){        print(&quot;f2(&quot;+marker+&quot;)&quot;);    }    static Bowl bowl2 = new Bowl(2);}class Cupboard{    Bowl bowl3 = new Bowl(3);    static Bowl bowl4 = new Bowl(4);    Cupboard(){        print(&quot;Cupboard&quot;);        bowl4.f1(2);    }    void f3(int marker){        print(&quot;f3(&quot;+marker+&quot;)&quot;);    }    static Bowl bowl5 = new Bowl(5);}class Main {    public static void main(String args[]){        print(&quot;create new Cupboard() in main !&quot;);        new Cupboard();        print(&quot;create new Cupboard() in main !&quot;);        new Cupboard();        table.f2(1);        cupboard.f3(1);    }    static Table table = new Table();    static Cupboard cupboard = new Cupboard();}</code></pre><pre><code>输出:Bowl(1)Bowl(2)Table()f1(1)Bowl(4)Bowl(5)Bowl(3)Cupboardf1(2)create new Cupboard() in main !Bowl(3)Cupboardf1(2)create new Cupboard() in main !Bowl(3)Cupboardf1(2)f2(1)f3(1)</code></pre><p><strong>总结初始化顺序:</strong></p><p>静态对象(只会被初始化一次)-&gt;非静态对象-&gt;构造器。</p><p>8.静态子句</p><p>只会被执行一次的域</p><pre><code class="lang-java">static{    int i = 1;    xxxx}</code></pre><p>9.数组初始化</p><pre><code>int a[];int[] a;int[] a = {1,2,3,4};int a[] = new int[10];</code></pre><pre><code class="lang-java">a2 = a1;//把a1的引用赋值给a2;</code></pre><pre><code class="lang-java">Arrays.toString(a); //把数组转化为字符串,需要引用java.utils.*标准库</code></pre><p>创建对象数组时，需要分两步:</p><p>创建应用数组，给每个引用赋初值。</p><pre><code class="lang-java">A[] a = new A[10];for(int i = 0; i  &lt; a.length; i++){    a = new A();}</code></pre><p>或者直接初始化</p><pre><code class="lang-java">A[] a = {new A(1),new A(2)};A[] a = new A[]{new A(1), new A(2)};</code></pre><p>10.可变参数列表</p><pre><code class="lang-java">public class VarArgs{    static void printArray(Object... args){    //将你的输入自动封装成数组，疮长度不固定，可以是0        for(Object obj: args){            System.out.print(obj + &quot; &quot;);        }        print();    }}class DynamicArray{    public static void main(String[] args){        VarArgs.printArray(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;);        VarArgs.printArray(new Object[]{                new Integer(1),                new Integer(2),                new Integer(3)        });    }}</code></pre><p>11.枚举类型</p><pre><code class="lang-java">enum E{    A,B,C,D}class Main{    public static void main(String[] args){        for(E e: E.values()){            print(e);        }        print(E.A);            }}</code></pre><p>enum类有toString方法，可以在switch中使用。</p><h2 id="5-访问权限控制"><a href="#5-访问权限控制" class="headerlink" title="5.访问权限控制"></a>5.访问权限控制</h2><p>1.包Package</p><p> 每个<code>.java</code>文件都只能有一个public类，该类的名称必须与文件名相同，如果改文件还有额外的类的话，包之外的世界(其他文件)是无法看见这个类的。即每个文件都有一个<code>public</code>类，以及许多非<code>public</code>类。</p><p>每个文件都有一个构件，如果希望这些构件从属于同一个群组，就可以使用关键字<code>package</code>,必须放在程序最前面。</p><p>新建package access</p><pre><code class="lang-java">package access;public class A {    public A(){        System.out.println(&quot;access A !&quot;);    }}class AA{    public AA(){        System.out.println(&quot;access AA !&quot;);    }}</code></pre><p>在<code>access</code>包外调用包内的内容。</p><pre><code class="lang-java">import access.*;public class B {    public static void main(String[] args){//        AA aa = new AA();        A a = new A();    }}</code></pre><p>java解释器寻找类库的过程：</p><p>比如导入包</p><pre><code class="lang-java">import net.mindview.test.*</code></pre><p>当编译器遇到<code>test</code>的<code>import</code>语句时，就开始在<code>CLASSPATH</code>所指定的目录中查找，查找到子目录<code>net/mindview/test</code>，然后从已编译的文件中找出名称相符者。</p><p>如果导入的两个类库中存在冲突类，如果你恰好使用到了冲突的类，编译器会报错。</p><p><strong>自己一个print包</strong></p><pre><code class="lang-java">package access;public class Print {    public static void print(Object obj){        System.out.println(obj);    }    public static void print(){        System.out.println();    }}</code></pre><p>调用:</p><pre><code class="lang-java">import static access.Print.*;public class B {    public static void main(String[] args){        print();    }}</code></pre><p><code>import static 包名.类名.*;</code></p><p>意思是导入这个类里的静态成员（静态方法、静态变量）,可以直接使用静态方法而不用通过<code>类名.方法名()</code>,可以导入的静态成员包括静态对象引用、静态常量和静态方法。</p><p>2.<strong>访问权限修饰词</strong></p><p>2.1包访问权限(默认权限)</p><p>没有访问权限修饰词，则默认为包访问权限(<code>friendly</code>),则当前包中的其他类堆那个成员对具有访问权限。对于包外的所有类都是不可见的。</p><p>如果你没有设置当前文件所属的包，即没有定义<code>package xxxx</code>,则位于同一目录的这样文件被java看作位于隶属于该目录的默认包中，于是对于同级目录下的没有设置包的文件来说，它们有<strong>包访问权限</strong>。</p><p>2.2 public</p><p>在任何位置都可以访问。</p><p>2.3 private</p><p>除了包含该成员的类之外，其他任何类都无法访问这个成员。</p><p>2.4 protected</p><p>继承的子类可以访问基类中的<code>protected</code>的成员（当然也可以访问<code>public</code>的）。</p><p><code>protected</code>也提供包继承，即同一个包内的类也可以访问含有<code>protected</code>声明的成员。</p><p>3.注意，类(外部类)不可以时<code>protected</code>或者<code>privated</code>.可以把构造器设置为<code>private</code>,阻止其他类创建该类的实例。</p><h2 id="6-复用类"><a href="#6-复用类" class="headerlink" title="6.复用类"></a>6.复用类</h2><p>1.复用类的两种实现方法</p><p>组合:在新类中<code>new</code>一个现有类。</p><p>继承:在基类的基础上添加代码。</p><p>2.toString方法</p><p>在每一个非基本类型的对象都有一个<code>toString()</code>方法，当编译器需要一个String而你只有一个对象时，该方法会被调用。可以自己定义<code>toString()</code>方法:</p><pre><code class="lang-java">public String toString(){    return &quot;This is toString&quot;;}</code></pre><pre><code class="lang-java">import static access.Print.*;public class B {    public static void main(String[] args){        Print p = new Print();        System.out.println(p);    }}</code></pre><p>3.继承</p><p>java默认从<code>Object</code>类继承。</p><p>继承关键字:<code>extends</code>.</p><pre><code class="lang-java">public A ectends B{    //balabala}</code></pre><p>A类从B类继承。</p><pre><code class="lang-java">class C{    C(){        System.out.println(&quot;initialize C!&quot;);    }}class B extends C{    B(){        System.out.println(&quot;initialize B!&quot;);    }}public class A extends B{    A(){        System.out.println(&quot;initialize A!&quot;);    }    public static void main(String[] args){        A a = new A();    }}</code></pre><p><strong>java会首先初始化基类。</strong></p><p>如果没有默认的基类构造器，或者基类构造器带参数，则必须使用<code>super</code>，显示地调用基类构造器。并且<code>super</code>要位于最前面。</p><p>4.代理</p><p>继承和组合的一个折中，不直接继承，而是创建基类的一个实例，根据定义当前类需要的方法。</p><p>5.名称屏蔽</p><p>如果基类中有一个方法，在子类中被重载了，那么基类中的这个方法依然是可用的。</p><p>使用<code>@override</code>会检查你写的下面的代码是否覆盖掉基类代码，如果只是重载而不是覆盖，则编译器会报错。</p><pre><code class="lang-java">class B {    B(int i) {        System.out.println(&quot;initialize B!&quot;);    }    void f(int x){        System.out.println(&quot;f(&quot;+x+&quot;)&quot;);    }}public class A extends B{    A(){        super(1);        System.out.println(&quot;initialize A!&quot;);    }    void f(String s){        System.out.println(&quot;f(&quot;+s+&quot;)&quot;);    }    public static void main(String[] args){        A a = new A();        a.f(&quot;你好&quot;);        a.f(1);    }}/* outputs:initialize B!initialize A!f(你好)f(1)*/</code></pre><pre><code class="lang-java">public class A extends B{    A(){        super(1);        System.out.println(&quot;initialize A!&quot;);    }    //限定只能覆盖,重写会报错    @Override    void f(int x){        System.out.println(&quot;ff(&quot;+x+&quot;)&quot;);    }    public static void main(String[] args){        A a = new A();        a.f(1);    }}</code></pre><p>6.组合和继承的选择</p><p>组合是使用现有类的一些功能，来实现我们需要的功能，比如car类可能需要wheel类，Engine类等。</p><p>继承一般是把一个通用类的功能特殊化，具体化。</p><p>7.向上转型</p><p>将导出类(子类)转换为基类的动作（从一个特殊类转换为通用类）。如:</p><pre><code class="lang-java">Instrument x = new Flute();</code></pre><p>8.final关键字</p><p><strong>1.数据</strong></p><p><code>final</code>代表常量，如果修饰基本类型，则表示该数据不能修改，如果修饰对象，表示改引用不能指向其他对象(但对象可以改变)。</p><p><code>final static</code>命名一般是大写字幕+下划线。</p><p><code>final</code>必须在定义时初始化。当然，如果作为类成员变量，可以先不初始化，但一定要在构造函数里初始化。</p><pre><code class="lang-java">class Test{    private final int j = 1;    private final int i;    Test(){        i = 1;    }}</code></pre><p><strong>2.方法</strong></p><p><code>final</code>修饰方法作用和<code>private</code>关键字类似，可以防止子类覆盖。</p><pre><code class="lang-java">class WithFinals {    // Identical to &quot;private&quot; alone:    private final void f() { print(&quot;WithFinals.f()&quot;); }    // Also automatically &quot;final&quot;:    public final void g() { print(&quot;WithFinals.g()&quot;); }}class OverridingPrivate extends WithFinals {    private final void f() {        print(&quot;OverridingPrivate.f()&quot;);    }    public void g() {   //会报错        print(&quot;OverridingPrivate.g()&quot;);    }}</code></pre><p><strong>3.类</strong></p><p>在类前加<code>final</code>关键字表示改类不能被继承。final类不会被继承，因此它的所有方法都隐式指定为final的。</p><h2 id="7-多态"><a href="#7-多态" class="headerlink" title="7.多态"></a>7.<strong>多态</strong></h2><p>在<strong>oop</strong>中，多态时继数据抽象和继承之后的第三种基本特征。多态的作用是消除类型之间的耦合关系</p><p>1.向上转型</p><p>对象既可作为它自己本身的类型使用，也可作为它的基类型使用。</p><pre><code class="lang-java">class Instrument {  public void play(Note n) {    print(&quot;Instrument.play()&quot;);  }}public class Wind extends Instrument {  // Redefine interface method:  public void play(Note n) {    System.out.println(&quot;Wind.play() &quot; + n);  }} public class Music {  public static void tune(Instrument i) {    // ...    i.play(Note.MIDDLE_C);  }  public static void main(String[] args) {    Wind flute = new Wind();    tune(flute); // Upcasting  }} /* Output:Wind.play() MIDDLE_C*///:~</code></pre><p>接收Instrument类型的对象，调用的却是Wind的方法。</p><p>为什么会这样？因为java中除了<code>final</code>和<code>static</code>均采用动态绑定，在运行时判断对象类型。</p><p>你以为你把它转到基类了，实际上如果可以，它还是会调用子类的方法。</p><pre><code class="lang-java">class A{    public void play(){        System.out.println(&quot;A.play()&quot;);    }}class B extends A{    public void play(){        System.out.println(&quot;B.play()&quot;);    }}public class test {    public static void main(String[] args){        A a = new B();        a.play();    }}B/* Output:B.play() *///:~</code></pre><p>2.“覆盖”私有方法</p><pre><code class="lang-java">public class PrivateOverride {  private void f() { print(&quot;private f()&quot;); }      public static void main(String[] args) {    PrivateOverride po = new Derived();    po.f();  }}class Derived extends PrivateOverride {  public void f() { print(&quot;public f()&quot;); }    } /* Output:private f()*///:~</code></pre><p>上面的基类中f()是私有的，与<code>final</code>等价，下面继承的方法看作是个全新的方法，基类中的方法f()在导出类中不可见，不能被重载，<strong>只有非<code>private</code>方法才可以被覆盖</strong>。</p><p>满足多态的条件:</p><ul><li>基类和子类中都有非<code>private</code>方法f().</li><li>A a = new B()形式，其中B继承A。</li></ul><p>最终a.f()调用B的f()。</p><p><strong>另外，向上转型后不能访问子类中存在但基类中不存在的方法。</strong></p><p>3.“域”(类变量)访问</p><p>如果你直接访问某个域，这个访问就会在编译期间进行解析，不具有多态性。</p><pre><code class="lang-java">class Super {  public int field = 0;  public int getField() { return field; }}class Sub extends Super {  public int field = 1;  public int getField() { return field; }  public int getSuperField() { return super.field; }}public class FieldAccess {  public static void main(String[] args) {    Super sup = new Sub(); // Upcast    System.out.println(&quot;sup.field = &quot; + sup.field +      &quot;, sup.getField() = &quot; + sup.getField());    Sub sub = new Sub();    System.out.println(&quot;sub.field = &quot; +      sub.field + &quot;, sub.getField() = &quot; +      sub.getField() +      &quot;, sub.getSuperField() = &quot; +      sub.getSuperField());  }}/* Output:sup.field = 0, sup.getField() = 1sub.field = 1, sub.getField() = 1, sub.getSuperField() = 0*///:~</code></pre><p>向上转型后，访问sup的域，因为sup是Super类，所以访问的是Super的类变量。</p><p>如果某个方法是静态的，它的行为也不具有多态性。因为静态方法与类关联而不是单个对象。</p><pre><code class="lang-java">class StaticSuper {  public static String staticGet() {    return &quot;Base staticGet()&quot;;  }  public String dynamicGet() {    return &quot;Base dynamicGet()&quot;;  }}class StaticSub extends StaticSuper {  public static String staticGet() {    return &quot;Derived staticGet()&quot;;  }  public String dynamicGet() {    return &quot;Derived dynamicGet()&quot;;  }}public class StaticPolymorphism {  public static void main(String[] args) {    StaticSuper sup = new StaticSub(); // Upcast    System.out.println(sup.staticGet());    System.out.println(sup.dynamicGet());  }} /* Output:Base staticGet()Derived dynamicGet()*///:~</code></pre><p>4.构造器和多态</p><p>构造器是<code>static</code>的，因此不具有多态性。</p><p>构造器调用顺序:</p><p><strong>从上往下初始化基类构造器-&gt;初始化当前类的变量-&gt;初始化当前类的构造器。</strong></p><p>5.清理</p><p>如果需要显示地写辣鸡回收方法，子类覆盖父类的请理方法，子类的清理方法中一定要添加<code>super().请理()</code>方法，否则父类的清理方法一直不会执行。</p><p>6.构造器中调用被覆盖的类</p><pre><code class="lang-java">class Glyph {  void draw() { print(&quot;Glyph.draw()&quot;); }  Glyph() {    print(&quot;Glyph() before draw()&quot;);    draw();    print(&quot;Glyph() after draw()&quot;);  }}  class RoundGlyph extends Glyph {  private int radius = 1;  RoundGlyph(int r) {    radius = r;    print(&quot;RoundGlyph.RoundGlyph(), radius = &quot; + radius);  }  void draw() {    print(&quot;RoundGlyph.draw(), radius = &quot; + radius);  }}  public class PolyConstructors {  public static void main(String[] args) {    new RoundGlyph(5);  }} /* Output:Glyph() before draw()RoundGlyph.draw(), radius = 0Glyph() after draw()RoundGlyph.RoundGlyph(), radius = 5*///:~</code></pre><p>可以看到基类的draw()方法被重写了，在基类构造器中调用draw()方法依旧调用的是子类的draw()方法，但由于子类还未初始化，所以radius为0.（之前编译器会给所有对象分配好空间，然后初始化成二进制的0.</p><p>7.协变返回类型</p><pre><code class="lang-java">class Grain {  public String toString() { return &quot;Grain&quot;; }}class Wheat extends Grain {  public String toString() { return &quot;Wheat&quot;; }}class Mill {  Grain process() { return new Grain(); }}class WheatMill extends Mill {  Wheat process() { return new Wheat(); }}public class CovariantReturn {  public static void main(String[] args) {    Mill m = new Mill();    Grain g = m.process();    System.out.println(g);    m = new WheatMill();    g = m.process();    System.out.println(g);  }} /* Output:GrainWheat*///:~</code></pre><p>8.向下转型</p><pre><code class="lang-java">class Useful {  public void f() {}  public void g() {}}class MoreUseful extends Useful {  public void f() {}  public void g() {}  public void u() {}  public void v() {}  public void w() {}}  public class RTTI {  public static void main(String[] args) {    Useful[] x = {      new Useful(),      new MoreUseful()    };    x[0].f();    x[1].g();    // Compile time: method not found in Useful:    x[1].u();    //编译报错    ((MoreUseful)x[1]).u(); //通过    ((MoreUseful)x[0]).u(); // 抛出异常  }} ///:~</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>动态规划</title>
    <link href="/EruLv.github.io/2020/07/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <url>/EruLv.github.io/2020/07/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
    
    <content type="html"><![CDATA[<h1 id="动态规划题目总结"><a href="#动态规划题目总结" class="headerlink" title="动态规划题目总结"></a>动态规划题目总结</h1><h2 id="1-背包问题"><a href="#1-背包问题" class="headerlink" title="1.背包问题"></a>1.背包问题</h2><h3 id="1-1-01背包问题"><a href="#1-1-01背包问题" class="headerlink" title="1.1 01背包问题"></a>1.1 01背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>每件物品只能使用一次</strong>。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数$v_i, w_i$，用空格隔开，分别表示第i件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例：</strong></p><pre><code>8</code></pre><h4 id="分析"><a href="#分析" class="headerlink" title="分析:"></a>分析:</h4><p>$f[i][j]$表示状态，从前i件物品中选择不超过质量j的最大总价值。</p><p>划分为两个集合:</p><p>不选择第i件物品,则$f[i][j] = f[i-1][j]$</p><p>选择第i件物品，考虑如何使用前面的状态表示，$f[i][j] = f[i - 1][j - v[i]] + w[i]$,选择第i件物品质量不超过j，需要从前i-1件物品中的质量不超过$j - v[i]$的物品中获得。前提是$j &gt;= v[i]$</p><p>上面两者求最大值即可。</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N][N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i]&gt;&gt; w[i];    }    //f[i][j] = max(f[i-1][j], f[i - 1][j - v[i]] + w[i])    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;=m ; j++){            f[i][j] = f[i-1][j];            if(j &gt;= v[i]) f[i][j] = max(f[i][j], f[i - 1][j-v[i]] + w[i]);         }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>可以使用一维数组代替二维数组，因为计算$f[i][j]$是只用到了$f[i-1]$的状态，所以i这一维可以压缩到一个数组中。</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int v[N], w[N];int n, m;int f[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i]&gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = m; j &gt;= v[i] ; j--){            //注意要从后往前遍历，因为我们要确保公式右边都是没有更新过的，j一定在j-v[i]前更新            f[j] = max(f[j], f[j-v[i]] + w[i]);         }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="1-2-完全背包问题"><a href="#1-2-完全背包问题" class="headerlink" title="1.2 完全背包问题"></a>1.2 完全背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>每件物品都有无限件可用</strong>。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数$v_i, w_i$，用空格隔开，分别表示第i件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N,V≤1000$<br>$0&lt;v_i,w_i≤1000$</p><p><strong>输入样例</strong></p><pre><code>4 51 22 43 44 5</code></pre><p><strong>输出样例：</strong></p><pre><code>10</code></pre><h4 id="分析-1"><a href="#分析-1" class="headerlink" title="分析:"></a>分析:</h4><p>跟01背包相似，不过集合划分时，把情况划分为第i件物品选0,1,2,…,k件。</p><p>$f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i], f[i-1][j-2<em>v[i]] + 2</em>w[i],…,f[i-1][j-k<em>v[i]] + k</em>w[i])$</p><p>所以有:</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int f[N][N];int n, m;int v[N], w[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j&lt;=m; j++){            for(int k = 0; k*v[i] &lt;= j; k++)            f[i][j] = max(f[i][j], f[i-1][j-k*v[i]] + K*w[i]);        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>上述时间复杂读为$O(nm^2)$,可以优化。</p><p>考虑:</p><p>$f[i][j] = max(f[i-1][j], f[i-1][j-v[i]] + w[i], f[i-1][j-2<em>v[i]] + 2</em>w[i],…,f[i-1][j-k<em>v[i]] + k</em>w[i])$</p><p>$f[i][j-v[i]] + w[i] = max(f[i-1][j - v[i]] + w[i], f[i-1][j-2 <em> v[i]] + 2</em>w[i], f[i-1][j-3<em>v[i]] + 3</em>w[i],…)$</p><p>所以</p><p>$f[i][j] = max(f[i-1][j], f[i][j-v[i]] + w[i])$</p><p>注意与01背包的区别，区别在它是从i转移来的而不是i - 1</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int f[N][N];int n, m;int v[N], w[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j&lt;=m; j++){            f[i][j] = f[i-1][j];            if(j &gt;= v[i])                f[i][j] = max(f[i-1][j], f[i][j - v[i]] + w[i]);        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>一维的形式</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 1010;int f[N];int n, m;int v[N], w[N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = v[i]; j&lt;=m; j++){            //注意j是从小到大遍历，因为左边是从已经更新过的i转移来的            f[j] = max(f[j], f[j - v[i]] + w[i]);        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre><h3 id="1-3-多重背包问题"><a href="#1-3-多重背包问题" class="headerlink" title="1.3 多重背包问题"></a>1.3 多重背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>第i种物品最多有$s_i$件</strong>。第 $i$ 件物品的体积是 $v_i$，价值是 $w_i$。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有 $N$ 行，每行两个整数$v_i, w_i$，用空格隔开，分别表示第i件物品的体积和价值。</p><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N≤1000$<br>$0&lt;V≤2000$<br>$0&lt;vi,wi,si≤2000$</p><p><strong>输入样例</strong></p><pre><code>4 51 2 32 4 13 4 34 5 2</code></pre><p><strong>输出样例：</strong></p><pre><code>10</code></pre><h4 id="分析-2"><a href="#分析-2" class="headerlink" title="分析:"></a>分析:</h4><p>思路同完全背包，把第i件物品划分为选择0,1,2,…s[i]件</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int v[N],w[N],s[N];int n, m;int f[N][N];int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;=n; i++){        cin &gt;&gt; v[i] &gt;&gt; w[i] &gt;&gt; s[i];    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;= m; j++){            for(int k = 0; k &lt;= s[i] &amp;&amp; k*v[i] &lt;= j; k++){                f[i][j] = max(f[i][j], f[i-1][j - k*v[i]] + k*w[i]);            }        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><p>根据完全背包问题做优化:</p><pre><code>f[i][j] = max(f[i-1][j], f[i-1][j - v[i]] + w[i],...,f[i-1][j - s*v[i]] + s* w[i])f[i][j-v[i]] = max(      f[i-1][j - v[i]],      ... ,f[i-1][j - s*v[i]] + (s-1)*w[i],  f[i-1][j - (s+1)*v[i]])</code></pre><p>发现后面多了一项，不能根据后面的最大值，求前面的最大值。</p><p>所以使用二进制优化。</p><p><strong>思想</strong>:</p><p>假设第i组的数量为s，则可以将s分解为$logs$组，每组的数量为$1,2,4…2^k,c$,其中$1+2+…+2^k+c = s$,可以证明0-s种的任意一个整数可以用上面的二进制组合表示。</p><p>所以将每一种物品分成数量为$1,2,4…2^k,c$的组，最后转换为01背包问题。</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;// N = log(s) * Nconst int N = 15000, M = 2010;int v[N], w[N];int n, m;int f[M];int main(){    cin &gt;&gt; n &gt;&gt; m;    int cnt = 0;    //新的集合的编号    for(int i = 0; i &lt; n; i++){        int a, b, s;        cin &gt;&gt; a &gt;&gt; b &gt;&gt; s;        //分组        int k = 1;  //该组的数量        while(k &lt;= s){            cnt ++;            v[cnt] = a * k;            w[cnt] = b * k;            s -= k;            k *= 2;        }        //剩下的        if(s &gt; 0){            cnt ++ ;            v[cnt] = a * s;            w[cnt] = b * s;        }    }    n = cnt;    //01背包问题    for(int i = 1; i &lt;= n; i++){        for(int j = m; j &gt;= v[i]; j--){            f[j] = max(f[j], f[j - v[i]] + w[i]);        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;}</code></pre><h3 id="1-4分组背包问题"><a href="#1-4分组背包问题" class="headerlink" title="1.4分组背包问题"></a>1.4分组背包问题</h3><p><strong>特点</strong>:</p><p>有 $N$ 件物品和一个容量是$V$的背包。<strong>每组物品有若干个，同一组内的物品最多只能选一个</strong>。每件物品的体积是 $v<em>{ij}$，价值是 $w</em>{ij}$，其中 i是组号，j是组内编号。求解将哪些物品装入背包，可使这些物品的总体积不超过背包容量，且总价值最大。输出最大价值。</p><p><strong>输入</strong></p><p>第一行两个整数，$N$，$V$用空格隔开，分别表示物品数量和背包容积。</p><p>接下来有$N$组数据：</p><ul><li>每组数据第一行有一个整数 $S_i$，表示第i 个物品组的物品数量；</li><li>每组数据接下来有$S<em>i$行，每行有两个整数 $v</em>{ij},w_{ij}$，用空格隔开，分别表示第 i个物品组的第 jj 个物品的体积和价值；</li></ul><p><strong>输出格式</strong></p><p>输出一个整数，表示最大价值。</p><p><strong>数据范围</strong></p><p>$0&lt;N,V≤100$<br>$0&lt;v<em>{ij},w</em>{ij}≤100$</p><p>$0&lt;S_i&lt;=100$</p><p><strong>输入样例</strong></p><pre><code>3 521 22 413 414 5</code></pre><p><strong>输出样例：</strong></p><pre><code>8</code></pre><h4 id="分析-3"><a href="#分析-3" class="headerlink" title="分析:"></a>分析:</h4><p>集合的表示:前i组中总体积不超过j的最大价值。</p><p>集合划分:第i组，选择0个，第一个，第二个，…,第$s[i]$个</p><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int v[N][N], w[N][N], s[N];int f[N][N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        int cnt;        cin &gt;&gt; cnt;        s[i] = cnt;        for(int j = 1; j &lt;= cnt; j++){            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];        }    }    for(int i = 1; i &lt;= n; i++){        for(int j = 0; j &lt;= m; j++){            for(int k = 0; k &lt;= s[i]; k++){                if(j - v[i][k] &gt;=0 )                    f[i][j] = max(f[i][j], f[i-1][j-v[i][k]] + w[i][k]);            }        }    }    cout &lt;&lt; f[n][m] &lt;&lt; endl;    return 0;}</code></pre><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;algorithm&gt;using namespace std;const int N = 110;int v[N][N], w[N][N], s[N];int f[N];int n, m;int main(){    cin &gt;&gt; n &gt;&gt; m;    for(int i = 1; i &lt;= n; i++){        cin &gt;&gt; s[i];        for(int j = 1; j &lt;= s[i]; j++){            cin &gt;&gt; v[i][j] &gt;&gt; w[i][j];        }    }    for(int i = 1; i &lt;= n; i++){        for(int j = m; j &gt;= 0; j--){            for(int k = 0; k &lt;= s[i]; k++){                if(j - v[i][k] &gt;=0 )                    f[j] = max(f[j], f[j-v[i][k]] + w[i][k]);            }        }    }    cout &lt;&lt; f[m] &lt;&lt; endl;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>动态规划 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>机器学习复习</title>
    <link href="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/"/>
    <url>/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h1><h2 id="1-判别模型vs生成模型"><a href="#1-判别模型vs生成模型" class="headerlink" title="1.判别模型vs生成模型"></a>1.判别模型vs生成模型</h2><p>生成模型是由数据先学习联合概率分布$P(X,Y)$，然后求出条件概率分布作为预测模型。如朴素贝叶斯和隐马尔可夫模型。</p><p>判别方法是直接根据数据学习决策函数$f(X)$或者条件概率分布$P(Y|X)$作为预测的模型(学习一个决策边界)。典型的模型由SVM，k近邻，感知机，决策树、最大熵模型、条件随机场等。</p><p>判别: discriminative</p><p>生成: generative</p><h2 id="2-评测指标"><a href="#2-评测指标" class="headerlink" title="2.评测指标"></a>2.评测指标</h2><h3 id="2-1-准确率，精确率，召回率，F1值"><a href="#2-1-准确率，精确率，召回率，F1值" class="headerlink" title="2.1 准确率，精确率，召回率，F1值"></a>2.1 准确率，精确率，召回率，F1值</h3><ul><li>tp: 预测为正类，实际为正类</li><li>fp:预测为正类，实际为负类</li><li>tn:预测为负类，实际为负类</li><li>fn:预测为负类，实际为正类</li></ul><p>准确率</p><script type="math/tex; mode=display">acc = \frac{tp + tn}{tp + tn + fp + fn}</script><p>精确率</p><script type="math/tex; mode=display">p = \frac{tp}{tp + fp}</script><p>召回率</p><script type="math/tex; mode=display">r = \frac{tp}{tp + fn}</script><p>F1值:精确率和召回率的调和平均</p><script type="math/tex; mode=display">F1 = \frac{2*p*r}{p+r}</script><h2 id="3-朴素贝叶斯"><a href="#3-朴素贝叶斯" class="headerlink" title="3. 朴素贝叶斯"></a>3. 朴素贝叶斯</h2><p>先验概率分布: $P(Y = c_k)$</p><p>条件概率分布:$P(X = x|Y = c_k)$</p><p>由上面两个概率得到联合概率分布:</p><script type="math/tex; mode=display">P(X = x,Y = c_k) = P(X = x| y = c_k) P(y = c_k)</script><p>朴素贝叶斯<strong>条件独立性假设</strong>（朴素的含义）:</p><p>当$Y$确定时，$X$的各个特征分量取值之间相互独立，用公式表示:</p><script type="math/tex; mode=display">P(X=x|y = c_k) = P(X = x_1,x_2,...,x_n|y = c_k) = \prod_{j = 1}^{n}P(X_j = x_j|y = c_k)</script><p>后验概率:(结合上式计算)</p><script type="math/tex; mode=display">P(Y = c_k|X) = \frac{P(X = x|Y = c_k)P(Y = c_k)}{P(X)} = \frac{P(X = x|Y = c_k)P(Y = c_k)}{\sum_{k} P(X = x|y = c_k)P(y = c_k)}</script><p><strong>在估计条件概率$P(X)$时出现概率为0的情况怎么办？</strong></p><p>贝叶斯估计:</p><p>在每个随机变量的哥哥取值的频数上各加一个正数$\lambda$,常取$\lambda = 1$</p><h2 id="4-决策树"><a href="#4-决策树" class="headerlink" title="4.决策树"></a>4.决策树</h2><h3 id="4-1算法流程"><a href="#4-1算法流程" class="headerlink" title="4.1算法流程"></a>4.1算法流程</h3><p><img src="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/dtree.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200701214058220"></p><h3 id="4-2-决策树的三个停止条件"><a href="#4-2-决策树的三个停止条件" class="headerlink" title="4.2 决策树的三个停止条件:"></a><strong>4.2 决策树的三个停止条件:</strong></h3><ul><li>当前节点包含的样本属于同一类别，无需划分。</li><li>当前属性集为空，或是所有样本在所有属性上取值相同，无需划分。把当前节点标记为叶节点，类别设定为它的父节点所含样本最多的类别</li><li>当前节点包含的样本集合为空，不能划分。把父节点样本分布作为当前结点的先验分布。</li></ul><h3 id="4-3划分选择"><a href="#4-3划分选择" class="headerlink" title="4.3划分选择:"></a><strong>4.3划分选择:</strong></h3><h4 id="4-3-1信息增益ID3"><a href="#4-3-1信息增益ID3" class="headerlink" title="4.3.1信息增益ID3"></a>4.3.1信息增益ID3</h4><p>信息熵: 度量样本集合纯度，熵越大，越混乱。公式如下:$p_k$表示样本集合D中第k类样本所占比例。</p><script type="math/tex; mode=display">Ent(D)  =- \sum_{k = 1}^{C}p_klog(p_k)</script><p>信息增益,使用a属性划分，划分后产生V个分支节点，信息增益公式为:</p><script type="math/tex; mode=display">Gain(D,a) = Ent(D) - \sum_{v = 1}^{V}\frac{D^v}{D}Ent(D^v)</script><h4 id="4-3-2增益率C4-5"><a href="#4-3-2增益率C4-5" class="headerlink" title="4.3.2增益率C4.5"></a>4.3.2增益率C4.5</h4><p>信息增益准则对可取数目比较多的属性有所偏好，(可取属性越多，划分越纯)，为减少这种偏好可能带来的不利影响，使用增益率作为划分依据。</p><script type="math/tex; mode=display">Gain_ratio(D,a) = \frac{Gain(D,a)}{IV(a)}\\IV (a)  =-\sum_{v = 1}^V\frac{|D^v|}{|D|}log2\frac{|D^v|}{|D|}</script><p>属性a的可能取值越多，IV越大</p><h4 id="4-3-3基尼指数CART"><a href="#4-3-3基尼指数CART" class="headerlink" title="4.3.3基尼指数CART"></a>4.3.3基尼指数CART</h4><p>从数据集D中随机抽取两个样本，类别不一致的概率。Gini越小，纯度越高。</p><script type="math/tex; mode=display">Gini(D) = \sum_{k=1}^C\sum_{u != k}p_k p_u = 1 - \sum_{k = 1}^{C}p_{k}^2</script><p>基尼指数为:选择使基尼指数最小a的作为划分依据。</p><script type="math/tex; mode=display">Gini_index(D,a) = \sum_{v=1}^{V}\frac{|D^v|}{|D|}Gini(D^v)</script><h3 id="4-4-剪枝"><a href="#4-4-剪枝" class="headerlink" title="4.4 剪枝"></a>4.4 剪枝</h3><p>提高泛化能力，避免过拟合。</p><h4 id="4-4-1预剪枝"><a href="#4-4-1预剪枝" class="headerlink" title="4.4.1预剪枝"></a>4.4.1预剪枝</h4><p>比较划分前后的验证集精度，如果划分后验证集精度不能提升，则禁止划分，类别标记为最多的类。有欠拟合的风险。</p><h4 id="4-4-2-后剪枝"><a href="#4-4-2-后剪枝" class="headerlink" title="4.4.2 后剪枝"></a>4.4.2 后剪枝</h4><p>自底向上的剪枝方法。后续遍历决策树内部节点，比较剪枝前后的验证集精度。</p><h3 id="4-5-连续值处理"><a href="#4-5-连续值处理" class="headerlink" title="4.5 连续值处理"></a>4.5 连续值处理</h3><p>二分法。与离散属性不同，若当前节点划分属性为连续属性，该属性还可作为其后代节点的划分属性。</p><h2 id="5-线性回归"><a href="#5-线性回归" class="headerlink" title="5.线性回归"></a>5.线性回归</h2><p>损失函数为L2距离</p><h2 id="6-逻辑回归"><a href="#6-逻辑回归" class="headerlink" title="6.逻辑回归"></a>6.逻辑回归</h2><h3 id="6-1二项式逻辑回归"><a href="#6-1二项式逻辑回归" class="headerlink" title="6.1二项式逻辑回归"></a>6.1二项式逻辑回归</h3><script type="math/tex; mode=display">P(Y = 1|x)  = \frac{exp(w^T x+b)}{1+exp(w^T x+b)}\\P(Y = 0|x) = \frac{1}{1+exp(w^T x+b)}</script><p>损失函数为交叉熵，可以根据极大似然估计获得。</p><h3 id="6-2多项式逻辑回归"><a href="#6-2多项式逻辑回归" class="headerlink" title="6.2多项式逻辑回归"></a>6.2多项式逻辑回归</h3><script type="math/tex; mode=display">P(Y = k|x)  = \frac{exp(w^T x_k+b)}{1+\sum_{k=1}^{K-1}exp(w^T x_k+b)},k = 1,2,..K-1\\P(Y = K|x) = \frac{1}{1+\sum_{k=1}^{K-1}exp(w^T x_k+b)}</script><h2 id="7-隐马尔可夫模型"><a href="#7-隐马尔可夫模型" class="headerlink" title="7.隐马尔可夫模型"></a>7.隐马尔可夫模型</h2><h3 id="7-1HMM属性"><a href="#7-1HMM属性" class="headerlink" title="7.1HMM属性"></a>7.1HMM属性</h3><ul><li>Q:所有可能状态集合${q_1,q_2,…,q_N}$</li><li>V:所有可能的观测集合${v_1,v_2,…,v_M}$</li><li>I:长度为T的状态序列${i_1,i_2,…i_T}$</li><li>O::长度为T的观测序列${o_1,o_2,…,o_T}$</li><li>A:状态转移矩阵,$N×N$,$a_{ij}$表示在时刻t处于状态$q_i$的条件下在时刻t+1转移到状态$q_j$的概率。</li><li>B:观测概率矩阵,$N×M$，$b_j$表示t时刻处于状态$q_j$生成观测$v_k$的概率。</li><li>$\pi$:初始状态概率向量，$\pi_i = P(i_1 = q_i)$</li></ul><h3 id="7-2-隐马尔可夫三要素"><a href="#7-2-隐马尔可夫三要素" class="headerlink" title="7.2 隐马尔可夫三要素"></a>7.2 隐马尔可夫三要素</h3><script type="math/tex; mode=display">\lambda = (A,B,\pi)</script><h3 id="7-3-隐马尔可夫两个基本假设"><a href="#7-3-隐马尔可夫两个基本假设" class="headerlink" title="7.3 隐马尔可夫两个基本假设"></a>7.3 隐马尔可夫两个基本假设</h3><p><strong>齐次马尔可夫性假设</strong>:马尔可夫在t+1时刻的状态只依赖于其前一时刻的状态。</p><p><strong>观测独立性假设</strong>：当前观测值只依赖于当前状态。</p><h3 id="7-4隐马尔可夫的三个问题"><a href="#7-4隐马尔可夫的三个问题" class="headerlink" title="7.4隐马尔可夫的三个问题"></a>7.4隐马尔可夫的三个问题</h3><ul><li><strong>概率问题</strong>:已知模型和观测序列，计算观测序列出现的概率$P(O|\lambda)$。</li><li><strong>学习问题</strong>:已知观测序列，估计模型参数，使得在该模型下观测序列概率$P(O|\lambda)$最大。</li><li><strong>预测问题</strong>:已知模型和观测序列，求对给定观测序列条件概率$P(I|O)$最大的状态序列I,即给定观测序列，求最有可能对应的状态序列。解码，分词。维特比(Viterbi)算法.</li></ul><h3 id="7-5-预测问题"><a href="#7-5-预测问题" class="headerlink" title="7.5 预测问题"></a>7.5 预测问题</h3><h2 id="8-聚类"><a href="#8-聚类" class="headerlink" title="8.聚类"></a>8.聚类</h2><h3 id="8-1-K-means"><a href="#8-1-K-means" class="headerlink" title="8.1 K-means"></a>8.1 K-means</h3><p><strong>算法流程:</strong></p><ul><li>输入聚类簇的个数k。</li><li>从数据集中随机选择k个数据点作为初始的质心。</li><li>对训练集中的每一个样本，计算它于质心的距离，距离哪个质心进，就属于那一组。</li><li>然后每个组重新求质心。</li><li>如果新的质心于原来质心的距离的和小于某个阈值，算法停止，否则继续迭代。</li></ul><p>细节问题:</p><p>​    1. K值怎么定？我怎么知道应该几类？ 答：这个真的没有确定的做法，分几类主要取决于个人的经验与感觉，通常的做法是多尝试几个K值，看分成几类的结果更好解释，更符合分析目的等。或者可以把各种K值算出的SSE做比较，取最小的SSE的K值。</p><p>​    2. 初始的K个质心怎么选？ 答：最常用的方法是随机选，初始质心的选取对最终聚类结果有影响，因此算法一定要多执行几次，哪个结果更reasonable，就用哪个结果。 当然也有一些优化的方法，第一种是选择彼此距离最远的点，具体来说就是先选第一个点，然后选离第一个点最远的当第二个点，然后选第三个点，第三个点到第一、第二两点的距离之和最小，以此类推。第二种是先根据其他聚类算法（如层次聚类）得到聚类结果，</p><pre><code>3. K-Means会不会陷入一直选质心的过程，永远停不下来？ 答：不会，有数学证明K-Means一定会收敛，大致思路是利用SSE的概念（也就是误差平方和），即每个点到自身所归属质心的距离的平方和，这个平方和是一个函数，然后能够证明这个函数是可以最终收敛的函数。 4. 缺点:只能处理球形的簇(只适用于凸样本集)。</code></pre><h3 id="8-2-DBSCAN"><a href="#8-2-DBSCAN" class="headerlink" title="8.2 DBSCAN"></a>8.2 DBSCAN</h3><p>​    DBSCAN（Density-Based Spatial Clustering of Applications with Noise，具有噪声的基于密度的聚类方法）是一种基于密度的空间聚类算法。 该算法将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，它将簇定义为密度相连的点的最大集合。DBSCAN算法的显著优点是聚类速度快且能够有效处理噪声点和发现<strong>任意形状的空间聚类</strong>。<br>​     该算法利用基于密度的聚类的概念，即要求聚类空间中的一定区域内所包含对象（点或其他空间对象）的数目不小于某一给定阈值。过滤低密度区域，发现稠密度样本点。同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</p><p>思想:同一类别的样本，他们之间的紧密相连的，也就是说，在该类别任意样本周围不远处一定有同类别的样本存在。</p><p><strong>概念:</strong></p><ul><li>核心对象: 对一个样本，在它的一个给定邻域内，样本的个数大于等于给定的阈值，则称该样本是核心对象。</li><li>密度直达: 如果$x_i$位于$x_j$的邻域中，且$x_j$是核心对象，那么$x_i$可由$x_j$密度直达。</li><li>密度可达:对于$x_i$和$x_j$,如果存在样本序列$p_1,p_2,…,p_T$满足$p_1 = x_i,p_t = x_j$,$p_t+1$可有$p_t$密度直达，则$x_j$由$x_i$密度可达。注意$p_1,…p_t+1$是核心对象。</li><li>密度相连:对于$x_i$和$x_j$,如果存在核心对象样本$x_k$,使得$x_i$和$x_j$均有$x_k$ 密度可达。</li></ul><p><strong>算法流程</strong>:</p><ul><li>找出所有核心对象 </li><li>从一个核心对象出发建立一个簇 </li><li>从核心对象集中去除已经被分簇的核心对象</li><li>对剩余核心对象重复执行第2、3步，至核心对象集为空。</li></ul><p><strong>如何从一个核心对象出发建立簇</strong>:</p><pre><code> 初始，给定数据集D中所有对象都被标记为“unvisited”，DBSCAN随机选择一个未访问的对象p，标记p为“visited”，并检查p的**ϵ-**领域是否至少包含MinPts个对象。如果不是，则p被标记为噪声点。否则为p创建一个新的簇C，并且把p的**ϵ-**领域中所有对象都放在候选集合N中。DBSCAN迭代地把N中不属于其他簇的对象添加到C中。在此过程中，对应N中标记为“unvisited”的对象 P&#39; ,DBSCAN把它标记为“visited”，并且检查它的**ϵ-**领域，如果 P&#39; 的**ϵ-**领域至少包含MinPts个对象，则P&#39; 的**ϵ-**领域中的对象都被添加到N中。DBSCAN继续添加对象到C，直到C不能扩展，即直到N为空。此时簇C完成生成，输出。</code></pre><h3 id="8-3评价指标"><a href="#8-3评价指标" class="headerlink" title="8.3评价指标"></a>8.3评价指标</h3><p>标准: 簇内相似度高，簇间相似度低</p><p>内部指标:</p><p>DB指数</p><p><img src="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/dbi.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200721150259920"></p><p>外部指标:</p><p>Jaccard 系数</p><p><img src="/EruLv.github.io/2020/07/01/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%A4%8D%E4%B9%A0/jaccard.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20200721151105353"></p>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ STL</title>
    <link href="/EruLv.github.io/2020/06/20/C-STL/"/>
    <url>/EruLv.github.io/2020/06/20/C-STL/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Leetcoed_week_1</title>
    <link href="/EruLv.github.io/2020/06/17/Leetcode-week-1/"/>
    <url>/EruLv.github.io/2020/06/17/Leetcode-week-1/</url>
    
    <content type="html"><![CDATA[<h2 id="Leetcode-打卡-week-1"><a href="#Leetcode-打卡-week-1" class="headerlink" title="Leetcode 打卡 week 1"></a>Leetcode 打卡 week 1</h2><h3 id="1-两数之和"><a href="#1-两数之和" class="headerlink" title="1. 两数之和"></a>1. 两数之和</h3><p>给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素不能使用两遍。</p><p><strong>示例</strong></p><pre><code>给定 nums = [2, 7, 11, 15], target = 9因为 nums[0] + nums[1] = 2 + 7 = 9所以返回 [0, 1]</code></pre><h4 id="Solution1"><a href="#Solution1" class="headerlink" title="Solution1"></a>Solution1</h4><p>暴力枚举$O(n^2)$</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; res;        int n = nums.size();        for(int i = 0; i &lt; n; i++){            for(int j = i; j&lt;n; j++){                if( i!=j &amp;&amp; nums[i] + nums[j] == target){                    res.push_back(i);                    res.push_back(j);                }            }        }        return res;    }};</code></pre><h4 id="Solution-2"><a href="#Solution-2" class="headerlink" title="Solution 2"></a>Solution 2</h4><p>排序 + 双指针, 参考<a href="https://www.acwing.com/problem/content/802/" target="_blank" rel="noopener">https://www.acwing.com/problem/content/802/</a></p><p>因为需要存下标，很不推荐这种方法。</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        vector&lt;int&gt; res;        vector&lt;pair&lt;int, int&gt;&gt; a;        for(int i = 0; i&lt; nums.size();i++) a.push_back({nums[i], i});        sort(a.begin(),a.end());  //升序，nlogn        for(int i = 0, j = 0; i&lt;a.size(); i++){    //O(2n)            while(a[i].first + a[j].first &lt; target) j++;            if( i != j &amp;&amp;a[i].first + a[j].first == target) {                res.push_back(a[i].second);                res.push_back(a[j].second);            }        }        sort(res.begin(), res.end());        return res;    }};</code></pre><h4 id="Solution-3"><a href="#Solution-3" class="headerlink" title="Solution 3"></a>Solution 3</h4><p>Hash map</p><pre><code class="lang-c++">class Solution {public:    vector&lt;int&gt; twoSum(vector&lt;int&gt;&amp; nums, int target) {        unordered_map&lt;int, int&gt; heap;    //基于散列表，查找时间为O(1)        for(int i = 0; i&lt; nums.size(); i++){            int r = target - nums[i];   //寻找目标值            if (heap.count(r)) return {heap[r], i};    //判断是否存在该键            heap[nums[i]] = i;        }        return {};    }};</code></pre><h3 id="2-两数相加"><a href="#2-两数相加" class="headerlink" title="2.两数相加"></a>2.两数相加</h3><p>给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。</p><p>如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。</p><p>您可以假设除了数字 0 之外，这两个数都不会以 0 开头。</p><p><strong>示例：</strong></p><pre><code class="lang-c++">输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807</code></pre><h4 id="Solution"><a href="#Solution" class="headerlink" title="Solution"></a>Solution</h4><pre><code class="lang-c++">/** * Definition for singly-linked list. * struct ListNode { *     int val; *     ListNode *next; *     ListNode(int x) : val(x), next(NULL) {} * }; */class Solution {public:    ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {        ListNode* head = new ListNode(-1);        ListNode* cur = head;        int t = 0;  //进位        while(l1 || l2 || t){   //若t最后为1，需要添加一个节点            if(l1) t += l1-&gt;val, l1 = l1-&gt;next;            if(l2) t += l2-&gt;val, l2 = l2-&gt;next;            cur-&gt;next = new ListNode(t % 10);            cur = cur-&gt;next;            t /= 10;        }        return head-&gt;next;    }};</code></pre><h3 id="3-无重复字符的最长字串"><a href="#3-无重复字符的最长字串" class="headerlink" title="3.无重复字符的最长字串"></a>3.无重复字符的最长字串</h3><p>给定一个字符串，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><p><strong>示例 1:</strong></p><pre><code>输入: &quot;abcabcbb&quot;输出: 3 解释: 因为无重复字符的最长子串是 &quot;abc&quot;，所以其长度为 3。</code></pre><p><strong>示例 2:</strong></p><pre><code>输入: &quot;bbbbb&quot;输出: 1解释: 因为无重复字符的最长子串是 &quot;b&quot;，所以其长度为 1。</code></pre><p><strong>示例 3:</strong></p><pre><code>输入: &quot;pwwkew&quot;输出: 3解释: 因为无重复字符的最长子串是 &quot;wke&quot;，所以其长度为 3。     请注意，你的答案必须是 子串 的长度，&quot;pwke&quot; 是一个子序列，不是子串。</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution"></a>Solution</h4><p>双指针算法.</p><p> 假设[j,i]为最长无重复字串，i向后移动时，j只能不动或向后移动。</p><pre><code class="lang-c++">class Solution {public:    int lengthOfLongestSubstring(string s) {        unordered_map&lt;char, int&gt; heap;        int res = 0;        for(int i =0, j = 0; i&lt;s.size();i++){            heap[s[i]] ++;            while(heap[s[i]] &gt; 1){                heap[s[j]] --;                j ++;            }            res = max(res, i - j + 1);        }    return res;    }};</code></pre><p>以”pwwkew”为例：</p><pre><code class="lang-c++">i = 0, j = 0, {p:1}i = 1, j = 0, {p:1, w:1}i = 2, j = 0, {p:1, w:2}     -&gt; j++, {w:2}     -&gt; j++, {w:1}i = 3, j = 2, {k:1, w:1}i = 4, j = 2, {k:1, w:1, e:1}i = 5, j = 2, {k:1, w:2, e:1}...</code></pre><h3 id="4-寻找两个正序数组的中位数"><a href="#4-寻找两个正序数组的中位数" class="headerlink" title="4.寻找两个正序数组的中位数"></a>4.寻找两个正序数组的中位数</h3><p>给定两个大小为 m 和 n 的正序（从小到大）数组 nums1 和 nums2。</p><p>请你找出这两个正序数组的中位数，并且要求算法的时间复杂度为 O(log(m + n))。</p><p>你可以假设 nums1 和 nums2 不会同时为空。</p><p><strong>示例 1:</strong></p><pre><code>nums1 = [1, 3]nums2 = [2]则中位数是 2.0</code></pre><p><strong>示例 2:</strong></p><pre><code>nums1 = [1, 2]nums2 = [3, 4]则中位数是 (2 + 3)/2 = 2.5</code></pre><h4 id="Solution-1"><a href="#Solution-1" class="headerlink" title="Solution 1"></a>Solution 1</h4><p>思想和归并排序相同。$O(m+n)$</p><pre><code class="lang-c++">class Solution {public:    double findMedianSortedArrays(vector&lt;int&gt;&amp; nums1, vector&lt;int&gt;&amp; nums2) {        double res;        vector&lt;int&gt; r;        int i = 0 , j = 0;        while(i &lt; nums1.size() &amp;&amp; j &lt; nums2.size()){            if(nums1[i] &lt; nums2[j]) r.push_back(nums1[i++]);            else r.push_back(nums2[j++]);        }        while(i &lt; nums1.size()) r.push_back(nums1[i++]);        while(j &lt; nums2.size()) r.push_back(nums2[j++]);        int n = nums1.size() +  nums2.size();        if(n%2 == 0)            res = double(r[n&gt;&gt;1] + r[n-1&gt;&gt;1])/2;        else res = r[n&gt;&gt;1];        return res;    }};</code></pre><h4 id="Solution-2-1"><a href="#Solution-2-1" class="headerlink" title="Solution 2"></a>Solution 2</h4>]]></content>
    
    
    
    <tags>
      
      <tag>leetcode 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>oj好题错题集</title>
    <link href="/EruLv.github.io/2020/06/11/oj%E9%94%99%E9%A2%98%E9%9B%86/"/>
    <url>/EruLv.github.io/2020/06/11/oj%E9%94%99%E9%A2%98%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="oj好题错题集"><a href="#oj好题错题集" class="headerlink" title="oj好题错题集"></a>oj好题错题集</h1><h2 id="1-模拟"><a href="#1-模拟" class="headerlink" title="1.模拟"></a>1.模拟</h2><h3 id="1-1-蚂蚁坠落"><a href="#1-1-蚂蚁坠落" class="headerlink" title="1.1 蚂蚁坠落"></a>1.1 蚂蚁坠落</h3><pre><code>https://www.nowcoder.com/practice/fdd6698014c340178a8b1f28ea5fadf8?tpId=40&amp;&amp;tqId=21420&amp;rp=1&amp;ru=/activity/oj&amp;qru=/ta/kaoyan/question-ranking</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>c++ 算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algorithm排序</title>
    <link href="/EruLv.github.io/2020/06/11/Algoritm%E6%8E%92%E5%BA%8F/"/>
    <url>/EruLv.github.io/2020/06/11/Algoritm%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h2 id="基础算法-一-——排序"><a href="#基础算法-一-——排序" class="headerlink" title="基础算法(一)——排序"></a>基础算法(一)——排序</h2><h3 id="1-快排"><a href="#1-快排" class="headerlink" title="1.快排"></a>1.快排</h3><p>快排是不稳定的。</p><p>基于<strong>分治</strong>，步骤:</p><ol><li>确定分界点</li><li>调整区间，&lt;=x在x左边，&gt;=x的在x右边。</li><li>递归，左边右边排序。</li></ol><pre><code class="lang-c++">void quick_sort(int q[], int l, int r){    if(l&gt;=r) return;    int x = q[l+r&gt;&gt;1], i = l - 1, j = r + 1;    while(i &lt; j){        do i++; while(q[i] &lt; x);        do j--; while(q[j] &gt; x);        if(i &lt; j) swap(q[i], q[j]);    }    quick_sort(q,l,j);    quick_sort(q,j+1,r);}</code></pre><h3 id="2-归并排序"><a href="#2-归并排序" class="headerlink" title="2.归并排序"></a>2.归并排序</h3><p>归并排序是稳定的。</p><ol><li>确定分界点。mid = (l+r)/2</li><li>递归排序left,right</li><li>归并，合二为一</li></ol><pre><code class="lang-c++">void merge_sort(int q[], int l, int r){    if (l &gt;= r) return;    int mid = l + r &gt;&gt; 1;    merge_sort(q, l, mid);    merge_sort(q, mid + 1, r);    int k = 0, i = l, j = mid + 1;    while (i &lt;= mid &amp;&amp; j &lt;= r)        if (q[i] &lt; q[j]) tmp[k ++ ] = q[i ++ ];        else tmp[k ++ ] = q[j ++ ];    while (i &lt;= mid) tmp[k ++ ] = q[i ++ ];    while (j &lt;= r) tmp[k ++ ] = q[j ++ ];    for (i = l, j = 0; i &lt;= r; i ++, j ++ ) q[i] = tmp[j];}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法 排序</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Algoritm模板</title>
    <link href="/EruLv.github.io/2020/06/10/Algoritm%E6%A8%A1%E6%9D%BF/"/>
    <url>/EruLv.github.io/2020/06/10/Algoritm%E6%A8%A1%E6%9D%BF/</url>
    
    <content type="html"><![CDATA[<h2 id="C-常用算法模板（一）"><a href="#C-常用算法模板（一）" class="headerlink" title="C++常用算法模板（一）"></a>C++常用算法模板（一）</h2><p>字符串、数字、数组的基础操作。</p><h3 id="1-反序数"><a href="#1-反序数" class="headerlink" title="1.反序数"></a>1.反序数</h3><p>1234-&gt;4321。</p><p>可用于判断数字是否对称。</p><pre><code class="lang-c++">int reverse(int x){    //反序数    int r = 0;    while(x!=0){        r *= 10;        r += x%10;        x /= 10;    }     return r;}</code></pre><h4 id="2-字符串反转"><a href="#2-字符串反转" class="headerlink" title="2.字符串反转"></a>2.字符串反转</h4><pre><code class="lang-c++">string reverse(string s){    string r = &quot;&quot;;    for(int i=s.size()-1;i&gt;=0;i--){        r += s[i];    }    return r;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>算法 c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>PAT甲级1001</title>
    <link href="/EruLv.github.io/2020/05/22/PAT%E7%94%B2%E7%BA%A71001/"/>
    <url>/EruLv.github.io/2020/05/22/PAT%E7%94%B2%E7%BA%A71001/</url>
    
    <content type="html"><![CDATA[<h2 id="A-B-Format"><a href="#A-B-Format" class="headerlink" title="A+B Format"></a>A+B Format</h2><h3 id="Description"><a href="#Description" class="headerlink" title="Description"></a>Description</h3><p>Calculate A + B and output the sum in standard format—hat is, the digits must be separated into groups of three by commas (unless there are less than four digits).</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case contains a pair of integers <em>a</em> and <em>b</em> where  </p><script type="math/tex; mode=display">-10^6<= a,b <= 10^6</script><p>The numbers are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, you should output the sum of <em>a</em> and <em>b</em> in one line. The sum must be written in the standard format.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><pre><code class="lang-c++">-1000000 9</code></pre><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><pre><code class="lang-c++">-999,991</code></pre><h3 id="My-Solution"><a href="#My-Solution" class="headerlink" title="My Solution:"></a>My Solution:</h3><pre><code class="lang-c++">#include&lt;iostream&gt;#include&lt;string&gt;using namespace std;int main(){    int a,b;    cin&gt;&gt;a&gt;&gt;b;    int r = a+b;    if(r==0){        cout&lt;&lt;0&lt;&lt;endl;        return 0;    }    int flag = r/abs(r);    if(flag==-1)        cout&lt;&lt;&quot;-&quot;;    string s = to_string(abs(r));    int j = 3-s.size()%3;    bool f = j==0;    for(int i=0;i&lt;s.size();i++){        if((i+j)%3==0 &amp;&amp; i!=0){             cout&lt;&lt;&quot;,&quot;;        }        cout&lt;&lt;s[i];    }    cout&lt;&lt;endl;    return 0;}</code></pre>]]></content>
    
    
    
    <tags>
      
      <tag>PAT</tag>
      
      <tag>字符串处理</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>test</title>
    <link href="/EruLv.github.io/2020/05/22/test/"/>
    <url>/EruLv.github.io/2020/05/22/test/</url>
    
    <content type="html"><![CDATA[<h1 id="This-is-a-test"><a href="#This-is-a-test" class="headerlink" title="This is a test."></a>This is a test.</h1><p><img src="/EruLv.github.io/2020/05/22/test/test1.jpg" srcset="/EruLv.github.io/img/loading.gif" alt="test1"></p>]]></content>
    
    
    
    <tags>
      
      <tag>test</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>cpp常用函数</title>
    <link href="/EruLv.github.io/2020/03/19/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/"/>
    <url>/EruLv.github.io/2020/03/19/cpp%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="c-常用函数"><a href="#c-常用函数" class="headerlink" title="c++常用函数"></a>c++常用函数</h2><h3 id="1-排序"><a href="#1-排序" class="headerlink" title="1.排序"></a>1.排序</h3><h4 id="sort"><a href="#sort" class="headerlink" title="sort:"></a>sort:</h4><p>头文件:</p><pre><code class="lang-c++">#include&lt;algorithm&gt;</code></pre><p>使用方法:</p><pre><code class="lang-c++">void sort (RandomAccessIterator first, RandomAccessIterator last, Compare comp);</code></pre><p>（1）第一个参数first：是要排序的数组的起始地址。</p><p>（2）第二个参数last：是结束的地址（最后一个数据的后一个数据的地址）</p><p>（3）第三个参数comp是排序的方法：可以是从升序也可是降序。如果第三个参数不写，则默认的排序方法是<strong>从小到大</strong>排序。</p><h4 id="qsort"><a href="#qsort" class="headerlink" title="qsort:"></a>qsort:</h4><pre><code class="lang-c++">void qsort(void *base, size_t nitems, size_t size, int (*compar)(const void *, const void*))</code></pre><ul><li><p><strong>base</strong> — 指向要排序的数组的第一个元素的指针。</p></li><li><p><strong>nitems</strong> — 由 base 指向的数组中元素的个数。</p></li><li><p><strong>size</strong> — 数组中每个元素的大小，以字节为单位。</p></li><li><p><strong>compar</strong> — 用来比较两个元素的函数。</p></li></ul><h3 id="2-输出保留小数后几位"><a href="#2-输出保留小数后几位" class="headerlink" title="2.输出保留小数后几位"></a>2.输出保留小数后几位</h3><p>头文件:</p><pre><code class="lang-c++">#include&lt;iomanip&gt;</code></pre><p>需要补零:</p><pre><code class="lang-c++">cout&lt;&lt;fixed&lt;&lt;setprecision(需要精确到小数点后几位)&lt;&lt;ans&lt;&lt;endl;</code></pre><p>不需要补零:</p><pre><code class="lang-c++">cout&lt;&lt;setprecision(需要精确到小数点后几位)&lt;&lt;ans&lt;&lt;endl;</code></pre><p><strong>推荐</strong>：更简单的方法:使用printf()</p><pre><code class="lang-c++">float d = 0.235;printf(&quot;%.5f\n&quot;,d);</code></pre><p>结果:0.23500</p><pre><code class="lang-c++">float d = 0.235;printf(&quot;%.2f\n&quot;,d);</code></pre><p>结果: 0.23</p><h3 id="3-格式化输出-日期"><a href="#3-格式化输出-日期" class="headerlink" title="3.格式化输出(日期)"></a>3.格式化输出(日期)</h3><pre><code class="lang-c++">printf(&quot;%04d-%02d-%02d\n&quot;,yyyy,mm,dd);</code></pre><p>会右对齐左补0.</p><h3 id="4-全局变量声明"><a href="#4-全局变量声明" class="headerlink" title="4.全局变量声明"></a>4.全局变量声明</h3><p>声明的int 的全局变量，数组会默认初始化为0.</p><h3 id="5-无限大与无限小-inf"><a href="#5-无限大与无限小-inf" class="headerlink" title="5.无限大与无限小(inf)"></a>5.无限大与无限小(inf)</h3><pre><code class="lang-c++">int inf = 1e9;//更好的: int最大2^31 - 1, 约等于10^9。int inf = 0x3f3f3f3f;</code></pre><h3 id="6-string与int互转"><a href="#6-string与int互转" class="headerlink" title="6.string与int互转"></a>6.string与int互转</h3><p>atoi:(表示 alphanumeric to integer)是把字符串转换成整型数的一个函数。</p><pre><code class="lang-c++">string s = &quot;123&quot;;int x = atoi(s.c_str());cout&lt;&lt;x&lt;&lt;endl;</code></pre><p>int转字符串</p><pre><code class="lang-c++">#include&lt;string&gt;string s = &quot;&quot;;int x = 5;s = to_string(x);</code></pre><p>c</p><h3 id="7-输入带空格的字符串"><a href="#7-输入带空格的字符串" class="headerlink" title="7.输入带空格的字符串"></a>7.输入带空格的字符串</h3><pre><code class="lang-c++">#include&lt;string.h&gt;char str[1000];gets(str);int len = strlen(str);</code></pre><p>or</p><pre><code class="lang-c++">#include&lt;string&gt;string str;getline(cin , str);cout&lt;&lt;str&lt;&lt;endl;</code></pre><h3 id="8-清空数组"><a href="#8-清空数组" class="headerlink" title="8.清空数组"></a>8.清空数组</h3><p>memset函数</p><pre><code class="lang-c++">#include &lt;cstring&gt;const int N = 128;int hs[N];int main(){    hs[0] = 5;    cout&lt;&lt;hs[0]&lt;&lt;endl;    memset(hs, 0 , sizeof(hs));    cout&lt;&lt;hs[0]&lt;&lt;endl;    return 0;}</code></pre><h3 id="9-分词"><a href="#9-分词" class="headerlink" title="9. 分词"></a>9. 分词</h3><pre><code class="lang-c++">    //分词    s += &quot; &quot;;    string tmp = &quot;&quot;;    int m = 0;    for(int i = 0; i &lt; s.size(); i++){        if(s[i] == &#39; &#39;){            w[m++] = tmp;            tmp = &quot;&quot;;        }        else{            tmp += s[i];        }    }</code></pre><h3 id><a href="#" class="headerlink" title=" "></a> </h3>]]></content>
    
    
    
    <tags>
      
      <tag>c++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>矩阵求导运算</title>
    <link href="/EruLv.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E8%BF%90%E7%AE%97/"/>
    <url>/EruLv.github.io/2020/03/18/%E7%9F%A9%E9%98%B5%E6%B1%82%E5%AF%BC%E8%BF%90%E7%AE%97/</url>
    
    <content type="html"><![CDATA[<h2 id="矩阵求导运算推导与总结"><a href="#矩阵求导运算推导与总结" class="headerlink" title="矩阵求导运算推导与总结"></a>矩阵求导运算推导与总结</h2><h3 id="1-标量对向量求导"><a href="#1-标量对向量求导" class="headerlink" title="1.标量对向量求导"></a>1.标量对向量求导</h3><p>输入向量，输出标量。即映射关系为$f:R^N➡R$ 。</p><p>设$y = f(\boldsymbol{x})$ ,$\boldsymbol{x}$是Nx1的矢量，y是标量。</p><p>则求导结果为:</p><script type="math/tex; mode=display">\frac{\partial y}{\partial \boldsymbol{x}}=\left(\frac{\partial y}{\partial x_{1}}, \frac{\partial y}{\partial x_{2}}, \ldots, \frac{\partial y}{\partial x_{N}}\right)</script><h3 id="2-向量对向量求导"><a href="#2-向量对向量求导" class="headerlink" title="2.向量对向量求导"></a>2.向量对向量求导</h3><p>输入向量，输出也是向量，则需要用到 Jacobian矩阵。</p><p>假设映射关系为$f:R^N➡R^M$ ,输入输出都为向量。$\boldsymbol{y} = f(\boldsymbol{x})$ ,则有:</p><script type="math/tex; mode=display">\frac{\partial y}{\partial x}=\left(\begin{array}{ccc}\frac{\partial y_{1}}{\partial x_{1}} & \cdots & \frac{\partial y_{1}}{\partial x_{N}} \\\vdots & \ddots & \vdots \\\frac{\partial y_{M}}{\partial x_{1}} & \cdots & \frac{\partial y_{M}}{\partial x_{N}}\end{array}\right)</script><p>输出MxN的矩阵。</p><script type="math/tex; mode=display">\left(\frac{\partial \boldsymbol{y}}{\partial \boldsymbol{x}}\right)_{i j}=\frac{\partial y_{i}}{\partial x_{j}}</script><h4 id="2-1-x-为列向量"><a href="#2-1-x-为列向量" class="headerlink" title="2.1$x$为列向量"></a>2.1$x$为列向量</h4><p>假如$W$ 是一个NxM的矩阵，$\boldsymbol{z}=\boldsymbol{W}\boldsymbol{x}$ ，$\boldsymbol{x}$为Mx1的列向量，$\boldsymbol{z}$为Nx1的列向量,Jacobian矩阵为NxM维。</p><script type="math/tex; mode=display">z_{i}=\sum_{k=1}^{m} W_{i k} x_{k}</script><script type="math/tex; mode=display">\left(\frac{\partial \boldsymbol{z}}{\partial \boldsymbol{x}}\right)_{i j}=\frac{\partial z_{i}}{\partial x_{j}}=\frac{\partial}{\partial x_{j}} \sum_{k=1}^{m} W_{i k} x_{k}=\sum_{k=1}^{m} W_{i k} \frac{\partial}{\partial x_{j}} x_{k}=W_{i j}</script><p>所以</p><script type="math/tex; mode=display">\frac{\partial{\boldsymbol{z}}}{\partial{\boldsymbol{x}}} = \boldsymbol{W}</script><h4 id="2-2-x-为行向量"><a href="#2-2-x-为行向量" class="headerlink" title="2.2 $x$为行向量"></a>2.2 $x$为行向量</h4><p>假设有$\boldsymbol{z}=\boldsymbol{x}\boldsymbol{W}$ ，$\boldsymbol{x}$为1xN的列向量，$\boldsymbol{z}$为1xM的列向量.W维度为NxM,Jacobian矩阵为MxN.</p><script type="math/tex; mode=display">\frac{\partial{\boldsymbol{z}}}{\partial{\boldsymbol{x}}} = \boldsymbol{W^T}</script><h3 id="3-向量对矩阵求导"><a href="#3-向量对矩阵求导" class="headerlink" title="3.向量对矩阵求导"></a>3.向量对矩阵求导</h3>]]></content>
    
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>线性代数</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
