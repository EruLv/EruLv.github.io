<!DOCTYPE html>
<html lang="zh-CN">





<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="/EruLv.github.io/img/apple-touch-icon.png">
  <link rel="icon" type="image/png" href="/EruLv.github.io/img/favicon.png">
  <meta name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="description" content="">
  <meta name="author" content="Eru Lv">
  <meta name="keywords" content="">
  <title>java基础2 - Hexo</title>

  <link  rel="stylesheet" href="https://cdn.staticfile.org/font-awesome/5.12.1/css/all.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/mdbootstrap/4.13.0/css/mdb.min.css" />
<link  rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/3.0.1/github-markdown.min.css" />

<link rel="stylesheet" href="//at.alicdn.com/t/font_1067060_qzomjdt8bmp.css">



  <link  rel="stylesheet" href="/EruLv.github.io/lib/prettify/tomorrow-night-eighties.min.css" />

<link  rel="stylesheet" href="/EruLv.github.io/css/main.css" />


  <link defer rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css" />


<!-- 自定义样式保持在最底部 -->


<meta name="generator" content="Hexo 4.2.0"></head>


<body>
  <header style="height: 70vh;">
    <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand"
       href="/EruLv.github.io/">&nbsp;<strong>HwLv's blog</strong>&nbsp;</a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/EruLv.github.io/">首页</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/EruLv.github.io/archives/">归档</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/EruLv.github.io/categories/">分类</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/EruLv.github.io/tags/">标签</a>
          </li>
        
          
          
          
          
          <li class="nav-item">
            <a class="nav-link" href="/EruLv.github.io/about/">关于</a>
          </li>
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i
                class="iconfont icon-search"></i>&nbsp;&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

    <div class="view intro-2" id="background" parallax=true
         style="background: url('/EruLv.github.io/img/bg2.jpg') no-repeat center center;
           background-size: cover;">
      <div class="full-bg-img">
        <div class="mask rgba-black-light flex-center">
          <div class="container text-center white-text fadeInUp">
            <span class="h2" id="subtitle">
              
            </span>

            
              
                <p class="mt-3 post-meta">
                  <i class="fas fa-calendar-alt" aria-hidden="true"></i>
                  星期二, 八月 18日 2020, 10:27 晚上
                </p>
              

              <p class="mt-1">
                
                  
                  <span class="post-meta">
                    <i class="far fa-chart-bar"></i>
                    9.9k 字
                  </span>
                

                
                  
                  <span class="post-meta">
                      <i class="far fa-clock"></i>
                      46 分钟
                  </span>
                

                
              </p>
            
          </div>

          
        </div>
      </div>
    </div>
  </header>

  <main>
    
      

<div class="container-fluid">
  <div class="row">
    <div class="d-none d-lg-block col-lg-2"></div>
    <div class="col-lg-8 nopadding-md">
      <div class="container nopadding-md" id="board-ctn">
        <div class="py-5 z-depth-3" id="board">
          <div class="post-content mx-auto" id="post">
            
              <p
                class="note note-warning">本文最后更新于：星期六, 十月 3日 2020, 3:32 下午</p>
            
            <div class="markdown-body">
              <h1 id="Java基础2"><a href="#Java基础2" class="headerlink" title="Java基础2"></a>Java基础2</h1><h2 id="8-接口"><a href="#8-接口" class="headerlink" title="8.接口"></a>8.接口</h2><h3 id="1-抽象方法和抽象类"><a href="#1-抽象方法和抽象类" class="headerlink" title="1.抽象方法和抽象类"></a>1.抽象方法和抽象类</h3><p>仅有声明而没有方法体。</p>
<pre><code class="lang-java">
abstract class Instrument {    //抽象类
  private int i; // Storage allocated for each
  public abstract void play(Note n);    //抽象方法
  public String what() { return &quot;Instrument&quot;; }
  public abstract void adjust();
}
</code></pre>
<p>包含抽象方法的类叫做抽象类。<strong>如果一个类包含一个或多个抽象方法，则该类必须是抽象的。</strong></p>
<p><strong>如果从一个抽象类继承，必须为基类中的所有抽象方法提供定义，否则该类也会被强制认为是抽象类。</strong></p>
<h3 id="2-接口"><a href="#2-接口" class="headerlink" title="2.接口"></a>2.接口</h3><p>更纯粹的抽象方法，<strong>接口内不能有方法体。</strong></p>
<p>用<code>interface</code>关键字代替<code>class</code></p>
<p>要想某个类遵循特定的接口，需要用<code>implements</code>关键字（类似于<code>extents</code>，必须实现接口的全部方法。</p>
<p>接口类中的方法必须被定义为<code>public</code>（默认<code>public</code>）。</p>
<pre><code class="lang-java">interface Instrument {
  int VALUE = 5; 
  void play(Note n); // Automatically public
  void adjust();
}

class Wind implements Instrument {
  public void play(Note n) {
    print(this + &quot;.play() &quot; + n);
  }
  public String toString() { return &quot;Wind&quot;; }
  public void adjust() { print(this + &quot;.adjust()&quot;); }
}
</code></pre>
<h3 id="3-多重继承"><a href="#3-多重继承" class="headerlink" title="3.多重继承"></a>3.多重继承</h3><p>在<code>implements</code>可以添加多个接口，用逗号隔开。</p>
<p>当同时有继承操作时，需要把<code>extends</code>放在前面。</p>
<pre><code class="lang-java">interface CanFight {
  void fight();
}

interface CanSwim {
  void swim();
}

interface CanFly {
  void fly();
}

class ActionCharacter {
  public void fight() {}
}  

//继承+接口
class Hero extends ActionCharacter
    implements CanFight, CanSwim, CanFly {
  public void swim() {}
  public void fly() {}
}
</code></pre>
<h3 id="4-通过继承拓展接口"><a href="#4-通过继承拓展接口" class="headerlink" title="4.通过继承拓展接口"></a>4.通过继承拓展接口</h3><p>接口与类一样也可以继承。</p>
<pre><code class="lang-java">interface Monster {
  void menace();
}

interface DangerousMonster extends Monster {
  void destroy();
}

interface Lethal {
  void kill();
}

class DragonZilla implements DangerousMonster {
  public void menace() {}
  public void destroy() {}
}  

interface Vampire extends DangerousMonster, Lethal {
  void drinkBlood();
}

class VeryBadVampire implements Vampire {
  public void menace() {}
  public void destroy() {}
  public void kill() {}
  public void drinkBlood() {}
}
</code></pre>
<h3 id="5-接口中的域"><a href="#5-接口中的域" class="headerlink" title="5.接口中的域"></a>5.接口中的域</h3><p>接口中的域默认时<code>static</code>和<code>final</code>的，即全局常量。</p>
<pre><code class="lang-java">public interface RandVals {
  Random RAND = new Random(47);
  int RANDOM_INT = RAND.nextInt(10);
  long RANDOM_LONG = RAND.nextLong() * 10;
  float RANDOM_FLOAT = RAND.nextLong() * 10;
  double RANDOM_DOUBLE = RAND.nextDouble() * 10;
} 

public class TestRandVals {
  public static void main(String[] args) {
    print(RandVals.RANDOM_INT);
    print(RandVals.RANDOM_LONG);
    print(RandVals.RANDOM_FLOAT);
    print(RandVals.RANDOM_DOUBLE);
  }
} /* Output:
8
-32032247016559954
-8.5939291E18
5.779976127815049
*///:~
</code></pre>
<h3 id="6-嵌套接口"><a href="#6-嵌套接口" class="headerlink" title="6.嵌套接口"></a>6.嵌套接口</h3><p>在类中声明接口，接口是<code>static</code>的，其他类可以通过类名访问接口。类内的接口可以设置为<code>默认</code>,<code>public</code>，<code>private</code>。</p>
<pre><code class="lang-java">class A {
  interface B {
    void f();
  }
  public class BImp implements B {
    public void f() {}
  }
  private class BImp2 implements B {
    public void f() {}
  }
  public interface C {
    void f();
  }
  class CImp implements C {
    public void f() {}
  }    
  private class CImp2 implements C {
    public void f() {}
  }
  private interface D {
    void f();
  }
  private class DImp implements D {
    public void f() {}
  }
  public class DImp2 implements D {
    public void f() {}
  }
  public D getD() { return new DImp2(); }
  private D dRef;
  public void receiveD(D d) {
    dRef = d;
    dRef.f();
  }
}
</code></pre>
<h2 id="9-内部类"><a href="#9-内部类" class="headerlink" title="9.内部类"></a>9.内部类</h2><h3 id="1-内部类"><a href="#1-内部类" class="headerlink" title="1.内部类"></a>1.内部类</h3><p>当生成一个内部类的对象时，此对象与制造它的外部对象（enclosing object）之间就有了一种联系，所以它能访问其外部对象的所有成员，而不需要任何特殊条件。此外，内部类还拥有其外部类的所有元素的访问权。</p>
<pre><code class="lang-java">interface Selector {
  boolean end();
  Object current();
  void next();
}  

public class Sequence {
  private Object[] items;
  private int next = 0;
  public Sequence(int size) { items = new Object[size]; }
  public void add(Object x) {
    if(next &lt; items.length)
      items[next++] = x;
  }
  private class SequenceSelector implements Selector {
    private int i = 0;
    public boolean end() { return i == items.length; }
    public Object current() { return items[i]; }
    public void next() { if(i &lt; items.length) i++; }
  }
  public Selector selector() {
    return new SequenceSelector();
  }    
  public static void main(String[] args) {
    Sequence sequence = new Sequence(10);
    for(int i = 0; i &lt; 10; i++)
      sequence.add(Integer.toString(i));
    Selector selector = sequence.selector();
    while(!selector.end()) {
      System.out.print(selector.current() + &quot; &quot;);
      selector.next();
    }
  }
} /* Output:
0 1 2 3 4 5 6 7 8 9
*///:~
</code></pre>
<h3 id="2-this和-new方法"><a href="#2-this和-new方法" class="headerlink" title="2.this和.new方法"></a>2<code>.this</code>和<code>.new</code>方法</h3><pre><code class="lang-java">// innerclasses/DotThis.java
// Accessing the outer-class object
public class DotThis {
    void f() { System.out.println(&quot;DotThis.f()&quot;); }

    public class Inner {
        public DotThis outer() {
            return DotThis.this;
            // A plain &quot;this&quot; would be Inner&#39;s &quot;this&quot;
        }
    }

    public Inner inner() { return new Inner(); }

    public static void main(String[] args) {
        DotThis dt = new DotThis();
        DotThis.Inner dti = dt.inner();
        dti.outer().f();
    }
}
</code></pre>
<p>必须使用外部类.new来直接创建内部类</p>
<pre><code class="lang-java">// innerclasses/DotNew.java
// Creating an inner class directly using .new syntax
public class DotNew {
    public class Inner {}
    public static void main(String[] args) {
        DotNew dn = new DotNew();
        DotNew.Inner dni = dn.new Inner();
        //    DotNew.Inner dni = new Inner();    wrong
    }
}
</code></pre>
<p>不能使用.new来直接访问<code>private</code>的内部类，但可以使用创建函数来新建内部类。</p>
<pre><code class="lang-java">class Parcel4 {
  private class PContents implements Contents {
    private int i = 11;
    public int value() { return i; }
  }
  protected class PDestination implements Destination {
    private String label;
    private PDestination(String whereTo) {
      label = whereTo;
    }
    public String readLabel() { return label; }
  }
  public Destination destination(String s) {
    return new PDestination(s);
  }
  public Contents contents() {
    return new PContents();
  }
}

public class TestParcel {
  public static void main(String[] args) {
    Parcel4 p = new Parcel4();
    Contents c = p.contents();
    Destination d = p.destination(&quot;Tasmania&quot;);
    // Illegal -- can&#39;t access private class:
    //! Parcel4.PContents pc = p.new PContents();
  }
} ///:~
</code></pre>
<h3 id="3-内部类和作用域"><a href="#3-内部类和作用域" class="headerlink" title="3.内部类和作用域"></a>3.内部类和作用域</h3><p>你可以在任意一个作用域内定义内部类。</p>
<p>在方法中定义内部类:</p>
<pre><code class="lang-java">// innerclasses/Parcel5.java
// Nesting a class within a method
public class Parcel5 {
    public Destination destination(String s) {
        final class PDestination implements Destination {
            private String label;

            private PDestination(String whereTo) {
                label = whereTo;
            }

            @Override
            public String readLabel() { return label; }
        }
        return new PDestination(s);
    }

    public static void main(String[] args) {
        Parcel5 p = new Parcel5();
        Destination d = p.destination(&quot;Tasmania&quot;);
    }
}
</code></pre>
<p><strong>PDestination</strong> 类是 <code>destination()</code> 方法的一部分，而不是 <strong>Parcel5</strong> 的一部分。所以，在 <code>destination()</code> 之外不能访问 在 <code>destination()</code> 中定义了内部类 <strong>PDestination</strong>，但并不意味着一旦 <code>destination()</code> 方法执行完毕，<strong>PDestination</strong> 就不可用了,它其实与别的类一起编译过了。</p>
<p><strong>匿名内部类</strong></p>
<p>创建一个继承自 <strong>Contents</strong> 的匿名类的对象。通过 <strong>new</strong> 表达式返回的引用被自动向上转型为对 <strong>Contents</strong> 的引用。</p>
<pre><code class="lang-java">public interface Contents {
  int value();
} 

public class Parcel7 {
  public Contents contents() {
    return new Contents() { // Insert a class definition
      private int i = 11;
      public int value() { return i; }
    }; // Semicolon required in this case
  }
  public static void main(String[] args) {
    Parcel7 p = new Parcel7();
    Contents c = p.contents();
  }
} ///:~
</code></pre>
<p>等价于:</p>
<pre><code class="lang-java">public class Parcel7b {
  class MyContents implements Contents {
    private int i = 11;
    public int value() { return i; }
  }
  public Contents contents() { return new MyContents(); }
  public static void main(String[] args) {
    Parcel7b p = new Parcel7b();
    Contents c = p.contents();
  }
} ///:~
</code></pre>
<p>内部匿名类传参要求是Final的。这里省略掉 <strong>final</strong> 也没问题，但是通常最好加上 <strong>final</strong> 作为一种暗示。</p>
<pre><code class="lang-java">public class Parcel9 {
  // Argument must be final to use inside
  // anonymous inner class:
  public Destination destination(final String dest) {
    return new Destination() {
      private String label = dest;
      public String readLabel() { return label; }
    };
  }
  public static void main(String[] args) {
    Parcel9 p = new Parcel9();
    Destination d = p.destination(&quot;Tasmania&quot;);
  }
} ///:~
</code></pre>
<p>匿名类没有构造器，但是可以在它的抽象类中定义构造器。在此例中，不要求变量一定是 <strong>final</strong> 的。因为被传递给匿名类的基类的构造器，它并不会在匿名类内部被直接使用。</p>
<pre><code class="lang-java">abstract class Base {
  public Base(int i) {
    print(&quot;Base constructor, i = &quot; + i);
  }
  public abstract void f();
}  

public class AnonymousConstructor {
  public static Base getBase(int i) {
    return new Base(i) {
      { print(&quot;Inside instance initializer&quot;); }
      public void f() {
        print(&quot;In anonymous f()&quot;);
      }
    };
  }
  public static void main(String[] args) {
    Base base = getBase(47);
    base.f();
  }
} /* Output:
Base constructor, i = 47
Inside instance initializer
In anonymous f()
*///:~
</code></pre>
<h3 id="4-嵌套类"><a href="#4-嵌套类" class="headerlink" title="4.嵌套类"></a>4.嵌套类</h3><p>当内部类声明为<code>static</code>时，叫做嵌套类。</p>
<p>想要理解 <strong>static</strong> 应用于内部类时的含义，就必须记住，普通的内部类对象隐式地保存了一个引用，指向创建它的外部类对象。然而，当内部类是 <strong>static</strong> 的时，就不是这样了。嵌套类意味着：</p>
<ol>
<li>要创建嵌套类的对象，并不需要其外部类的对象。</li>
<li>不能从嵌套类的对象中访问非静态的外部类对象。</li>
</ol>
<h3 id="5-接口内部类"><a href="#5-接口内部类" class="headerlink" title="5.接口内部类"></a>5.接口内部类</h3><p>内部类可以写在接口里。</p>
<pre><code class="lang-java">public interface ClassInInterface {
    void howdy();
    class Test implements ClassInInterface {
        @Override
        public void howdy() {
            System.out.println(&quot;Howdy!&quot;);
        }
        public static void main(String[] args) {
            new Test().howdy();
        }
    }
}
</code></pre>
<h3 id="6-多层嵌套类"><a href="#6-多层嵌套类" class="headerlink" title="6.多层嵌套类"></a>6.多层嵌套类</h3><p>内部类可以访问外部类成员。</p>
<pre><code class="lang-java">class MNA {
    private void f() {}
    class A {
        private void g() {}
        public class B {
            void h() {
                g();
                f();
            }
        }
    }
}
public class MultiNestingAccess {
    public static void main(String[] args) {
        MNA mna = new MNA();
        MNA.A mnaa = mna.new A();
        MNA.A.B mnaab = mnaa.new B();
        mnaab.h();
    }
}
</code></pre>
<h3 id="7-为什么要用内部类"><a href="#7-为什么要用内部类" class="headerlink" title="7.为什么要用内部类"></a>7.为什么要用内部类</h3><p>部类使得多重继承的解决方案变得完整。接口解决了部分问题，而内部类有效地实现了“多重继承”。也就是说，内部类允许继承多个非接口类型（译注：类或抽象类，抽象类不能多重继承）。</p>
<pre><code class="lang-java">class D {}

abstract class E {}

class Z extends D {
    E makeE() {
      return new E() {};  
    }
}

public class MultiImplementation {
    static void takesD(D d) {}
    static void takesE(E e) {}

    public static void main(String[] args) {
        Z z = new Z();
        takesD(z);
        takesE(z.makeE());
    }
}
</code></pre>
<h3 id="8-内部类的继承"><a href="#8-内部类的继承" class="headerlink" title="8.内部类的继承"></a>8.内部类的继承</h3><p>必须使用外部类.内部类方法继承。</p>
<pre><code class="lang-java">class WithInner {
    class Inner {}
}
public class InheritInner extends WithInner.Inner {
    //- InheritInner() {} // Won&#39;t compile
    InheritInner(WithInner wi) {
        wi.super();
    }
    public static void main(String[] args) {
        WithInner wi = new WithInner();
        InheritInner ii = new InheritInner(wi);
    }
}
</code></pre>
<p>另外，内部类覆盖是没用的。</p>
<pre><code class="lang-java">class Egg {
  private Yolk y;
  protected class Yolk {
    public Yolk() { print(&quot;Egg.Yolk()&quot;); }
  }
  public Egg() {
    print(&quot;New Egg()&quot;);
    y = new Yolk();
  }
}  

public class BigEgg extends Egg {
  public class Yolk {    //无效
    public Yolk() { print(&quot;BigEgg.Yolk()&quot;); }
  }
  public static void main(String[] args) {
    new BigEgg();
  }
} /* Output:
New Egg()
Egg.Yolk()
*///:~
</code></pre>
<h2 id="10-集合"><a href="#10-集合" class="headerlink" title="10.集合"></a>10.集合</h2><p>Java集合类库采用“持有对象”（holding objects）的思想，并将其分为两个不同的概念，表示为类库的基本接口：</p>
<ol>
<li><strong>集合（Collection）</strong> ：一个独立元素的序列，这些元素都服从一条或多条规则。<strong>List</strong> 必须以插入的顺序保存元素， <strong>Set</strong> 不能包含重复元素， <strong>Queue</strong> 按照<em>排队规则</em>来确定对象产生的顺序（通常与它们被插入的顺序相同）。</li>
<li><strong>映射（Map）</strong> ： 一组成对的“键值对”对象，允许使用键来查找值。 <strong>ArrayList</strong> 使用数字来查找对象，因此在某种意义上讲，它是将数字和对象关联在一起。 <strong>map</strong> 允许我们使用一个对象来查找另一个对象，它也被称作<em>关联数组</em>（associative array），因为它将对象和其它对象关联在一起；或者称作<em>字典</em>（dictionary），因为可以使用一个键对象来查找值对象，就像在字典中使用单词查找定义一样。 <strong>Map</strong> 是强大的编程工具。</li>
</ol>
<h3 id="1-Collection"><a href="#1-Collection" class="headerlink" title="1.Collection"></a>1.Collection</h3><p><code>collection.addAll()</code>方法接受一个 <strong>Collection</strong> 对象，以及一个数组或是一个逗号分隔的列表，将其中元素添加到 <strong>Collection</strong> 中。</p>
<p><code>Arrays.asList()</code>方法接受一个数组或是逗号分隔的元素列表（使用可变参数），并将其转换为 <strong>List</strong> 对象。</p>
<p><code>Arrays.toString()</code>打印集合。</p>
<h3 id="2-列表List"><a href="#2-列表List" class="headerlink" title="2.列表List"></a>2.列表List</h3><p><strong>List</strong>承诺将元素保存在特定的序列中。 <strong>List</strong> 接口在 <strong>Collection</strong> 的基础上添加了许多方法，允许在 <strong>List</strong> 的中间插入和删除元素。</p>
<p>有两种类型的 <strong>List</strong> ：</p>
<ul>
<li>基本的 <strong>ArrayList</strong> ，擅长随机访问元素，但在 <strong>List</strong> 中间插入和删除元素时速度较慢。</li>
<li><strong>LinkedList</strong> ，它通过代价较低的在 <strong>List</strong> 中间进行的插入和删除操作，提供了优化的顺序访问。 <strong>LinkedList</strong> 对于随机访问来说相对较慢，但它具有比 <strong>ArrayList</strong> 更大的特征集</li>
</ul>
<p>方法:</p>
<p><code>List.add()</code>:在后面添加元素。</p>
<p><code>List.remove(ele)</code>:移除元素ele.</p>
<p><code>List.get(index)</code>:根据下标返回元素。</p>
<p><code>List.indexOf(ele)</code>:返回下标。</p>
<p><code>List.subList(st,ed)</code>:左闭右开</p>
<p><code>Collections.sort(List):</code>排序，无返回</p>
<p><code>Collections.shuffle(List, rand_int)</code>,根据随机种子打乱。</p>
<p>根据已有的List新建List.</p>
<pre><code class="lang-java">List&lt;Pet&gt; copy = new ArrayList&lt;&gt;(pets);
</code></pre>
<p><code>List.retainAll(List)</code>两个集合求交集</p>
<p><code>List.removeAll(List),</code>根据List内容移除</p>
<p><code>List.set(index, object)</code>在index位置替换元素。</p>
<p><code>List.addAll(index, List)</code>,在中间位置添加列表。</p>
<p><code>List.clear()</code>清除。</p>
<h3 id="3-迭代器"><a href="#3-迭代器" class="headerlink" title="3.迭代器"></a>3.迭代器</h3><p>迭代器是一个对象，它在一个序列中移动并选择该序列中的每个对象，而客户端程序员不知道或不关心该序列的底层结构。另外，迭代器通常被称为<em>轻量级对象</em>（lightweight object）：创建它的代价小。因此，经常可以看到一些对迭代器有些奇怪的约束。例如，Java 的 <strong>Iterator</strong> 只能单向移动。这个 <strong>Iterator</strong> 只能用来：</p>
<ol>
<li>使用 <code>iterator()</code> 方法要求集合返回一个 <strong>Iterator</strong>。 <strong>Iterator</strong> 将准备好返回序列中的第一个元素。</li>
<li>使用 <code>next()</code> 方法获得序列中的下一个元素。</li>
<li>使用 <code>hasNext()</code> 方法检查序列中是否还有元素。</li>
<li>使用 <code>remove()</code> 方法将迭代器最近返回的那个元素删除。</li>
</ol>
<pre><code class="lang-java">public class CrossCollectionIteration2 {
  public static void display(Iterable&lt;Pet&gt; ip) {
    Iterator&lt;Pet&gt; it = ip.iterator();
    while(it.hasNext()) {
      Pet p = it.next();
      System.out.print(p.id() + &quot;:&quot; + p + &quot; &quot;);
    }
    System.out.println();
  }
  public static void main(String[] args) {
    List&lt;Pet&gt; pets = Pets.list(8);
    LinkedList&lt;Pet&gt; petsLL = new LinkedList&lt;&gt;(pets);
    HashSet&lt;Pet&gt; petsHS = new HashSet&lt;&gt;(pets);
    TreeSet&lt;Pet&gt; petsTS = new TreeSet&lt;&gt;(pets);
    display(pets);
    display(petsLL);
    display(petsHS);
    display(petsTS);
  }
}
</code></pre>
<p><strong>ListIterator</strong> 是一个更强大的 <strong>Iterator</strong> 子类型，它只能由各种 <strong>List</strong> 类生成。 <strong>Iterator</strong> 只能向前移动，而 <strong>ListIterator</strong> 可以双向移动。它可以生成迭代器在列表中指向位置的后一个和前一个元素的索引，并且可以使用 <code>set()</code> 方法替换它访问过的最近一个元素。可以通过调用 <code>listIterator()</code> 方法来生成指向 <strong>List</strong> 开头处的 <strong>ListIterator</strong> ，还可以通过调用 <code>listIterator(n)</code> 创建一个一开始就指向列表索引号为 <strong>n</strong> 的元素处的 <strong>ListIterator</strong> 。</p>
<pre><code class="lang-java">// collections/ListIteration.java
import typeinfo.pets.*;
import java.util.*;

public class ListIteration {
  public static void main(String[] args) {
    List&lt;Pet&gt; pets = Pets.list(8);
    ListIterator&lt;Pet&gt; it = pets.listIterator();
    while(it.hasNext())
      System.out.print(it.next() +
        &quot;, &quot; + it.nextIndex() +
        &quot;, &quot; + it.previousIndex() + &quot;; &quot;);
    System.out.println();
    // Backwards:
    while(it.hasPrevious())
      System.out.print(it.previous().id() + &quot; &quot;);
    System.out.println();
    System.out.println(pets);
    it = pets.listIterator(3);
    while(it.hasNext()) {
      it.next();
      it.set(Pets.get());
    }
    System.out.println(pets);
  }
}
/* Output:
Rat, 1, 0; Manx, 2, 1; Cymric, 3, 2; Mutt, 4, 3; Pug,
5, 4; Cymric, 6, 5; Pug, 7, 6; Manx, 8, 7;
7 6 5 4 3 2 1 0
[Rat, Manx, Cymric, Mutt, Pug, Cymric, Pug, Manx]
[Rat, Manx, Cymric, Cymric, Rat, EgyptianMau, Hamster,
EgyptianMau]
*/
</code></pre>
<p><strong>LinkedList</strong> 也像 <strong>ArrayList</strong> 一样实现了基本的 <strong>List</strong> 接口，但它在 <strong>List</strong> 中间执行插入和删除操作时比 <strong>ArrayList</strong> 更高效。然而,它在随机访问操作效率方面却要逊色一些。</p>
<p><strong>LinkedList 还添加了一些方法，使其可以被用作栈、队列或双端队列（deque）</strong> 。在这些方法中，有些彼此之间可能只是名称有些差异，或者只存在些许差异，以使得这些名字在特定用法的上下文环境中更加适用（特别是在 <strong>Queue</strong> 中）。例如：</p>
<ul>
<li><code>getFirst()</code> 和 <code>element()</code> 是相同的，它们都返回列表的头部（第一个元素）而并不删除它，如果 <strong>List</strong> 为空，则抛出 <strong>NoSuchElementException</strong> 异常。 <code>peek()</code> 方法与这两个方法只是稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>removeFirst()</code> 和 <code>remove()</code> 也是相同的，它们删除并返回列表的头部元素，并在列表为空时抛出 <strong>NoSuchElementException</strong> 异常。 <code>poll()</code> 稍有差异，它在列表为空时返回 <strong>null</strong> 。</li>
<li><code>addFirst()</code> 在列表的开头插入一个元素。</li>
<li><code>offer()</code> 与 <code>add()</code> 和 <code>addLast()</code> 相同。 它们都在列表的尾部（末尾）添加一个元素。</li>
<li><code>removeLast()</code> 删除并返回列表的最后一个元素。</li>
</ul>
<p>自定义Collection迭代器。</p>
<p>要实现 <strong>Collection</strong> ，就必须实现该接口中的所有方法AbstractCollection。</p>
<pre><code class="lang-java">public class CollectionSequence extends AbstractCollection&lt;Pet&gt; {
  private Pet[] pets = Pets.array(8);
  @Override
  public int size() { return pets.length; }
  @Override
  public Iterator&lt;Pet&gt; iterator() {
    return new Iterator&lt;Pet&gt;() { // [1]
      private int index = 0;
      @Override
      public boolean hasNext() {
        return index &lt; pets.length;
      }
      @Override
      public Pet next() { return pets[index++]; }
      @Override
      public void remove() { // Not implemented
        throw new UnsupportedOperationException();
      }
    };
  }
  public static void main(String[] args) {
    CollectionSequence c = new CollectionSequence();
    InterfaceVsIterator.display(c);
    InterfaceVsIterator.display(c.iterator());
  }
}
</code></pre>
<p>实现<code>for-in</code></p>
<p><code>for-in</code>要求<strong>Iterable</strong> 的接口，该接口包含一个能够生成 <strong>Iterator</strong> 的 <code>iterator()</code> 方法。</p>
<pre><code class="lang-java">// collections/IterableClass.java
// Anything Iterable works with for-in
import java.util.*;

public class IterableClass implements Iterable&lt;String&gt; {
  protected String[] words = (&quot;And that is how &quot; +
    &quot;we know the Earth to be banana-shaped.&quot;
    ).split(&quot; &quot;);
  @Override
  public Iterator&lt;String&gt; iterator() {
    return new Iterator&lt;String&gt;() {
      private int index = 0;
      @Override
      public boolean hasNext() {
        return index &lt; words.length;
      }
      @Override
      public String next() { return words[index++]; }
      @Override
      public void remove() { // Not implemented
        throw new UnsupportedOperationException();
      }
    };
  }
  public static void main(String[] args) {
    for(String s : new IterableClass())
      System.out.print(s + &quot; &quot;);
  }
}
/* Output:
And that is how we know the Earth to be banana-shaped.
*/
</code></pre>
<h3 id="4-堆栈Stack"><a href="#4-堆栈Stack" class="headerlink" title="4.堆栈Stack"></a>4.堆栈Stack</h3><pre><code class="lang-java">// collections/StackTest.java
import java.util.*;

public class StackTest {
  public static void main(String[] args) {
    Deque&lt;String&gt; stack = new ArrayDeque&lt;&gt;();
    for(String s : &quot;My dog has fleas&quot;.split(&quot; &quot;))
      stack.push(s);
    while(!stack.isEmpty())
      System.out.print(stack.pop() + &quot; &quot;);
  }
}
/* Output:
fleas has dog My
*/
</code></pre>
<h3 id="5-集合Set"><a href="#5-集合Set" class="headerlink" title="5.集合Set"></a>5.集合Set</h3><p><strong>Set</strong> 不保存重复的元素。 如果试图将相同对象的多个实例添加到 <strong>Set</strong> 中，那么它会阻止这种重复行为。 <strong>Set</strong> 最常见的用途是测试归属性，可以很轻松地询问某个对象是否在一个 <strong>Set</strong> 中。因此，查找通常是 <strong>Set</strong> 最重要的操作，因此通常会选择 <strong>HashSet</strong> 实现，该实现针对快速查找进行了优化。</p>
<pre><code class="lang-java">// collections/SetOfInteger.java
import java.util.*;

public class SetOfInteger {
  public static void main(String[] args) {
    Random rand = new Random(47);
    Set&lt;Integer&gt; intset = new HashSet&lt;&gt;();
    for(int i = 0; i &lt; 10000; i++)
      intset.add(rand.nextInt(30));
    System.out.println(intset);
  }
}
/* Output:
[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15,
16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29]
*/
</code></pre>
<h3 id="6-映射Map"><a href="#6-映射Map" class="headerlink" title="6.映射Map"></a>6.映射Map</h3><pre><code class="lang-java">import java.util.*;

public class Statistics {
  public static void main(String[] args) {
    Random rand = new Random(47);
    Map&lt;Integer, Integer&gt; m = new HashMap&lt;&gt;();
    for(int i = 0; i &lt; 10000; i++) {
      // Produce a number between 0 and 20:
      int r = rand.nextInt(20);
      Integer freq = m.get(r); // [1]
      m.put(r, freq == null ? 1 : freq + 1);
    }
    System.out.println(m);
  }
}
/* Output:
{0=481, 1=502, 2=489, 3=508, 4=481, 5=503, 6=519,
7=471, 8=468, 9=549, 10=513, 11=531, 12=521, 13=506,
14=477, 15=497, 16=533, 17=509, 18=478, 19=464}
*/
</code></pre>
<h3 id="7-队列Queue"><a href="#7-队列Queue" class="headerlink" title="7.队列Queue"></a>7.队列Queue</h3><pre><code class="lang-java">import java.util.*;

public class QueueDemo {
  public static void printQ(Queue queue) {
    while(queue.peek() != null)
      System.out.print(queue.remove() + &quot; &quot;);
    System.out.println();
  }
  public static void main(String[] args) {
    Queue&lt;Integer&gt; queue = new LinkedList&lt;&gt;();
    Random rand = new Random(47);
    for(int i = 0; i &lt; 10; i++)
      queue.offer(rand.nextInt(i + 10));
    printQ(queue);
    Queue&lt;Character&gt; qc = new LinkedList&lt;&gt;();
    for(char c : &quot;Brontosaurus&quot;.toCharArray())
      qc.offer(c);
    printQ(qc);
  }
}
/* Output:
8 1 1 1 5 14 3 1 0 1
B r o n t o s a u r u s
*/
</code></pre>
<p><code>offer()</code> 是与 <strong>Queue</strong> 相关的方法之一，它在允许的情况下，在队列的尾部插入一个元素，或者返回 <strong>false</strong> 。 </p>
<p><code>peek()</code> 和 <code>element()</code> 都返回队头元素而不删除它，但是如果队列为空，则 <code>element()</code> 抛出 <strong>NoSuchElementException</strong> ，而 <code>peek()</code> 返回 <strong>null</strong> 。</p>
<p> <code>poll()</code> 和 <code>remove()</code><em> 都删除并返回队头元素，但如果队列为空，<code>poll()</code> 返回 <strong>null</strong> ，而 <code>remove()</code> 抛出 <em>*NoSuchElementException</em></em> 。</p>
<p><strong>优先级队列PriorityQueue</strong></p>
<p>当在 <strong>PriorityQueue</strong> 上调用 <code>offer()</code> 方法来插入一个对象时，该对象会在队列中被排序。<sup><a href="#fn_5" id="reffn_5">5</a></sup>默认的排序使用队列中对象的<em>自然顺序</em>（natural order），但是可以通过提供自己的 <strong>Comparator</strong> 来修改这个顺序。 <strong>PriorityQueue</strong> 确保在调用 <code>peek()</code> ， <code>poll()</code> 或 <code>remove()</code> 方法时，获得的元素将是队列中优先级最高的元素。</p>
<h2 id="11-函数式编程"><a href="#11-函数式编程" class="headerlink" title="11.函数式编程"></a>11.函数式编程</h2><p>OO（object oriented，面向对象）是抽象数据，FP（functional programming，函数式编程）是抽象行为。</p>
<h3 id="1-Lambda表达式"><a href="#1-Lambda表达式" class="headerlink" title="1.Lambda表达式"></a>1.Lambda表达式</h3><p>​    Lambda 表达式是使用<strong>最小可能</strong>语法编写的函数定义：</p>
<ol>
<li>Lambda 表达式产生函数，而不是类。 在 JVM（Java Virtual Machine，Java 虚拟机）上，一切都是一个类，因此在幕后执行各种操作使 Lambda 看起来像函数 —— 但作为程序员，你可以高兴地假装它们“只是函数”。</li>
<li>Lambda 语法尽可能少，这正是为了使 Lambda 易于编写和使用。</li>
</ol>
<p>任何 Lambda 表达式的基本语法是：</p>
<ol>
<li>参数。</li>
<li>接着 <code>-&gt;</code>，可视为“产出”。</li>
<li><code>-&gt;</code> 之后的内容都是方法体。</li>
</ol>
<pre><code class="lang-java">// functional/LambdaExpressions.java

interface Description {
  String brief();
}

interface Body {
  String detailed(String head);
}

interface Multi {
  String twoArg(String head, Double d);
}

public class LambdaExpressions {

  static Body bod = h -&gt; h + &quot; No Parens!&quot;; // 当只用一个参数，可以不需要括号 ()。

  static Body bod2 = (h) -&gt; h + &quot; More details&quot;; // 正常情况使用括号 () 包裹参数。 为了保持一致性，也可以使用括号 () 包裹单个参数，虽然这种情况并不常见。

  static Description desc = () -&gt; &quot;Short info&quot;; //  如果没有参数，则必须使用括号 () 表示空参数列表。

  static Multi mult = (h, n) -&gt; h + n; // 对于多个参数，将参数列表放在括号 () 中。

  static Description moreLines = () -&gt; { // 如果在 Lambda 表达式中确实需要多行，则必须将这些行放在花括号中。 在这种情况下，就需要使用 return。
    System.out.println(&quot;moreLines()&quot;);
    return &quot;from moreLines()&quot;;
  };

  public static void main(String[] args) {
    System.out.println(bod.detailed(&quot;Oh!&quot;));
    System.out.println(bod2.detailed(&quot;Hi!&quot;));
    System.out.println(desc.brief());
    System.out.println(mult.twoArg(&quot;Pi! &quot;, 3.14159));
    System.out.println(moreLines.brief());
  }
}
</code></pre>
<p>输出:</p>
<pre><code>Oh! No Parens!
Hi! More details
Short info
Pi! 3.14159
moreLines()
from moreLines()
</code></pre><h3 id="2-方法引用"><a href="#2-方法引用" class="headerlink" title="2.方法引用"></a>2.方法引用</h3><p>方法引用组成：类名或对象名，后面跟 <code>::</code> ，然后跟方法名称。</p>
<pre><code class="lang-java">// functional/MethodReferences.java

import java.util.*;

interface Callable { // [1]
  void call(String s);
}

class Describe {
  void show(String msg) { // [2]
    System.out.println(msg);
  }
}

public class MethodReferences {
  static void hello(String name) { // [3]
    System.out.println(&quot;Hello, &quot; + name);
  }
  static class Description {
    String about;
    Description(String desc) { about = desc; }
    void help(String msg) { // [4]
      System.out.println(about + &quot; &quot; + msg);
    }
  }
  static class Helper {
    static void assist(String msg) { // [5]
      System.out.println(msg);
    }
  }
  public static void main(String[] args) {
    Describe d = new Describe();
    Callable c = d::show; // [6]
    c.call(&quot;call()&quot;); // [7]

    c = MethodReferences::hello; // static方法直接引用
    c.call(&quot;Bob&quot;);

    c = new Description(&quot;valuable&quot;)::help; // 非静态方法需要实例化class
    c.call(&quot;information&quot;);

    c = Helper::assist; // 静态类和静态方法
    c.call(&quot;Help!&quot;);
  }
}
</code></pre>
<p><strong>Runable接口</strong></p>
<p>我们可以使用 Lambda 表达式和方法引用作为 <strong>Runnable</strong></p>
<pre><code class="lang-java">// functional/RunnableMethodReference.java

// 方法引用与 Runnable 接口的结合使用

class Go {
  static void go() {
    System.out.println(&quot;Go::go()&quot;);
  }
}

public class RunnableMethodReference {
  public static void main(String[] args) {

    new Thread(new Runnable() {
      public void run() {
        System.out.println(&quot;Anonymous&quot;);
      }
    }).start();

    new Thread(
      () -&gt; System.out.println(&quot;lambda&quot;)
    ).start();

    new Thread(Go::go).start();
  }
}
</code></pre>
<p><strong>未绑定方法引用</strong></p>
<pre><code class="lang-java">class X {
  String f() { return &quot;X::f()&quot;; }
}

interface MakeString {
  String make();
}

interface TransformX {
  String transform(X x);
}

public class UnboundMethodReference {
  public static void main(String[] args) {
//     MakeString ms = X::f; // [1] should be :MakeString ms = new X()::f
    TransformX sp = X::f;
    X x = new X();
    System.out.println(sp.transform(x)); // [2]
    System.out.println(x.f()); // Same effect
  }
}
/* Output:
X::f()
X::f()
*/
</code></pre>
<p>[1]会报错，因为方法不是静态的，而且方法签名对不上。可以先不实例化类，把方法引用传递给给包含该类的接口方法上。</p>
<p><strong>构造函数的引用</strong></p>
<p>使用class::new来获得构造函数引用。</p>
<pre><code class="lang-java">class Dog {
  String name;
  int age = -1; // For &quot;unknown&quot;
  Dog() { name = &quot;stray&quot;; }
  Dog(String nm) { name = nm; }
  Dog(String nm, int yrs) { name = nm; age = yrs; }
}

interface MakeNoArgs {
  Dog make();
}

interface Make1Arg {
  Dog make(String nm);
}

interface Make2Args {
  Dog make(String nm, int age);
}

public class CtorReference {
  public static void main(String[] args) {
    MakeNoArgs mna = Dog::new; // [1]
    Make1Arg m1a = Dog::new;   // [2]
    Make2Args m2a = Dog::new;  // [3]

    Dog dn = mna.make();
    Dog d1 = m1a.make(&quot;Comet&quot;);
    Dog d2 = m2a.make(&quot;Ralph&quot;, 4);
  }
}
</code></pre>
<h3 id="3-函数式接口"><a href="#3-函数式接口" class="headerlink" title="3.函数式接口"></a>3.函数式接口</h3><h2 id="12-流式编程"><a href="#12-流式编程" class="headerlink" title="12.流式编程"></a>12.流式编程</h2><p>流编程风格:</p>
<p>首先，我们给 <strong>Random</strong> 对象一个种子（以便程序再次运行时产生相同的输出）。<code>ints()</code> 方法产生一个流并且 <code>ints()</code> 方法有多种方式的重载 — 两个参数限定了产生的数值的边界。这将生成一个随机整数流。我们用中间流操作（intermediate stream operation） <code>distinct()</code> 使流中的整数不重复，然后使用 <code>limit()</code> 方法获取前 7 个元素。接下来使用 <code>sorted()</code> 方法排序。最终使用 <code>forEach()</code> 方法遍历输出，它根据传递给它的函数对流中的每个对象执行操作。在这里，我们传递了一个可以在控制台显示每个元素的方法引用：<code>System.out::println</code> 。</p>
<pre><code class="lang-java">// streams/Randoms.java
import java.util.*;
public class Randoms {
    public static void main(String[] args) {
        new Random(47)
            .ints(5, 20)
            .distinct()
            .limit(7)
            .sorted()
            .forEach(System.out::println);
    }
}

//[7, 8, 9, 11, 13, 15, 18]
</code></pre>
<h3 id="1-流创建"><a href="#1-流创建" class="headerlink" title="1.流创建"></a>1.流创建</h3><p>你可以通过 <code>Stream.of()</code> 很容易地将一组元素转化成为流。</p>
<pre><code class="lang-java">import java.util.stream.*;

public class StreamOf {
  public static void main(String[] args) {
    Stream.of(
      new Bubble(1), new Bubble(2), new Bubble(3))
      .forEach(System.out::println);
    Stream.of(&quot;It&#39;s &quot;, &quot;a &quot;, &quot;wonderful &quot;,
      &quot;day &quot;, &quot;for &quot;, &quot;pie!&quot;)
      .forEach(System.out::print);
    System.out.println();
    Stream.of(3.14159, 2.718, 1.618)
      .forEach(System.out::println);
  }
}
/* Output:
Bubble(1)
Bubble(2)
Bubble(3)
It&#39;s a wonderful day for pie!
3.14159
2.718
1.618
*/
</code></pre>
<p>除此之外，每个集合都可以通过调用 <code>stream()</code> 方法来产生一个流。代码示例：</p>
<pre><code class="lang-java">// streams/CollectionToStream.java
import java.util.*;
import java.util.stream.*;
public class CollectionToStream {
    public static void main(String[] args) {
        List&lt;Bubble&gt; bubbles = Arrays.asList(new Bubble(1), new Bubble(2), new Bubble(3));
        System.out.println(bubbles.stream()
            .mapToInt(b -&gt; b.i)
            .sum());

        Set&lt;String&gt; w = new HashSet&lt;&gt;(Arrays.asList(&quot;It&#39;s a wonderful day for pie!&quot;.split(&quot; &quot;)));
        w.stream()
         .map(x -&gt; x + &quot; &quot;)
         .forEach(System.out::print);
        System.out.println();

        Map&lt;String, Double&gt; m = new HashMap&lt;&gt;();
        m.put(&quot;pi&quot;, 3.14159);
        m.put(&quot;e&quot;, 2.718);
        m.put(&quot;phi&quot;, 1.618);
        m.entrySet().stream()
                    .map(e -&gt; e.getKey() + &quot;: &quot; + e.getValue())
                    .forEach(System.out::println);
    }
}
</code></pre>
<p><strong>生成Stream.generate</strong></p>
<p>需要实现supplier<T>，或者直接传一个lambda函数。</T></p>
<pre><code class="lang-java">import java.util.*;
import java.util.function.*;
import java.util.stream.*;

public class Generator implements Supplier&lt;String&gt; {
  Random rand = new Random(47);
  char[] letters =
    &quot;ABCDEFGHIJKLMNOPQRSTUVWXYZ&quot;.toCharArray();
  public String get() {    
    return &quot;&quot; + letters[rand.nextInt(letters.length)];
  }
  public static void main(String[] args) {
    String word = Stream.generate(new Generator())
      .limit(30)
      .collect(Collectors.joining());
    System.out.println(word);
  }
}
</code></pre>
<pre><code class="lang-java">// streams/Duplicator.java
import java.util.stream.*;
public class Duplicator {
    public static void main(String[] args) {
        Stream.generate(() -&gt; &quot;duplicate&quot;)
              .limit(3)
              .forEach(System.out::println);
    }
}
</code></pre>
<p><strong>迭代iterate</strong></p>
<p><code>Stream.iterate()</code> 产生的流的第一个元素是种子（iterate方法的第一个参数），然后将种子传递给方法（iterate方法的第二个参数）。<strong>方法运行的结果被添加到流（作为流的第二个元素），并存储起来作为下次调用 <code>iterate()</code>时的第一个参数</strong>，以此类推。</p>
<pre><code class="lang-java">import java.util.stream.*;

public class Fibonacci {
  int x = 1;
  Stream&lt;Integer&gt; numbers() {
    return Stream.iterate(0, i -&gt; {    //第一次i = 0, 后来i = 1,2...
      int result = x + i;
      x = i;
      return result;
    });
  }
  public static void main(String[] args) {
    new Fibonacci().numbers()
      .limit(10) // Then take 10 of them
      .forEach(System.out::println);
  }
}
</code></pre>
<p><strong>builder</strong></p>
<p>在建造者模式（Builder design pattern）中，首先创建一个 <code>builder</code> 对象，然后将创建流所需的多个信息传递给它，最后<code>builder</code> 对象执行”创建“流的操作。</p>
<pre><code class="lang-java">import java.io.*;
import java.nio.file.*;
import java.util.stream.*;

public class FileToWordsBuilder {
    Stream.Builder&lt;String&gt; builder = Stream.builder();

    public FileToWordsBuilder(String filePath) throws Exception {
        Files.lines(Paths.get(filePath))
             .skip(1) // 略过开头的注释行
             .forEach(line -&gt; {
                  for (String w : line.split(&quot;[ .?,]+&quot;))
                      builder.add(w);
              });
    }

    Stream&lt;String&gt; stream() {
        return builder.build();
    }

    public static void main(String[] args) throws Exception {
        new FileToWordsBuilder(&quot;Cheese.dat&quot;)
            .stream()
            .limit(7)
            .map(w -&gt; w + &quot; &quot;)
            .forEach(System.out::print);
    }
}
</code></pre>
<p><code>Arrays</code> 类中含有一个名为 <code>stream()</code> 的静态方法用于把数组转换成为流。</p>
<pre><code class="lang-java">import java.util.*;
import java.util.stream.*;

public class ArrayStreams {
    public static void main(String[] args) {
        Arrays.stream(new double[] { 3.14159, 2.718, 1.618 })
            .forEach(n -&gt; System.out.format(&quot;%f &quot;, n));
        System.out.println();

        Arrays.stream(new int[] { 1, 3, 5 })
            .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
        System.out.println();

        Arrays.stream(new long[] { 11, 22, 44, 66 })
            .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
        System.out.println();

        // 选择一个区间:
        Arrays.stream(new int[] { 1, 3, 5, 7, 15, 28, 37 }, 3, 6)    //start, end
            .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
    }
}
/*
3.141590 2.718000 1.618000
1 3 5
11 22 44 66
7 15 28
*/
</code></pre>
<h3 id="2-中间操作"><a href="#2-中间操作" class="headerlink" title="2.中间操作"></a>2.中间操作</h3><p>中间操作用于从一个流中获取对象，并将对象作为另一个流从后端输出，以连接到其他操作。</p>
<p><strong><code>peek</code>测试</strong></p>
<p>它允许你无修改地查看流中的元素。代码示例：</p>
<pre><code class="lang-java">class Peeking {
    public static void main(String[] args) throws Exception {
        FileToWords.stream(&quot;Cheese.dat&quot;)
        .skip(21)
        .limit(4)
        .map(w -&gt; w + &quot; &quot;)
        .peek(System.out::print)
        .map(String::toUpperCase)
        .peek(System.out::print)
        .map(String::toLowerCase)
        .forEach(System.out::print);
    }
}
</code></pre>
<p><strong>排序</strong></p>
<p>在 <code>Randoms.java</code> 中，我们熟识了 <code>sorted()</code> 的默认比较器实现。其实它还有另一种形式的实现：传入一个 <strong>Comparator</strong> 参数。代码示例：</p>
<pre><code class="lang-java">// streams/SortedComparator.java
import java.util.*;
public class SortedComparator {
    public static void main(String[] args) throws Exception {
        FileToWords.stream(&quot;Cheese.dat&quot;)
        .skip(10)
        .limit(10)
        .sorted(Comparator.reverseOrder())
        .map(w -&gt; w + &quot; &quot;)
        .forEach(System.out::print);
    }
}
</code></pre>
<p><strong>移除元素</strong></p>
<ul>
<li><code>distinct()</code>：在 <code>Randoms.java</code> 类中的 <code>distinct()</code> 可用于消除流中的重复元素。相比创建一个 <strong>Set</strong> 集合，该方法的工作量要少得多。</li>
<li><code>filter(Predicate)</code>：若元素传递给过滤函数产生的结果为<code>true</code> ，则过滤操作保留这些元素。</li>
</ul>
<p><code>rangeClosed()</code> 定义一个区间，遍历区间中的数，如果不能整除，即余数不等于 0，则 <code>noneMatch()</code> 操作返回 <code>true</code>，如果出现任何等于 0 的结果则返回 <code>false</code>。 <code>noneMatch()</code> 操作一旦有失败就会退出。</p>
<pre><code class="lang-java">import java.util.stream.*;
import static java.util.stream.LongStream.*;

public class Prime {
  public static boolean isPrime(long n) {
    return rangeClosed(2, (long)Math.sqrt(n))
      .noneMatch(i -&gt; n % i == 0);
  }
  public LongStream numbers() {
    return iterate(2, i -&gt; i + 1)
      .filter(Prime::isPrime);
  }
  public static void main(String[] args) {
    new Prime().numbers()
      .limit(10)
      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
    System.out.println();
    new Prime().numbers()
      .skip(90)
      .limit(10)
      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
  }
}
/* Output:
2 3 5 7 11 13 17 19 23 29
467 479 487 491 499 503 509 521 523 541
*/
</code></pre>
<p><strong><code>map</code>应用函数到元素</strong></p>
<ul>
<li><code>map(Function)</code>：将函数操作应用在输入流的元素中，并将返回值传递到输出流中。</li>
<li><code>mapToInt(ToIntFunction)</code>：操作同上，但结果是 <strong>IntStream</strong>。</li>
<li><code>mapToLong(ToLongFunction)</code>：操作同上，但结果是 <strong>LongStream</strong>。</li>
<li><code>mapToDouble(ToDoubleFunction)</code>：操作同上，但结果是 <strong>DoubleStream</strong>。</li>
</ul>
<p><strong><code>flatMap()</code>组合流</strong></p>
<p><code>flatMap()</code> 做了两件事：将产生流的函数应用在每个元素上（与 <code>map()</code> 所做的相同），然后将每个流都扁平化为元素，因而最终产生的仅仅是元素。相当于双重循环。</p>
<pre><code class="lang-java">// streams/FlatMap.java
import java.util.stream.*;
public class FlatMap {
    public static void main(String[] args) {
        Stream.of(1, 2, 3)
        .flatMap(i -&gt; Stream.of(&quot;Gonzo&quot;, &quot;Fozzie&quot;, &quot;Beaker&quot;))
        .forEach(System.out::println);
    }
}
</code></pre>
<pre><code class="lang-java">import java.util.*;
import java.util.stream.*;

public class StreamOfRandoms {
  static Random rand = new Random(47);
  public static void main(String[] args) {
    Stream.of(1, 2, 3, 4, 5)
      .flatMapToInt(i -&gt; IntStream.concat(
        rand.ints(0, 100).limit(i), IntStream.of(-1)))
      .forEach(n -&gt; System.out.format(&quot;%d &quot;, n));
  }
}
/* Output:
58 -1 55 93 -1 61 61 29 -1 68 0 22 7 -1 88 28 51 89 9
-1
*/
</code></pre>
<p>在这里我们引入了 <code>concat()</code>，它以参数顺序组合两个流。 如此，我们在每个随机 <code>Integer</code> 流的末尾添加一个 -1 作为标记。你可以看到最终流确实是从一组扁平流中创建的。</p>
<p>现有一个任务：去除字符串数组中出现多次的字母。</p>
<pre><code class="lang-java">import java.util.*;
import java.util.stream.*;

public class Test {
    public static void main(String[] args) {
        String[] words = new String[]{&quot;Hello&quot;, &quot;World&quot;};
        Arrays.stream(words)
                .map(word -&gt; word.split(&quot;&quot;))    //[1]
                .distinct()
                .forEach(System.out::print);
    }
}
//[Ljava.lang.String;@30c7da1e[Ljava.lang.String;@5b464ce8
</code></pre>
<p>该方法在第一步将每个元素分成了String数组，得到的类型是Stream(String[]),比较两个流元素之间的差异，发现它们不同(两个数组比较)</p>
<p><img src="/EruLv.github.io/2020/08/18/java%E5%9F%BA%E7%A1%802/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20201002162307882.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20201002162307882"></p>
<p>正确的做法应该是</p>
<pre><code class="lang-java">import java.util.*;
import java.util.stream.*;

public class Test {
    public static void main(String[] args) {
        String[] words = new String[]{&quot;Hello&quot;, &quot;World&quot;};
        Arrays.stream(words)
                .map(word -&gt; word.split(&quot;&quot;))
                .flatMap(Arrays::stream)
                .distinct()
                .forEach(System.out::print);
    }
}
//HeloWrd
</code></pre>
<p>flatMap将两个流合并，即把二维数组降成一维。</p>
<p><img src="/EruLv.github.io/2020/08/18/java%E5%9F%BA%E7%A1%802/Users\hp\AppData\Roaming\Typora\typora-user-images\image-20201002162630124.png" srcset="/EruLv.github.io/img/loading.gif" alt="image-20201002162630124"></p>
<h3 id="3-Optional类"><a href="#3-Optional类" class="headerlink" title="3.Optional类"></a>3.Optional类</h3><p>Optional类解决流为空的问题。</p>
<ul>
<li><code>findFirst()</code> 返回一个包含第一个元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li>
<li><code>findAny()</code> 返回包含任意元素的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li>
<li><code>max()</code> 和 <code>min()</code> 返回一个包含最大值或者最小值的 <strong>Optional</strong> 对象，如果流为空则返回 <strong>Optional.empty</strong></li>
</ul>
<p>空流可以通过 <code>Stream.&lt;String&gt;empty()</code> 创建。</p>
<pre><code class="lang-java">// streams/OptionalBasics.java
import java.util.*;
import java.util.stream.*;
class OptionalBasics {
    static void test(Optional&lt;String&gt; optString) {
        if(optString.isPresent())
            System.out.println(optString.get()); 
        else
            System.out.println(&quot;Nothing inside!&quot;);
    }
    public static void main(String[] args) {
        test(Stream.of(&quot;Epithets&quot;).findFirst());
        test(Stream.&lt;String&gt;empty().findFirst());
    }
}
//Epithets
//Nothing inside!
</code></pre>
<p>当你接收到 <strong>Optional</strong> 对象时，应首先调用 <code>isPresent()</code> 检查其中是否包含元素。如果存在，可使用 <code>get()</code> 获取。</p>
<p><strong>便利函数</strong></p>
<p>有许多便利函数可以解包 <strong>Optional</strong> ，这简化了上述“对所包含的对象的检查和执行操作”的过程：</p>
<ul>
<li><code>ifPresent(Consumer)</code>：当值存在时调用 <strong>Consumer</strong>，否则什么也不做。</li>
<li><code>orElse(otherObject)</code>：如果值存在则直接返回，否则生成 <strong>otherObject</strong>。</li>
<li><code>orElseGet(Supplier)</code>：如果值存在则直接返回，否则使用 <strong>Supplier</strong> 函数生成一个可替代对象。</li>
<li><code>orElseThrow(Supplier)</code>：如果值存在直接返回，否则使用 <strong>Supplier</strong> 函数生成一个异常。</li>
</ul>
<pre><code class="lang-java">package streams;// streams/Optionals.java
// (c)2017 MindView LLC: see Copyright.txt
// We make no guarantees that this code is fit for any purpose.
// Visit http://OnJava8.com for more book information.
import java.util.*;
import java.util.stream.*;
import java.util.function.*;

public class Optionals {
  static void basics(Optional&lt;String&gt; optString) {
    if(optString.isPresent())
      System.out.println(optString.get());
    else
      System.out.println(&quot;Nothing inside!&quot;);
  }
  static void ifPresent(Optional&lt;String&gt; optString) {
    optString.ifPresent(System.out::println);
  }
  static void orElse(Optional&lt;String&gt; optString) {
    System.out.println(optString.orElse(&quot;Nada&quot;));
  }
  static void orElseGet(Optional&lt;String&gt; optString) {
    System.out.println(
      optString.orElseGet(() -&gt; &quot;Generated&quot;));
  }
  static void orElseThrow(Optional&lt;String&gt; optString) {
    try {
      System.out.println(optString.orElseThrow(
        () -&gt; new Exception(&quot;Supplied&quot;)));
    } catch(Exception e) {
      System.out.println(&quot;Caught &quot; + e);
    }
  }
  static void test(String testName,
    Consumer&lt;Optional&lt;String&gt;&gt; cos) {
    System.out.println(&quot; === &quot; + testName + &quot; === &quot;);
    cos.accept(Stream.of(&quot;Epithets&quot;).findFirst());
    cos.accept(Stream.&lt;String&gt;empty().findFirst());
  }
  public static void main(String[] args) {
    test(&quot;basics&quot;, Optionals::basics);
    test(&quot;ifPresent&quot;, Optionals::ifPresent);
    test(&quot;orElse&quot;, Optionals::orElse);
    test(&quot;orElseGet&quot;, Optionals::orElseGet);
    test(&quot;orElseThrow&quot;, Optionals::orElseThrow);
  }
}
/* Output:
 === basics ===
Epithets
Nothing inside!
 === ifPresent ===
Epithets
 === orElse ===
Epithets
Nada
 === orElseGet ===
Epithets
Generated
 === orElseThrow ===
Epithets
Caught java.lang.Exception: Supplied
*/
</code></pre>
<p><strong>创建Optional</strong></p>
<p>当我们在自己的代码中加入 <strong>Optional</strong> 时，可以使用下面 3 个静态方法：</p>
<ul>
<li><code>empty()</code>：生成一个空 <strong>Optional</strong>。</li>
<li><code>of(value)</code>：将一个非空值包装到 <strong>Optional</strong> 里。</li>
<li><code>ofNullable(value)</code>：针对一个可能为空的值，为空时自动生成 <strong>Optional.empty</strong>，否则将值包装在 <strong>Optional</strong> 中。</li>
</ul>
<pre><code class="lang-java">package streams;// streams/CreatingOptionals.java
// (c)2017 MindView LLC: see Copyright.txt
// We make no guarantees that this code is fit for any purpose.
// Visit http://OnJava8.com for more book information.
import java.util.*;
import java.util.stream.*;
import java.util.function.*;

class CreatingOptionals {
  static void test(String testName, Optional&lt;String&gt; opt) {
    System.out.println(&quot; === &quot; + testName + &quot; === &quot;);
    System.out.println(opt.orElse(&quot;Null&quot;));
  }

  public static void main(String[] args) {
    test(&quot;empty&quot;, Optional.empty());
    test(&quot;of&quot;, Optional.of(&quot;Howdy&quot;));
    try {
      test(&quot;of&quot;, Optional.of(null));
    } catch(Exception e) {
      System.out.println(e);
    }
    test(&quot;ofNullable&quot;, Optional.ofNullable(&quot;Hi&quot;));
    test(&quot;ofNullable&quot;, Optional.ofNullable(null));
  }
}
/* Output:
 === empty ===
Null
 === of ===
Howdy
java.lang.NullPointerException
 === ofNullable ===
Hi
 === ofNullable ===
Null
*/
</code></pre>
<p><strong>Optional对象操作</strong></p>
<p>当我们的流管道生成了 <strong>Optional</strong> 对象，下面 3 个方法可使得 <strong>Optional</strong> 的后续能做更多的操作：</p>
<ul>
<li><code>filter(Predicate)</code>：对 <strong>Optional</strong> 中的内容应用<strong>Predicate</strong> 并将结果返回。如果 <strong>Optional</strong> 不满足 <strong>Predicate</strong>(false) ，将 <strong>Optional</strong> 转化为空 <strong>Optional</strong> 。如果 <strong>Optional</strong> 已经为空，则直接返回空<strong>Optional</strong> 。</li>
<li><code>map(Function)</code>：如果 <strong>Optional</strong> 不为空，应用 <strong>Function</strong> 于 <strong>Optional</strong> 中的内容，并返回结果。否则直接返回 <strong>Optional.empty</strong>。</li>
<li><code>flatMap(Function)</code>：同 <code>map()</code>，但是提供的映射函数将结果包装在 <strong>Optional</strong> 对象中，因此 <code>flatMap()</code> 不会在最后进行任何包装。</li>
</ul>
<p>以上方法都不适用于数值型 <strong>Optional</strong>。一般来说，流的 <code>filter()</code> 会在 <strong>Predicate</strong> 返回 <code>false</code> 时移除流元素。而 <code>Optional.filter()</code> 在失败时不会删除 <strong>Optional</strong>，而是将其保留下来，并转化为空。</p>
<pre><code class="lang-java">package streams;// streams/OptionalFilter.java
// (c)2017 MindView LLC: see Copyright.txt
// We make no guarantees that this code is fit for any purpose.
// Visit http://OnJava8.com for more book information.
import java.util.*;
import java.util.stream.*;
import java.util.function.*;

class OptionalFilter {
  static String[] elements = {
    &quot;Foo&quot;, &quot;&quot;, &quot;Bar&quot;, &quot;Baz&quot;, &quot;Bingo&quot;
  };
  static Stream&lt;String&gt; testStream() {
    return Arrays.stream(elements);
  }
  static void
  test(String descr, Predicate&lt;String&gt; pred) {
    System.out.println(&quot; ---( &quot; + descr + &quot; )---&quot;);
    for(int i = 0; i &lt;= elements.length; i++) {
      System.out.println(
        testStream()
          .skip(i)
          .findFirst()
          .filter(pred));
    }
  }
  public static void main(String[] args) {
    test(&quot;true&quot;, str -&gt; true);
    test(&quot;false&quot;, str -&gt; false);
    test(&quot;str != \&quot;\&quot;&quot;, str -&gt; str != &quot;&quot;);
    test(&quot;str.length() == 3&quot;, str -&gt; str.length() == 3);
    test(&quot;startsWith(\&quot;B\&quot;)&quot;,
         str -&gt; str.startsWith(&quot;B&quot;));
  }
}
/* Output:
 ---( true )---
Optional[Foo]
Optional[]
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
 ---( false )---
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
Optional.empty
 ---( str != &quot;&quot; )---
Optional[Foo]
Optional.empty
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
 ---( str.length() == 3 )---
Optional[Foo]
Optional.empty
Optional[Bar]
Optional[Baz]
Optional.empty
Optional.empty
 ---( startsWith(&quot;B&quot;) )---
Optional.empty
Optional.empty
Optional[Bar]
Optional[Baz]
Optional[Bingo]
Optional.empty
*/
</code></pre>
<h3 id="4-终端操作"><a href="#4-终端操作" class="headerlink" title="4.终端操作"></a>4.终端操作</h3><p>获取流的最终结果。</p>
<p><strong>数组</strong></p>
<ul>
<li><code>toArray()</code>：将流转换成适当类型的数组。</li>
<li><code>toArray(generator)</code>：在特殊情况下，生成自定义类型的数组</li>
</ul>
<pre><code class="lang-java">// streams/RandInts.java
package streams;
import java.util.*;
import java.util.stream.*;
public class RandInts {
    private static int[] rints = new Random(47).ints(0, 1000).limit(100).toArray();
    public static IntStream rands() {
        return Arrays.stream(rints);
    }
}
</code></pre>
<p><strong>循环</strong></p>
<ul>
<li><code>forEach(Consumer)</code>常见如 <code>System.out::println</code> 作为 <strong>Consumer</strong> 函数。</li>
<li><code>forEachOrdered(Consumer)</code>： 保证 <code>forEach</code> 按照原始流顺序操作。</li>
</ul>
<p>第一种形式是无序操作，在引入并行流时会和<code>forEachOrdered(Consumer)</code>有区别。<code>parallel()</code>：可实现多处理器并行操作。实现原理为将流分割为多个（通常数目为 CPU 核心数）并在不同处理器上分别执行操作。因为我们采用的是内部迭代，而不是外部迭代，所以这是可能实现的。</p>
<p><strong>集合</strong></p>
<ul>
<li><code>collect(Collector)</code>：使用 <strong>Collector</strong> 收集流元素到结果集合中。</li>
<li><code>collect(Supplier, BiConsumer, BiConsumer)</code>：同上，第一个参数 <strong>Supplier</strong> 创建了一个新的结果集合，第二个参数 <strong>BiConsumer</strong> 将下一个元素收集到结果集合中，第三个参数 <strong>BiConsumer</strong> 用于将两个结果集合合并起来</li>
</ul>
<pre><code class="lang-java">package streams;// streams/TreeSetOfWords.java
// (c)2017 MindView LLC: see Copyright.txt
// We make no guarantees that this code is fit for any purpose.
// Visit http://OnJava8.com for more book information.
import java.util.*;
import java.nio.file.*;
import java.util.stream.*;

public class TreeSetOfWords {
  public static void
  main(String[] args) throws Exception {
    Set&lt;String&gt; words2 =
      Files.lines(Paths.get(&quot;src/streams/TreeSetOfWords.java&quot;))
        .peek(System.out::println)
        .flatMap(s -&gt; Arrays.stream(s.split(&quot;\\W+&quot;)))
        .filter(s -&gt; !s.matches(&quot;\\d+&quot;)) // No numbers
        .map(String::trim)
        .filter(s -&gt; s.length() &gt; 2)
        .limit(100)
        .collect(Collectors.toCollection(TreeSet::new));
    System.out.println(words2);
  }
}

/* Output:
[Arrays, Collectors, Exception, Files, Output, Paths,
Set, String, System, TreeSet, TreeSetOfWords, args,
class, collect, file, filter, flatMap, get, import,
java, length, limit, lines, main, map, matches, new,
nio, numbers, out, println, public, split, static,
stream, streams, throws, toCollection, trim, util,
void, words2]
*/
</code></pre>
<p><strong>Files.</strong><code>lines()</code> 打开 <strong>Path</strong> 并将其转换成为由行组成的流。下一行代码以一个或多个非单词字符（<code>\\W+</code>）为分界，对每一行进行分割，结果是产生一个数组，然后使用 <strong>Arrays.</strong><code>stream()</code> 将数组转化成为流，最后<code>flatMap()</code>将各行形成的多个单词流，扁平映射为一个单词流。使用 <code>matches(\\d+)</code> 查找并移除全部是数字的字符串（注意,<code>words2</code> 是通过的）。然后用 <strong>String.</strong><code>trim()</code> 去除单词两边的空白，<code>filter()</code> 过滤所有长度小于3的单词，并只获取前100个单词，最后将其保存到 <strong>TreeSet</strong> 中。</p>
<p><strong>组合</strong></p>
<ul>
<li><code>reduce(BinaryOperator)</code>：使用 <strong>BinaryOperator</strong> 来组合所有流中的元素。因为流可能为空，其返回值为 <strong>Optional</strong>。</li>
<li><code>reduce(identity, BinaryOperator)</code>：功能同上，但是使用 <strong>identity</strong> 作为其组合的初始值。因此如果流为空，<strong>identity</strong> 就是结果。</li>
<li><code>reduce(identity, BiFunction, BinaryOperator)</code>：更复杂的使用形式（暂不介绍），这里把它包含在内，因为它可以提高效率。通常，我们可以显式地组合 <code>map()</code> 和 <code>reduce()</code> 来更简单的表达它。</li>
</ul>
<p>Lambda 表达式中的第一个参数 <code>fr0</code> 是 <code>reduce()</code> 中上一次调用的结果。而第二个参数 <code>fr1</code> 是从流传递过来的值。</p>
<pre><code class="lang-java">class Frobnitz {
  int size;
  Frobnitz(int sz) { size = sz; }
  @Override
  public String toString() {
    return &quot;Frobnitz(&quot; + size + &quot;)&quot;;
  }
  // Generator:
  static Random rand = new Random(47);
  static final int BOUND = 100;
  static Frobnitz supply() {
    return new Frobnitz(rand.nextInt(BOUND));
  }
}

public class Reduce {
  public static void main(String[] args) {
    Stream.generate(Frobnitz::supply)
      .limit(10)
      .peek(System.out::println)
      .reduce((fr0, fr1) -&gt; fr0.size &lt; 50 ? fr0 : fr1)
      .ifPresent(System.out::println);
  }
}
</code></pre>
<p><code>reduce()</code> 中的 Lambda 表达式使用了三元表达式来获取结果，当 <code>fr0</code> 的 <code>size</code> 值小于 50 的时候，将 <code>fr0</code> 作为结果，否则将序列中的下一个元素即 <code>fr1</code>作为结果。当取得第一个 <code>size</code> 值小于 50 的 <code>Frobnitz</code>，只要得到这个结果就会忽略流中其他元素。这是个非常奇怪的限制， 但也确实让我们对 <code>reduce()</code> 有了更多的了解。</p>
<p><strong>匹配</strong></p>
<ul>
<li><code>allMatch(Predicate)</code> ：如果流的每个元素提供给 <strong>Predicate</strong> 都返回 true ，结果返回为 true。在第一个 false 时，则停止执行计算。</li>
<li><code>anyMatch(Predicate)</code>：如果流的任意一个元素提供给 <strong>Predicate</strong> 返回 true ，结果返回为 true。在第一个 true 是停止执行计算。</li>
<li><p><code>noneMatch(Predicate)</code>：如果流的每个元素提供给 <strong>Predicate</strong> 都返回 false 时，结果返回为 true。在第一个 true 时停止执行计算。</p>
<p><strong>查找</strong></p>
</li>
<li><p><code>findFirst()</code>：返回第一个流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</p>
</li>
<li><code>findAny(</code>：返回含有任意流元素的 <strong>Optional</strong>，如果流为空返回 <strong>Optional.empty</strong>。</li>
</ul>
<p><strong>信息</strong></p>
<ul>
<li><code>count()</code>：流中的元素个数。</li>
<li><code>max(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最大”元素。</li>
<li><code>min(Comparator)</code>：根据所传入的 <strong>Comparator</strong> 所决定的“最小”元素。</li>
</ul>
<p><strong>数字流信息</strong></p>
<ul>
<li><code>average()</code> ：求取流元素平均值。</li>
<li><code>max()</code> 和 <code>min()</code>：数值流操作无需 <strong>Comparator</strong>。</li>
<li><p><code>sum()</code>：对所有流元素进行求和。</p>
</li>
<li><p><code>summaryStatistics()</code>：生成可能有用的数据。目前并不太清楚这个方法存在的必要性，因为我们其实可以用更直接的方法获得需要的数据。</p>
</li>
</ul>

            </div>
            <hr>
            <div>
              <p>
                
                
                  <span>
                <i class="iconfont icon-tag"></i>
                    
                      <a class="hover-with-bg" href="/EruLv.github.io/tags/java/">java</a>
                    
                  </span>
                
              </p>
              
                <p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p>
              
              
                <div class="post-prevnext row">
                  <div class="post-prev col-12 col-md-6">
                    
                      <a href="/EruLv.github.io/2020/10/03/java%E5%9F%BA%E7%A1%803/">
                        <i class="fa fa-chevron-left"></i>
                        <span>java基础3</span>
                      </a>
                    
                  </div>
                  <div class="post-next col-12 col-md-6">
                    
                      <a href="/EruLv.github.io/2020/08/18/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/">
                        <span>计算机图形学复习</span>
                        <i class="fa fa-chevron-right"></i>
                      </a>
                    
                  </div>
                </div>
              
            </div>

              
                <!-- Comments -->
                <div class="comments" id="comments">
                  
                  

                </div>
            
          </div>
        </div>
      </div>
    </div>
    
      <div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn">
        <div id="toc-start"></div>
<div id="toc">
  <p class="h5"><i class="far fa-list-alt"></i>&nbsp;目录</p>
  <div id="tocbot"></div>
</div>

      </div>
    
  </div>
</div>

<!-- Custom -->


    
  </main>

  
    <a class="z-depth-1" id="scroll-top-button" href="#" role="button">
      <i class="fa fa-chevron-up scroll-top-arrow" aria-hidden="true"></i>
    </a>
  

  
    <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v"
                 for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>
  

  

  

  <footer class="mt-5">

  <div class="text-center py-3">
    <div>
      <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><b>Hexo</b></a>
      <i class="iconfont icon-love"></i>
      <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"> <b>Fluid</b></a>
    </div>
    

    

    
  </div>
</footer>

<!-- SCRIPTS -->
<script  src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js" ></script>
<script  src="https://cdn.staticfile.org/popper.js/1.16.1/umd/popper.min.js" ></script>
<script  src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js" ></script>
<script  src="https://cdn.staticfile.org/mdbootstrap/4.13.0/js/mdb.min.js" ></script>
<script  src="/EruLv.github.io/js/main.js" ></script>


  <script  src="/EruLv.github.io/js/lazyload.js" ></script>



  
  <script  src="https://cdn.staticfile.org/tocbot/4.10.0/tocbot.min.js" ></script>
  <script>
    $(document).ready(function () {
      var navHeight = $('#navbar').height();
      var toc = $('#toc');
      var boardCtn = $('#board-ctn');
      var boardTop = boardCtn.offset().top;
      var tocLimMax = 2 * boardTop + boardCtn.height();

      $(window).scroll(function () {
        var tocLimMin = $('#toc-start').offset().top - navHeight;
        var scroH = document.body.scrollTop + document.documentElement.scrollTop;

        if (tocLimMin <= scroH && scroH <= tocLimMax) {
          toc.css({
            'display': 'block',
            'position': 'fixed',
            'top': navHeight,
          });
        } else if (scroH <= tocLimMin) {
          toc.css({
            'position': '',
            'top': '',
          });
        } else if (scroH > tocLimMax) {
          toc.css('display', 'none');
        }
      });
      tocbot.init({
        tocSelector: '#tocbot',
        contentSelector: '.post-content',
        headingSelector: 'h1,h2,h3,h4,h5,h6',
        linkClass: 'tocbot-link',
        activeLinkClass: 'tocbot-active-link',
        listClass: 'tocbot-list',
        isCollapsedClass: 'tocbot-is-collapsed',
        collapsibleClass: 'tocbot-is-collapsible',
        scrollSmooth: true,
        headingsOffset: -boardTop
      });
      if ($('.toc-list-item').length > 0) {
        $('#toc > p').css('visibility', 'visible');
      }
      var offset = boardCtn.css('margin-right')
      $('#toc-ctn').css({
        'right': offset
      })
    });
  </script>










<!-- Plugins -->



  <script  src="https://cdn.staticfile.org/prettify/188.0.0/prettify.min.js" ></script>
  <script>
    $(document).ready(function () {
      $('pre').addClass('prettyprint  linenums');
      prettyPrint();
    })
  </script>



  <script  src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js" ></script>
  <script>
    var typed = new Typed('#subtitle', {
      strings: [
        '  ',
        "java基础2&nbsp;",
      ],
      cursorChar: "_",
      typeSpeed: 70,
      loop: false,
    });
    typed.stop();
    $(document).ready(function () {
      $(".typed-cursor").addClass("h2");
      typed.start();
    });
  </script>



  <script  src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js" ></script>
  <script>
    anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))
  </script>



  <script  src="/EruLv.github.io/js/local-search.js" ></script>
  <script>
    var path = "/EruLv.github.io/local-search.xml";
    var inputArea = document.querySelector("#local-search-input");
    inputArea.onclick = function () {
      getSearchFile(path);
      this.onclick = null
    }
  </script>



  <script defer src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js" ></script>
  <script>
    $("#post img:not(.no-zoom img, img[no-zoom])").each(
      function () {
        var element = document.createElement("a");
        $(element).attr("data-fancybox", "images");
        $(element).attr("href", $(this).attr("src"));
        $(this).wrap(element);
      }
    );
  </script>



  

  
    <!-- MathJax -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
          tex2jax: {
              inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
              processEscapes: true,
              skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
          }
      });

      MathJax.Hub.Queue(function() {
          var all = MathJax.Hub.getAllJax(), i;
          for(i=0; i < all.length; i += 1) {
              all[i].SourceElement().parentNode.className += ' has-jax';
          }
      });

    </script>

    <script  src="https://cdn.staticfile.org/mathjax/2.7.7/MathJax.js?config=TeX-MML-AM_CHTML" ></script>

  










</body>
</html>
